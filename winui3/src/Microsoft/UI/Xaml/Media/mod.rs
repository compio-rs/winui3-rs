// Bindings generated by `windows-bindgen` 0.61.1

#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]

#[cfg(feature = "UI_Xaml_Media_Animation")]
pub mod Animation;
#[cfg(feature = "UI_Xaml_Media_Imaging")]
pub mod Imaging;
#[cfg(feature = "UI_Xaml_Media_Media3D")]
pub mod Media3D;
#[cfg(feature = "UI_Composition")]
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct AcrylicBrush(windows_core::IUnknown);
#[cfg(feature = "UI_Composition")]
windows_core::imp::interface_hierarchy!(
    AcrylicBrush,
    windows_core::IUnknown,
    windows_core::IInspectable
);
#[cfg(feature = "UI_Composition")]
windows_core::imp::required_hierarchy!(
    AcrylicBrush,
    super::super::Composition::IAnimationObject,
    XamlCompositionBrushBase,
    Brush,
    super::DependencyObject
);
#[cfg(feature = "UI_Composition")]
impl AcrylicBrush {
    pub fn TintColor(&self) -> windows_core::Result<windows::UI::Color> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TintColor)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetTintColor(&self, value: windows::UI::Color) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetTintColor)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn TintOpacity(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TintOpacity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetTintOpacity(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetTintOpacity)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn TintTransitionDuration(&self) -> windows_core::Result<windows::Foundation::TimeSpan> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TintTransitionDuration)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetTintTransitionDuration(
        &self,
        value: windows::Foundation::TimeSpan,
    ) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetTintTransitionDuration)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn AlwaysUseFallback(&self) -> windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AlwaysUseFallback)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAlwaysUseFallback(&self, value: bool) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAlwaysUseFallback)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn TintLuminosityOpacity(
        &self,
    ) -> windows_core::Result<windows::Foundation::IReference<f64>> {
        let this = &windows_core::Interface::cast::<IAcrylicBrush2>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TintLuminosityOpacity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTintLuminosityOpacity<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows::Foundation::IReference<f64>>,
    {
        let this = &windows_core::Interface::cast::<IAcrylicBrush2>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTintLuminosityOpacity)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn new() -> windows_core::Result<AcrylicBrush> {
        Self::IAcrylicBrushFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn TintColorProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IAcrylicBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TintColorProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn TintOpacityProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IAcrylicBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TintOpacityProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn TintTransitionDurationProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IAcrylicBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TintTransitionDurationProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn AlwaysUseFallbackProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IAcrylicBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AlwaysUseFallbackProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn TintLuminosityOpacityProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IAcrylicBrushStatics2(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TintLuminosityOpacityProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn PopulatePropertyInfo<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        propertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this =
            &windows_core::Interface::cast::<super::super::Composition::IAnimationObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfo)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                propertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn Opacity(&self) -> windows_core::Result<f64> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Opacity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetOpacity(&self, value: f64) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetOpacity)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RelativeTransform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RelativeTransform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetRelativeTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetRelativeTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn PopulatePropertyInfoOverride<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        animationpropertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this = &windows_core::Interface::cast::<IBrushOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfoOverride)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                animationpropertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn FallbackColor(&self) -> windows_core::Result<windows::UI::Color> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBase>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FallbackColor)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetFallbackColor(&self, value: windows::UI::Color) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBase>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetFallbackColor)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn OnConnected(&self) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnConnected)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn OnDisconnected(&self) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnDisconnected)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn CompositionBrush(
        &self,
    ) -> windows_core::Result<super::super::Composition::CompositionBrush> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseProtected>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CompositionBrush)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetCompositionBrush<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::CompositionBrush>,
    {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseProtected>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetCompositionBrush)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    fn IAcrylicBrushFactory<R, F: FnOnce(&IAcrylicBrushFactory) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<AcrylicBrush, IAcrylicBrushFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn IAcrylicBrushStatics<R, F: FnOnce(&IAcrylicBrushStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<AcrylicBrush, IAcrylicBrushStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn IAcrylicBrushStatics2<R, F: FnOnce(&IAcrylicBrushStatics2) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<AcrylicBrush, IAcrylicBrushStatics2> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeType for AcrylicBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IAcrylicBrush>();
}
#[cfg(feature = "UI_Composition")]
unsafe impl windows_core::Interface for AcrylicBrush {
    type Vtable = <IAcrylicBrush as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IAcrylicBrush as windows_core::Interface>::IID;
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for AcrylicBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.AcrylicBrush";
}
#[cfg(feature = "UI_Composition")]
unsafe impl Send for AcrylicBrush {}
#[cfg(feature = "UI_Composition")]
unsafe impl Sync for AcrylicBrush {}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AlignmentX(pub i32);
impl AlignmentX {
    pub const Left: Self = Self(0i32);
    pub const Center: Self = Self(1i32);
    pub const Right: Self = Self(2i32);
}
impl windows_core::TypeKind for AlignmentX {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for AlignmentX {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::from_slice(b"enum(Microsoft.UI.Xaml.Media.AlignmentX;i4)");
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct AlignmentY(pub i32);
impl AlignmentY {
    pub const Top: Self = Self(0i32);
    pub const Center: Self = Self(1i32);
    pub const Bottom: Self = Self(2i32);
}
impl windows_core::TypeKind for AlignmentY {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for AlignmentY {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::from_slice(b"enum(Microsoft.UI.Xaml.Media.AlignmentY;i4)");
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ArcSegment(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    ArcSegment,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(ArcSegment, PathSegment, super::DependencyObject);
impl ArcSegment {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            ArcSegment,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn Point(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetPoint(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetPoint)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Size(&self) -> windows_core::Result<windows::Foundation::Size> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Size)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetSize(&self, value: windows::Foundation::Size) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetSize)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn RotationAngle(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RotationAngle)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetRotationAngle(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetRotationAngle)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn IsLargeArc(&self) -> windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IsLargeArc)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetIsLargeArc(&self, value: bool) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetIsLargeArc)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn SweepDirection(&self) -> windows_core::Result<SweepDirection> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SweepDirection)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetSweepDirection(&self, value: SweepDirection) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetSweepDirection)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn PointProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IArcSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).PointProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn SizeProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IArcSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SizeProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn RotationAngleProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IArcSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RotationAngleProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn IsLargeArcProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IArcSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IsLargeArcProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn SweepDirectionProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IArcSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SweepDirectionProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    fn IArcSegmentStatics<R, F: FnOnce(&IArcSegmentStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<ArcSegment, IArcSegmentStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for ArcSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IArcSegment>();
}
unsafe impl windows_core::Interface for ArcSegment {
    type Vtable = <IArcSegment as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IArcSegment as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for ArcSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ArcSegment";
}
unsafe impl Send for ArcSegment {}
unsafe impl Sync for ArcSegment {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BezierSegment(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    BezierSegment,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(BezierSegment, PathSegment, super::DependencyObject);
impl BezierSegment {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            BezierSegment,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn Point1(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point1)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetPoint1(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetPoint1)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Point2(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point2)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetPoint2(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetPoint2)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Point3(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point3)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetPoint3(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetPoint3)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Point1Property() -> windows_core::Result<super::DependencyProperty> {
        Self::IBezierSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point1Property)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn Point2Property() -> windows_core::Result<super::DependencyProperty> {
        Self::IBezierSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point2Property)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn Point3Property() -> windows_core::Result<super::DependencyProperty> {
        Self::IBezierSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point3Property)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    fn IBezierSegmentStatics<R, F: FnOnce(&IBezierSegmentStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<BezierSegment, IBezierSegmentStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for BezierSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IBezierSegment>();
}
unsafe impl windows_core::Interface for BezierSegment {
    type Vtable = <IBezierSegment as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IBezierSegment as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for BezierSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.BezierSegment";
}
unsafe impl Send for BezierSegment {}
unsafe impl Sync for BezierSegment {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BitmapCache(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    BitmapCache,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(BitmapCache, CacheMode, super::DependencyObject);
impl BitmapCache {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            BitmapCache,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
impl windows_core::RuntimeType for BitmapCache {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IBitmapCache>();
}
unsafe impl windows_core::Interface for BitmapCache {
    type Vtable = <IBitmapCache as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IBitmapCache as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for BitmapCache {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.BitmapCache";
}
unsafe impl Send for BitmapCache {}
unsafe impl Sync for BitmapCache {}
#[cfg(feature = "UI_Composition")]
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Brush(windows_core::IUnknown);
#[cfg(feature = "UI_Composition")]
windows_core::imp::interface_hierarchy!(Brush, windows_core::IUnknown, windows_core::IInspectable);
#[cfg(feature = "UI_Composition")]
windows_core::imp::required_hierarchy!(
    Brush,
    super::super::Composition::IAnimationObject,
    super::DependencyObject
);
#[cfg(feature = "UI_Composition")]
impl Brush {
    pub fn PopulatePropertyInfo<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        propertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this =
            &windows_core::Interface::cast::<super::super::Composition::IAnimationObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfo)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                propertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn Opacity(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Opacity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetOpacity(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetOpacity)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RelativeTransform(&self) -> windows_core::Result<Transform> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RelativeTransform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetRelativeTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetRelativeTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn new() -> windows_core::Result<Brush> {
        Self::IBrushFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn PopulatePropertyInfoOverride<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        animationpropertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this = &windows_core::Interface::cast::<IBrushOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfoOverride)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                animationpropertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn OpacityProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).OpacityProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn TransformProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn RelativeTransformProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RelativeTransformProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    fn IBrushFactory<R, F: FnOnce(&IBrushFactory) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<Brush, IBrushFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn IBrushStatics<R, F: FnOnce(&IBrushStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<Brush, IBrushStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeType for Brush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IBrush>();
}
#[cfg(feature = "UI_Composition")]
unsafe impl windows_core::Interface for Brush {
    type Vtable = <IBrush as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IBrush as windows_core::Interface>::IID;
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for Brush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.Brush";
}
#[cfg(feature = "UI_Composition")]
unsafe impl Send for Brush {}
#[cfg(feature = "UI_Composition")]
unsafe impl Sync for Brush {}
#[cfg(feature = "UI_Composition")]
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct BrushCollection(windows_core::IUnknown);
#[cfg(feature = "UI_Composition")]
windows_core::imp::interface_hierarchy!(
    BrushCollection,
    windows_core::IUnknown,
    windows_core::IInspectable,
    windows_collections::IVector<Brush>
);
#[cfg(feature = "UI_Composition")]
windows_core::imp::required_hierarchy!(BrushCollection, windows_collections::IIterable<Brush>);
#[cfg(feature = "UI_Composition")]
impl BrushCollection {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            BrushCollection,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn First(&self) -> windows_core::Result<windows_collections::IIterator<Brush>> {
        let this = &windows_core::Interface::cast::<windows_collections::IIterable<Brush>>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).First)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAt(&self, index: u32) -> windows_core::Result<Brush> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAt)(
                windows_core::Interface::as_raw(this),
                index,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Size(&self) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Size)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn GetView(&self) -> windows_core::Result<windows_collections::IVectorView<Brush>> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetView)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn IndexOf<P0>(&self, value: P0, index: &mut u32) -> windows_core::Result<bool>
    where
        P0: windows_core::Param<Brush>,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IndexOf)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
                index,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<Brush>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn InsertAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<Brush>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).InsertAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAt(&self, index: u32) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAt)(
                windows_core::Interface::as_raw(this),
                index,
            )
            .ok()
        }
    }
    pub fn Append<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Brush>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Append)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAtEnd(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAtEnd)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn Clear(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Clear)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
    pub fn GetMany(
        &self,
        startindex: u32,
        items: &mut [Option<Brush>],
    ) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetMany)(
                windows_core::Interface::as_raw(this),
                startindex,
                items.len().try_into().unwrap(),
                core::mem::transmute_copy(&items),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn ReplaceAll(&self, items: &[Option<Brush>]) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).ReplaceAll)(
                windows_core::Interface::as_raw(this),
                items.len().try_into().unwrap(),
                core::mem::transmute(items.as_ptr()),
            )
            .ok()
        }
    }
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeType for BrushCollection {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, windows_collections::IVector<Brush>>();
}
#[cfg(feature = "UI_Composition")]
unsafe impl windows_core::Interface for BrushCollection {
    type Vtable = <windows_collections::IVector<Brush> as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID =
        <windows_collections::IVector<Brush> as windows_core::Interface>::IID;
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for BrushCollection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.BrushCollection";
}
#[cfg(feature = "UI_Composition")]
unsafe impl Send for BrushCollection {}
#[cfg(feature = "UI_Composition")]
unsafe impl Sync for BrushCollection {}
#[cfg(feature = "UI_Composition")]
impl IntoIterator for BrushCollection {
    type Item = Brush;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        IntoIterator::into_iter(&self)
    }
}
#[cfg(feature = "UI_Composition")]
impl IntoIterator for &BrushCollection {
    type Item = Brush;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        self.First().unwrap()
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct BrushMappingMode(pub i32);
impl BrushMappingMode {
    pub const Absolute: Self = Self(0i32);
    pub const RelativeToBoundingBox: Self = Self(1i32);
}
impl windows_core::TypeKind for BrushMappingMode {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for BrushMappingMode {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::from_slice(
        b"enum(Microsoft.UI.Xaml.Media.BrushMappingMode;i4)",
    );
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct CacheMode(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    CacheMode,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(CacheMode, super::DependencyObject);
impl CacheMode {
    pub fn new() -> windows_core::Result<CacheMode> {
        Self::ICacheModeFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    fn ICacheModeFactory<R, F: FnOnce(&ICacheModeFactory) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<CacheMode, ICacheModeFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for CacheMode {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ICacheMode>();
}
unsafe impl windows_core::Interface for CacheMode {
    type Vtable = <ICacheMode as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ICacheMode as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for CacheMode {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.CacheMode";
}
unsafe impl Send for CacheMode {}
unsafe impl Sync for CacheMode {}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct ColorInterpolationMode(pub i32);
impl ColorInterpolationMode {
    pub const ScRgbLinearInterpolation: Self = Self(0i32);
    pub const SRgbLinearInterpolation: Self = Self(1i32);
}
impl windows_core::TypeKind for ColorInterpolationMode {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for ColorInterpolationMode {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::from_slice(
        b"enum(Microsoft.UI.Xaml.Media.ColorInterpolationMode;i4)",
    );
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct CompositeTransform(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    CompositeTransform,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(
    CompositeTransform,
    Transform,
    GeneralTransform,
    super::DependencyObject
);
impl CompositeTransform {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            CompositeTransform,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn CenterX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenterX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenterX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenterY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenterY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn ScaleX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ScaleX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetScaleX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetScaleX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn ScaleY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ScaleY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetScaleY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetScaleY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn SkewX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SkewX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetSkewX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetSkewX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn SkewY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SkewY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetSkewY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetSkewY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Rotation(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Rotation)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetRotation(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetRotation)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn TranslateX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TranslateX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetTranslateX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetTranslateX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn TranslateY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TranslateY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetTranslateY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetTranslateY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ICompositeTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn CenterYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ICompositeTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn ScaleXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ICompositeTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ScaleXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn ScaleYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ICompositeTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ScaleYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn SkewXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ICompositeTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SkewXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn SkewYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ICompositeTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SkewYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn RotationProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ICompositeTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RotationProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn TranslateXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ICompositeTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TranslateXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn TranslateYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ICompositeTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TranslateYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Inverse(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Inverse)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TransformPoint(
        &self,
        point: windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformPoint)(
                windows_core::Interface::as_raw(this),
                point,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TryTransform(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransform)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBounds(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBounds)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn InverseCore(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).InverseCore)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TryTransformCore(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransformCore)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBoundsCore(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBoundsCore)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    fn ICompositeTransformStatics<
        R,
        F: FnOnce(&ICompositeTransformStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            CompositeTransform,
            ICompositeTransformStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for CompositeTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ICompositeTransform>();
}
unsafe impl windows_core::Interface for CompositeTransform {
    type Vtable = <ICompositeTransform as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ICompositeTransform as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for CompositeTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.CompositeTransform";
}
unsafe impl Send for CompositeTransform {}
unsafe impl Sync for CompositeTransform {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct CompositionTarget(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    CompositionTarget,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl CompositionTarget {
    pub fn Rendering<P0>(handler: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<windows::Foundation::EventHandler<windows_core::IInspectable>>,
    {
        Self::ICompositionTargetStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Rendering)(
                windows_core::Interface::as_raw(this),
                handler.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        })
    }
    pub fn RemoveRendering(token: i64) -> windows_core::Result<()> {
        Self::ICompositionTargetStatics(|this| unsafe {
            (windows_core::Interface::vtable(this).RemoveRendering)(
                windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        })
    }
    pub fn Rendered<P0>(handler: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<windows::Foundation::EventHandler<RenderedEventArgs>>,
    {
        Self::ICompositionTargetStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Rendered)(
                windows_core::Interface::as_raw(this),
                handler.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        })
    }
    pub fn RemoveRendered(token: i64) -> windows_core::Result<()> {
        Self::ICompositionTargetStatics(|this| unsafe {
            (windows_core::Interface::vtable(this).RemoveRendered)(
                windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        })
    }
    pub fn SurfaceContentsLost<P0>(handler: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<windows::Foundation::EventHandler<windows_core::IInspectable>>,
    {
        Self::ICompositionTargetStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SurfaceContentsLost)(
                windows_core::Interface::as_raw(this),
                handler.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        })
    }
    pub fn RemoveSurfaceContentsLost(token: i64) -> windows_core::Result<()> {
        Self::ICompositionTargetStatics(|this| unsafe {
            (windows_core::Interface::vtable(this).RemoveSurfaceContentsLost)(
                windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        })
    }
    #[cfg(feature = "UI_Composition")]
    pub fn GetCompositorForCurrentThread(
    ) -> windows_core::Result<super::super::Composition::Compositor> {
        Self::ICompositionTargetStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetCompositorForCurrentThread)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn ICompositionTargetStatics<
        R,
        F: FnOnce(&ICompositionTargetStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            CompositionTarget,
            ICompositionTargetStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for CompositionTarget {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ICompositionTarget>();
}
unsafe impl windows_core::Interface for CompositionTarget {
    type Vtable = <ICompositionTarget as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ICompositionTarget as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for CompositionTarget {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.CompositionTarget";
}
unsafe impl Send for CompositionTarget {}
unsafe impl Sync for CompositionTarget {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DesktopAcrylicBackdrop(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    DesktopAcrylicBackdrop,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(
    DesktopAcrylicBackdrop,
    SystemBackdrop,
    super::DependencyObject
);
impl DesktopAcrylicBackdrop {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn new() -> windows_core::Result<DesktopAcrylicBackdrop> {
        Self::IDesktopAcrylicBackdropFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    #[cfg(feature = "UI_Composition_SystemBackdrops")]
    pub fn GetDefaultSystemBackdropConfiguration<P0, P1>(
        &self,
        target: P0,
        xamlroot: P1,
    ) -> windows_core::Result<super::super::Composition::SystemBackdrops::SystemBackdropConfiguration>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
        P1: windows_core::Param<super::XamlRoot>,
    {
        let this = &windows_core::Interface::cast::<ISystemBackdrop>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetDefaultSystemBackdropConfiguration)(
                windows_core::Interface::as_raw(this),
                target.param().abi(),
                xamlroot.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn OnTargetConnected<P0, P1>(
        &self,
        connectedtarget: P0,
        xamlroot: P1,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
        P1: windows_core::Param<super::XamlRoot>,
    {
        let this = &windows_core::Interface::cast::<ISystemBackdropOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnTargetConnected)(
                windows_core::Interface::as_raw(this),
                connectedtarget.param().abi(),
                xamlroot.param().abi(),
            )
            .ok()
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn OnTargetDisconnected<P0>(&self, disconnectedtarget: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
    {
        let this = &windows_core::Interface::cast::<ISystemBackdropOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnTargetDisconnected)(
                windows_core::Interface::as_raw(this),
                disconnectedtarget.param().abi(),
            )
            .ok()
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn OnDefaultSystemBackdropConfigurationChanged<P0, P1>(
        &self,
        target: P0,
        xamlroot: P1,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
        P1: windows_core::Param<super::XamlRoot>,
    {
        let this = &windows_core::Interface::cast::<ISystemBackdropOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnDefaultSystemBackdropConfigurationChanged)(
                windows_core::Interface::as_raw(this),
                target.param().abi(),
                xamlroot.param().abi(),
            )
            .ok()
        }
    }
    fn IDesktopAcrylicBackdropFactory<
        R,
        F: FnOnce(&IDesktopAcrylicBackdropFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            DesktopAcrylicBackdrop,
            IDesktopAcrylicBackdropFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for DesktopAcrylicBackdrop {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IDesktopAcrylicBackdrop>();
}
unsafe impl windows_core::Interface for DesktopAcrylicBackdrop {
    type Vtable = <IDesktopAcrylicBackdrop as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IDesktopAcrylicBackdrop as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for DesktopAcrylicBackdrop {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.DesktopAcrylicBackdrop";
}
unsafe impl Send for DesktopAcrylicBackdrop {}
unsafe impl Sync for DesktopAcrylicBackdrop {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DoubleCollection(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    DoubleCollection,
    windows_core::IUnknown,
    windows_core::IInspectable,
    windows_collections::IVector<f64>
);
windows_core::imp::required_hierarchy!(DoubleCollection, windows_collections::IIterable<f64>);
impl DoubleCollection {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            DoubleCollection,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn First(&self) -> windows_core::Result<windows_collections::IIterator<f64>> {
        let this = &windows_core::Interface::cast::<windows_collections::IIterable<f64>>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).First)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAt(&self, index: u32) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAt)(
                windows_core::Interface::as_raw(this),
                index,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn Size(&self) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Size)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn GetView(&self) -> windows_core::Result<windows_collections::IVectorView<f64>> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetView)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn IndexOf(&self, value: f64, index: &mut u32) -> windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IndexOf)(
                windows_core::Interface::as_raw(this),
                value,
                index,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAt(&self, index: u32, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAt)(
                windows_core::Interface::as_raw(this),
                index,
                value,
            )
            .ok()
        }
    }
    pub fn InsertAt(&self, index: u32, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).InsertAt)(
                windows_core::Interface::as_raw(this),
                index,
                value,
            )
            .ok()
        }
    }
    pub fn RemoveAt(&self, index: u32) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAt)(
                windows_core::Interface::as_raw(this),
                index,
            )
            .ok()
        }
    }
    pub fn Append(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Append)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn RemoveAtEnd(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAtEnd)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn Clear(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Clear)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
    pub fn GetMany(&self, startindex: u32, items: &mut [f64]) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetMany)(
                windows_core::Interface::as_raw(this),
                startindex,
                items.len().try_into().unwrap(),
                items.as_mut_ptr(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn ReplaceAll(&self, items: &[f64]) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).ReplaceAll)(
                windows_core::Interface::as_raw(this),
                items.len().try_into().unwrap(),
                items.as_ptr(),
            )
            .ok()
        }
    }
}
impl windows_core::RuntimeType for DoubleCollection {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, windows_collections::IVector<f64>>();
}
unsafe impl windows_core::Interface for DoubleCollection {
    type Vtable = <windows_collections::IVector<f64> as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID =
        <windows_collections::IVector<f64> as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for DoubleCollection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.DoubleCollection";
}
unsafe impl Send for DoubleCollection {}
unsafe impl Sync for DoubleCollection {}
impl IntoIterator for DoubleCollection {
    type Item = f64;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        IntoIterator::into_iter(&self)
    }
}
impl IntoIterator for &DoubleCollection {
    type Item = f64;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        self.First().unwrap()
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct ElementCompositeMode(pub i32);
impl ElementCompositeMode {
    pub const Inherit: Self = Self(0i32);
    pub const SourceOver: Self = Self(1i32);
    pub const MinBlend: Self = Self(2i32);
}
impl windows_core::TypeKind for ElementCompositeMode {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for ElementCompositeMode {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::from_slice(
        b"enum(Microsoft.UI.Xaml.Media.ElementCompositeMode;i4)",
    );
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct EllipseGeometry(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    EllipseGeometry,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(EllipseGeometry, Geometry, super::DependencyObject);
impl EllipseGeometry {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            EllipseGeometry,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Center(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Center)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenter(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenter)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn RadiusX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RadiusX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetRadiusX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetRadiusX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn RadiusY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RadiusY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetRadiusY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetRadiusY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IEllipseGeometryStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn RadiusXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IEllipseGeometryStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RadiusXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn RadiusYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IEllipseGeometryStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RadiusYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn Bounds(&self) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Bounds)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    fn IEllipseGeometryStatics<
        R,
        F: FnOnce(&IEllipseGeometryStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<EllipseGeometry, IEllipseGeometryStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for EllipseGeometry {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IEllipseGeometry>();
}
unsafe impl windows_core::Interface for EllipseGeometry {
    type Vtable = <IEllipseGeometry as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IEllipseGeometry as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for EllipseGeometry {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.EllipseGeometry";
}
unsafe impl Send for EllipseGeometry {}
unsafe impl Sync for EllipseGeometry {}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct FastPlayFallbackBehaviour(pub i32);
impl FastPlayFallbackBehaviour {
    pub const Skip: Self = Self(0i32);
    pub const Hide: Self = Self(1i32);
    pub const Disable: Self = Self(2i32);
}
impl windows_core::TypeKind for FastPlayFallbackBehaviour {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for FastPlayFallbackBehaviour {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::from_slice(
        b"enum(Microsoft.UI.Xaml.Media.FastPlayFallbackBehaviour;i4)",
    );
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct FillRule(pub i32);
impl FillRule {
    pub const EvenOdd: Self = Self(0i32);
    pub const Nonzero: Self = Self(1i32);
}
impl windows_core::TypeKind for FillRule {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for FillRule {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::from_slice(b"enum(Microsoft.UI.Xaml.Media.FillRule;i4)");
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct FontFamily(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    FontFamily,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl FontFamily {
    pub fn Source(&self) -> windows_core::Result<windows_core::HSTRING> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Source)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| core::mem::transmute(result__))
        }
    }
    pub fn CreateInstanceWithName(
        familyname: &windows_core::HSTRING,
    ) -> windows_core::Result<FontFamily> {
        Self::IFontFamilyFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstanceWithName)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(familyname),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn XamlAutoFontFamily() -> windows_core::Result<FontFamily> {
        Self::IFontFamilyStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).XamlAutoFontFamily)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IFontFamilyFactory<R, F: FnOnce(&IFontFamilyFactory) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<FontFamily, IFontFamilyFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn IFontFamilyStatics<R, F: FnOnce(&IFontFamilyStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<FontFamily, IFontFamilyStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for FontFamily {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IFontFamily>();
}
unsafe impl windows_core::Interface for FontFamily {
    type Vtable = <IFontFamily as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IFontFamily as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for FontFamily {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.FontFamily";
}
unsafe impl Send for FontFamily {}
unsafe impl Sync for FontFamily {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct GeneralTransform(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    GeneralTransform,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(GeneralTransform, super::DependencyObject);
impl GeneralTransform {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Inverse(&self) -> windows_core::Result<GeneralTransform> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Inverse)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TransformPoint(
        &self,
        point: windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformPoint)(
                windows_core::Interface::as_raw(this),
                point,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TryTransform(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransform)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBounds(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBounds)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn new() -> windows_core::Result<GeneralTransform> {
        Self::IGeneralTransformFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn InverseCore(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).InverseCore)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TryTransformCore(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransformCore)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBoundsCore(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBoundsCore)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    fn IGeneralTransformFactory<
        R,
        F: FnOnce(&IGeneralTransformFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<GeneralTransform, IGeneralTransformFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for GeneralTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IGeneralTransform>();
}
unsafe impl windows_core::Interface for GeneralTransform {
    type Vtable = <IGeneralTransform as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IGeneralTransform as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for GeneralTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.GeneralTransform";
}
unsafe impl Send for GeneralTransform {}
unsafe impl Sync for GeneralTransform {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Geometry(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    Geometry,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(Geometry, super::DependencyObject);
impl Geometry {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn Bounds(&self) -> windows_core::Result<windows::Foundation::Rect> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Bounds)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn Empty() -> windows_core::Result<Geometry> {
        Self::IGeometryStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Empty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn StandardFlatteningTolerance() -> windows_core::Result<f64> {
        Self::IGeometryStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StandardFlatteningTolerance)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        })
    }
    pub fn TransformProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IGeometryStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IGeometryStatics<R, F: FnOnce(&IGeometryStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<Geometry, IGeometryStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for Geometry {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IGeometry>();
}
unsafe impl windows_core::Interface for Geometry {
    type Vtable = <IGeometry as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IGeometry as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for Geometry {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.Geometry";
}
unsafe impl Send for Geometry {}
unsafe impl Sync for Geometry {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct GeometryCollection(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    GeometryCollection,
    windows_core::IUnknown,
    windows_core::IInspectable,
    windows_collections::IVector<Geometry>
);
windows_core::imp::required_hierarchy!(
    GeometryCollection,
    windows_collections::IIterable<Geometry>
);
impl GeometryCollection {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            GeometryCollection,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn First(&self) -> windows_core::Result<windows_collections::IIterator<Geometry>> {
        let this =
            &windows_core::Interface::cast::<windows_collections::IIterable<Geometry>>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).First)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAt(&self, index: u32) -> windows_core::Result<Geometry> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAt)(
                windows_core::Interface::as_raw(this),
                index,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Size(&self) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Size)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn GetView(&self) -> windows_core::Result<windows_collections::IVectorView<Geometry>> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetView)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn IndexOf<P0>(&self, value: P0, index: &mut u32) -> windows_core::Result<bool>
    where
        P0: windows_core::Param<Geometry>,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IndexOf)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
                index,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<Geometry>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn InsertAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<Geometry>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).InsertAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAt(&self, index: u32) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAt)(
                windows_core::Interface::as_raw(this),
                index,
            )
            .ok()
        }
    }
    pub fn Append<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Geometry>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Append)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAtEnd(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAtEnd)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn Clear(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Clear)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
    pub fn GetMany(
        &self,
        startindex: u32,
        items: &mut [Option<Geometry>],
    ) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetMany)(
                windows_core::Interface::as_raw(this),
                startindex,
                items.len().try_into().unwrap(),
                core::mem::transmute_copy(&items),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn ReplaceAll(&self, items: &[Option<Geometry>]) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).ReplaceAll)(
                windows_core::Interface::as_raw(this),
                items.len().try_into().unwrap(),
                core::mem::transmute(items.as_ptr()),
            )
            .ok()
        }
    }
}
impl windows_core::RuntimeType for GeometryCollection {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, windows_collections::IVector<Geometry>>();
}
unsafe impl windows_core::Interface for GeometryCollection {
    type Vtable = <windows_collections::IVector<Geometry> as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID =
        <windows_collections::IVector<Geometry> as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for GeometryCollection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.GeometryCollection";
}
unsafe impl Send for GeometryCollection {}
unsafe impl Sync for GeometryCollection {}
impl IntoIterator for GeometryCollection {
    type Item = Geometry;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        IntoIterator::into_iter(&self)
    }
}
impl IntoIterator for &GeometryCollection {
    type Item = Geometry;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        self.First().unwrap()
    }
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct GeometryGroup(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    GeometryGroup,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(GeometryGroup, Geometry, super::DependencyObject);
impl GeometryGroup {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            GeometryGroup,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn Bounds(&self) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Bounds)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn FillRule(&self) -> windows_core::Result<FillRule> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FillRule)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetFillRule(&self, value: FillRule) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetFillRule)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Children(&self) -> windows_core::Result<GeometryCollection> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Children)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetChildren<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<GeometryCollection>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetChildren)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn FillRuleProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IGeometryGroupStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FillRuleProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn ChildrenProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IGeometryGroupStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ChildrenProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IGeometryGroupStatics<R, F: FnOnce(&IGeometryGroupStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<GeometryGroup, IGeometryGroupStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for GeometryGroup {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IGeometryGroup>();
}
unsafe impl windows_core::Interface for GeometryGroup {
    type Vtable = <IGeometryGroup as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IGeometryGroup as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for GeometryGroup {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.GeometryGroup";
}
unsafe impl Send for GeometryGroup {}
unsafe impl Sync for GeometryGroup {}
#[cfg(feature = "UI_Composition")]
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct GradientBrush(windows_core::IUnknown);
#[cfg(feature = "UI_Composition")]
windows_core::imp::interface_hierarchy!(
    GradientBrush,
    windows_core::IUnknown,
    windows_core::IInspectable
);
#[cfg(feature = "UI_Composition")]
windows_core::imp::required_hierarchy!(
    GradientBrush,
    super::super::Composition::IAnimationObject,
    Brush,
    super::DependencyObject
);
#[cfg(feature = "UI_Composition")]
impl GradientBrush {
    pub fn PopulatePropertyInfo<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        propertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this =
            &windows_core::Interface::cast::<super::super::Composition::IAnimationObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfo)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                propertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn Opacity(&self) -> windows_core::Result<f64> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Opacity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetOpacity(&self, value: f64) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetOpacity)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RelativeTransform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RelativeTransform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetRelativeTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetRelativeTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn PopulatePropertyInfoOverride<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        animationpropertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this = &windows_core::Interface::cast::<IBrushOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfoOverride)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                animationpropertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SpreadMethod(&self) -> windows_core::Result<GradientSpreadMethod> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SpreadMethod)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetSpreadMethod(&self, value: GradientSpreadMethod) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetSpreadMethod)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn MappingMode(&self) -> windows_core::Result<BrushMappingMode> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).MappingMode)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetMappingMode(&self, value: BrushMappingMode) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetMappingMode)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn ColorInterpolationMode(&self) -> windows_core::Result<ColorInterpolationMode> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ColorInterpolationMode)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetColorInterpolationMode(
        &self,
        value: ColorInterpolationMode,
    ) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetColorInterpolationMode)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn GradientStops(&self) -> windows_core::Result<GradientStopCollection> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GradientStops)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetGradientStops<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<GradientStopCollection>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetGradientStops)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn new() -> windows_core::Result<GradientBrush> {
        Self::IGradientBrushFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn SpreadMethodProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SpreadMethodProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn MappingModeProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).MappingModeProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn ColorInterpolationModeProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ColorInterpolationModeProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GradientStopsProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GradientStopsProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IGradientBrushFactory<R, F: FnOnce(&IGradientBrushFactory) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<GradientBrush, IGradientBrushFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn IGradientBrushStatics<R, F: FnOnce(&IGradientBrushStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<GradientBrush, IGradientBrushStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeType for GradientBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IGradientBrush>();
}
#[cfg(feature = "UI_Composition")]
unsafe impl windows_core::Interface for GradientBrush {
    type Vtable = <IGradientBrush as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IGradientBrush as windows_core::Interface>::IID;
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for GradientBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.GradientBrush";
}
#[cfg(feature = "UI_Composition")]
unsafe impl Send for GradientBrush {}
#[cfg(feature = "UI_Composition")]
unsafe impl Sync for GradientBrush {}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct GradientSpreadMethod(pub i32);
impl GradientSpreadMethod {
    pub const Pad: Self = Self(0i32);
    pub const Reflect: Self = Self(1i32);
    pub const Repeat: Self = Self(2i32);
}
impl windows_core::TypeKind for GradientSpreadMethod {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for GradientSpreadMethod {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::from_slice(
        b"enum(Microsoft.UI.Xaml.Media.GradientSpreadMethod;i4)",
    );
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct GradientStop(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    GradientStop,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(GradientStop, super::DependencyObject);
impl GradientStop {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            GradientStop,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Color(&self) -> windows_core::Result<windows::UI::Color> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Color)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetColor(&self, value: windows::UI::Color) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetColor)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Offset(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Offset)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetOffset(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetOffset)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn ColorProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IGradientStopStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ColorProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn OffsetProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IGradientStopStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).OffsetProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IGradientStopStatics<R, F: FnOnce(&IGradientStopStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<GradientStop, IGradientStopStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for GradientStop {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IGradientStop>();
}
unsafe impl windows_core::Interface for GradientStop {
    type Vtable = <IGradientStop as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IGradientStop as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for GradientStop {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.GradientStop";
}
unsafe impl Send for GradientStop {}
unsafe impl Sync for GradientStop {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct GradientStopCollection(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    GradientStopCollection,
    windows_core::IUnknown,
    windows_core::IInspectable,
    windows_collections::IVector<GradientStop>
);
windows_core::imp::required_hierarchy!(
    GradientStopCollection,
    windows_collections::IIterable<GradientStop>
);
impl GradientStopCollection {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            GradientStopCollection,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn First(&self) -> windows_core::Result<windows_collections::IIterator<GradientStop>> {
        let this =
            &windows_core::Interface::cast::<windows_collections::IIterable<GradientStop>>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).First)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAt(&self, index: u32) -> windows_core::Result<GradientStop> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAt)(
                windows_core::Interface::as_raw(this),
                index,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Size(&self) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Size)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn GetView(&self) -> windows_core::Result<windows_collections::IVectorView<GradientStop>> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetView)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn IndexOf<P0>(&self, value: P0, index: &mut u32) -> windows_core::Result<bool>
    where
        P0: windows_core::Param<GradientStop>,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IndexOf)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
                index,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<GradientStop>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn InsertAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<GradientStop>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).InsertAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAt(&self, index: u32) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAt)(
                windows_core::Interface::as_raw(this),
                index,
            )
            .ok()
        }
    }
    pub fn Append<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<GradientStop>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Append)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAtEnd(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAtEnd)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn Clear(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Clear)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
    pub fn GetMany(
        &self,
        startindex: u32,
        items: &mut [Option<GradientStop>],
    ) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetMany)(
                windows_core::Interface::as_raw(this),
                startindex,
                items.len().try_into().unwrap(),
                core::mem::transmute_copy(&items),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn ReplaceAll(&self, items: &[Option<GradientStop>]) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).ReplaceAll)(
                windows_core::Interface::as_raw(this),
                items.len().try_into().unwrap(),
                core::mem::transmute(items.as_ptr()),
            )
            .ok()
        }
    }
}
impl windows_core::RuntimeType for GradientStopCollection {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::for_class::<
        Self,
        windows_collections::IVector<GradientStop>,
    >();
}
unsafe impl windows_core::Interface for GradientStopCollection {
    type Vtable = <windows_collections::IVector<GradientStop> as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID =
        <windows_collections::IVector<GradientStop> as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for GradientStopCollection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.GradientStopCollection";
}
unsafe impl Send for GradientStopCollection {}
unsafe impl Sync for GradientStopCollection {}
impl IntoIterator for GradientStopCollection {
    type Item = GradientStop;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        IntoIterator::into_iter(&self)
    }
}
impl IntoIterator for &GradientStopCollection {
    type Item = GradientStop;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        self.First().unwrap()
    }
}
windows_core::imp::define_interface!(
    IAcrylicBrush,
    IAcrylicBrush_Vtbl,
    0x3a8c760a_941f_58bc_a6d4_aa7a0dd1d036
);
impl windows_core::RuntimeType for IAcrylicBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IAcrylicBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IAcrylicBrush";
}
pub trait IAcrylicBrush_Impl: windows_core::IUnknownImpl {
    fn TintColor(&self) -> windows_core::Result<windows::UI::Color>;
    fn SetTintColor(&self, value: &windows::UI::Color) -> windows_core::Result<()>;
    fn TintOpacity(&self) -> windows_core::Result<f64>;
    fn SetTintOpacity(&self, value: f64) -> windows_core::Result<()>;
    fn TintTransitionDuration(&self) -> windows_core::Result<windows::Foundation::TimeSpan>;
    fn SetTintTransitionDuration(
        &self,
        value: &windows::Foundation::TimeSpan,
    ) -> windows_core::Result<()>;
    fn AlwaysUseFallback(&self) -> windows_core::Result<bool>;
    fn SetAlwaysUseFallback(&self, value: bool) -> windows_core::Result<()>;
}
impl IAcrylicBrush_Vtbl {
    pub const fn new<Identity: IAcrylicBrush_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn TintColor<Identity: IAcrylicBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::UI::Color,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAcrylicBrush_Impl::TintColor(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTintColor<
            Identity: IAcrylicBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::UI::Color,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAcrylicBrush_Impl::SetTintColor(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn TintOpacity<Identity: IAcrylicBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAcrylicBrush_Impl::TintOpacity(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTintOpacity<
            Identity: IAcrylicBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAcrylicBrush_Impl::SetTintOpacity(this, value).into()
            }
        }
        unsafe extern "system" fn TintTransitionDuration<
            Identity: IAcrylicBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::TimeSpan,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAcrylicBrush_Impl::TintTransitionDuration(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTintTransitionDuration<
            Identity: IAcrylicBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::TimeSpan,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAcrylicBrush_Impl::SetTintTransitionDuration(this, core::mem::transmute(&value))
                    .into()
            }
        }
        unsafe extern "system" fn AlwaysUseFallback<
            Identity: IAcrylicBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAcrylicBrush_Impl::AlwaysUseFallback(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAlwaysUseFallback<
            Identity: IAcrylicBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAcrylicBrush_Impl::SetAlwaysUseFallback(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IAcrylicBrush, OFFSET>(),
            TintColor: TintColor::<Identity, OFFSET>,
            SetTintColor: SetTintColor::<Identity, OFFSET>,
            TintOpacity: TintOpacity::<Identity, OFFSET>,
            SetTintOpacity: SetTintOpacity::<Identity, OFFSET>,
            TintTransitionDuration: TintTransitionDuration::<Identity, OFFSET>,
            SetTintTransitionDuration: SetTintTransitionDuration::<Identity, OFFSET>,
            AlwaysUseFallback: AlwaysUseFallback::<Identity, OFFSET>,
            SetAlwaysUseFallback: SetAlwaysUseFallback::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAcrylicBrush as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAcrylicBrush_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub TintColor: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::UI::Color,
    ) -> windows_core::HRESULT,
    pub SetTintColor: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::UI::Color,
    ) -> windows_core::HRESULT,
    pub TintOpacity:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetTintOpacity:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub TintTransitionDuration: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::TimeSpan,
    ) -> windows_core::HRESULT,
    pub SetTintTransitionDuration: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::TimeSpan,
    ) -> windows_core::HRESULT,
    pub AlwaysUseFallback:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut bool) -> windows_core::HRESULT,
    pub SetAlwaysUseFallback:
        unsafe extern "system" fn(*mut core::ffi::c_void, bool) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IAcrylicBrush2,
    IAcrylicBrush2_Vtbl,
    0x23fad570_43ed_5a73_9de7_a303553d5414
);
impl windows_core::RuntimeType for IAcrylicBrush2 {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IAcrylicBrush2 {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IAcrylicBrush2";
}
pub trait IAcrylicBrush2_Impl: windows_core::IUnknownImpl {
    fn TintLuminosityOpacity(&self) -> windows_core::Result<windows::Foundation::IReference<f64>>;
    fn SetTintLuminosityOpacity(
        &self,
        value: windows_core::Ref<'_, windows::Foundation::IReference<f64>>,
    ) -> windows_core::Result<()>;
}
impl IAcrylicBrush2_Vtbl {
    pub const fn new<Identity: IAcrylicBrush2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn TintLuminosityOpacity<
            Identity: IAcrylicBrush2_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAcrylicBrush2_Impl::TintLuminosityOpacity(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTintLuminosityOpacity<
            Identity: IAcrylicBrush2_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IAcrylicBrush2_Impl::SetTintLuminosityOpacity(
                    this,
                    core::mem::transmute_copy(&value),
                )
                .into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IAcrylicBrush2, OFFSET>(),
            TintLuminosityOpacity: TintLuminosityOpacity::<Identity, OFFSET>,
            SetTintLuminosityOpacity: SetTintLuminosityOpacity::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAcrylicBrush2 as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAcrylicBrush2_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub TintLuminosityOpacity: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetTintLuminosityOpacity: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IAcrylicBrushFactory,
    IAcrylicBrushFactory_Vtbl,
    0x80173353_611d_5a02_8864_1aaa279dff1c
);
impl windows_core::RuntimeType for IAcrylicBrushFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IAcrylicBrushFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IAcrylicBrushFactory";
}
#[cfg(feature = "UI_Composition")]
pub trait IAcrylicBrushFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<AcrylicBrush>;
}
#[cfg(feature = "UI_Composition")]
impl IAcrylicBrushFactory_Vtbl {
    pub const fn new<Identity: IAcrylicBrushFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: IAcrylicBrushFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAcrylicBrushFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IAcrylicBrushFactory, OFFSET>(
            ),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAcrylicBrushFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAcrylicBrushFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    CreateInstance: usize,
}
windows_core::imp::define_interface!(
    IAcrylicBrushStatics,
    IAcrylicBrushStatics_Vtbl,
    0x9d9d366b_00a3_5f3e_98b8_1df7fec1828c
);
impl windows_core::RuntimeType for IAcrylicBrushStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IAcrylicBrushStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IAcrylicBrushStatics";
}
pub trait IAcrylicBrushStatics_Impl: windows_core::IUnknownImpl {
    fn TintColorProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn TintOpacityProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn TintTransitionDurationProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn AlwaysUseFallbackProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IAcrylicBrushStatics_Vtbl {
    pub const fn new<Identity: IAcrylicBrushStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn TintColorProperty<
            Identity: IAcrylicBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAcrylicBrushStatics_Impl::TintColorProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TintOpacityProperty<
            Identity: IAcrylicBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAcrylicBrushStatics_Impl::TintOpacityProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TintTransitionDurationProperty<
            Identity: IAcrylicBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAcrylicBrushStatics_Impl::TintTransitionDurationProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AlwaysUseFallbackProperty<
            Identity: IAcrylicBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAcrylicBrushStatics_Impl::AlwaysUseFallbackProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IAcrylicBrushStatics, OFFSET>(
            ),
            TintColorProperty: TintColorProperty::<Identity, OFFSET>,
            TintOpacityProperty: TintOpacityProperty::<Identity, OFFSET>,
            TintTransitionDurationProperty: TintTransitionDurationProperty::<Identity, OFFSET>,
            AlwaysUseFallbackProperty: AlwaysUseFallbackProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAcrylicBrushStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAcrylicBrushStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub TintColorProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub TintOpacityProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub TintTransitionDurationProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub AlwaysUseFallbackProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IAcrylicBrushStatics2,
    IAcrylicBrushStatics2_Vtbl,
    0x6e3eb0bd_20a1_52ea_aede_478061012279
);
impl windows_core::RuntimeType for IAcrylicBrushStatics2 {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IAcrylicBrushStatics2 {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IAcrylicBrushStatics2";
}
pub trait IAcrylicBrushStatics2_Impl: windows_core::IUnknownImpl {
    fn TintLuminosityOpacityProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IAcrylicBrushStatics2_Vtbl {
    pub const fn new<Identity: IAcrylicBrushStatics2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn TintLuminosityOpacityProperty<
            Identity: IAcrylicBrushStatics2_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IAcrylicBrushStatics2_Impl::TintLuminosityOpacityProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IAcrylicBrushStatics2, OFFSET>(
            ),
            TintLuminosityOpacityProperty: TintLuminosityOpacityProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAcrylicBrushStatics2 as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IAcrylicBrushStatics2_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub TintLuminosityOpacityProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IArcSegment,
    IArcSegment_Vtbl,
    0x6b7ce02b_87be_5acb_9d3b_c9964c6962d0
);
impl windows_core::RuntimeType for IArcSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IArcSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IArcSegment";
}
pub trait IArcSegment_Impl: windows_core::IUnknownImpl {
    fn Point(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetPoint(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
    fn Size(&self) -> windows_core::Result<windows::Foundation::Size>;
    fn SetSize(&self, value: &windows::Foundation::Size) -> windows_core::Result<()>;
    fn RotationAngle(&self) -> windows_core::Result<f64>;
    fn SetRotationAngle(&self, value: f64) -> windows_core::Result<()>;
    fn IsLargeArc(&self) -> windows_core::Result<bool>;
    fn SetIsLargeArc(&self, value: bool) -> windows_core::Result<()>;
    fn SweepDirection(&self) -> windows_core::Result<SweepDirection>;
    fn SetSweepDirection(&self, value: SweepDirection) -> windows_core::Result<()>;
}
impl IArcSegment_Vtbl {
    pub const fn new<Identity: IArcSegment_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Point<Identity: IArcSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IArcSegment_Impl::Point(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPoint<Identity: IArcSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IArcSegment_Impl::SetPoint(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn Size<Identity: IArcSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Size,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IArcSegment_Impl::Size(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSize<Identity: IArcSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Size,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IArcSegment_Impl::SetSize(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn RotationAngle<Identity: IArcSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IArcSegment_Impl::RotationAngle(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRotationAngle<
            Identity: IArcSegment_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IArcSegment_Impl::SetRotationAngle(this, value).into()
            }
        }
        unsafe extern "system" fn IsLargeArc<Identity: IArcSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IArcSegment_Impl::IsLargeArc(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetIsLargeArc<Identity: IArcSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IArcSegment_Impl::SetIsLargeArc(this, value).into()
            }
        }
        unsafe extern "system" fn SweepDirection<
            Identity: IArcSegment_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut SweepDirection,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IArcSegment_Impl::SweepDirection(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSweepDirection<
            Identity: IArcSegment_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: SweepDirection,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IArcSegment_Impl::SetSweepDirection(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IArcSegment, OFFSET>(),
            Point: Point::<Identity, OFFSET>,
            SetPoint: SetPoint::<Identity, OFFSET>,
            Size: Size::<Identity, OFFSET>,
            SetSize: SetSize::<Identity, OFFSET>,
            RotationAngle: RotationAngle::<Identity, OFFSET>,
            SetRotationAngle: SetRotationAngle::<Identity, OFFSET>,
            IsLargeArc: IsLargeArc::<Identity, OFFSET>,
            SetIsLargeArc: SetIsLargeArc::<Identity, OFFSET>,
            SweepDirection: SweepDirection::<Identity, OFFSET>,
            SetSweepDirection: SetSweepDirection::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IArcSegment as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IArcSegment_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Point: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub Size: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Size,
    ) -> windows_core::HRESULT,
    pub SetSize: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Size,
    ) -> windows_core::HRESULT,
    pub RotationAngle:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetRotationAngle:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub IsLargeArc:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut bool) -> windows_core::HRESULT,
    pub SetIsLargeArc:
        unsafe extern "system" fn(*mut core::ffi::c_void, bool) -> windows_core::HRESULT,
    pub SweepDirection: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut SweepDirection,
    ) -> windows_core::HRESULT,
    pub SetSweepDirection:
        unsafe extern "system" fn(*mut core::ffi::c_void, SweepDirection) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IArcSegmentStatics,
    IArcSegmentStatics_Vtbl,
    0x5ba7ccb3_5bc7_5038_99c5_93dc730230cf
);
impl windows_core::RuntimeType for IArcSegmentStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IArcSegmentStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IArcSegmentStatics";
}
pub trait IArcSegmentStatics_Impl: windows_core::IUnknownImpl {
    fn PointProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn SizeProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn RotationAngleProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn IsLargeArcProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn SweepDirectionProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IArcSegmentStatics_Vtbl {
    pub const fn new<Identity: IArcSegmentStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn PointProperty<
            Identity: IArcSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IArcSegmentStatics_Impl::PointProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SizeProperty<
            Identity: IArcSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IArcSegmentStatics_Impl::SizeProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RotationAngleProperty<
            Identity: IArcSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IArcSegmentStatics_Impl::RotationAngleProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn IsLargeArcProperty<
            Identity: IArcSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IArcSegmentStatics_Impl::IsLargeArcProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SweepDirectionProperty<
            Identity: IArcSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IArcSegmentStatics_Impl::SweepDirectionProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IArcSegmentStatics, OFFSET>(),
            PointProperty: PointProperty::<Identity, OFFSET>,
            SizeProperty: SizeProperty::<Identity, OFFSET>,
            RotationAngleProperty: RotationAngleProperty::<Identity, OFFSET>,
            IsLargeArcProperty: IsLargeArcProperty::<Identity, OFFSET>,
            SweepDirectionProperty: SweepDirectionProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IArcSegmentStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IArcSegmentStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub PointProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SizeProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub RotationAngleProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub IsLargeArcProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SweepDirectionProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IBezierSegment,
    IBezierSegment_Vtbl,
    0x0f36bade_892e_51fe_b94a_3875e86feaae
);
impl windows_core::RuntimeType for IBezierSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IBezierSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IBezierSegment";
}
pub trait IBezierSegment_Impl: windows_core::IUnknownImpl {
    fn Point1(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetPoint1(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
    fn Point2(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetPoint2(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
    fn Point3(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetPoint3(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
}
impl IBezierSegment_Vtbl {
    pub const fn new<Identity: IBezierSegment_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Point1<Identity: IBezierSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBezierSegment_Impl::Point1(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPoint1<Identity: IBezierSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBezierSegment_Impl::SetPoint1(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn Point2<Identity: IBezierSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBezierSegment_Impl::Point2(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPoint2<Identity: IBezierSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBezierSegment_Impl::SetPoint2(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn Point3<Identity: IBezierSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBezierSegment_Impl::Point3(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPoint3<Identity: IBezierSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBezierSegment_Impl::SetPoint3(this, core::mem::transmute(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IBezierSegment, OFFSET>(),
            Point1: Point1::<Identity, OFFSET>,
            SetPoint1: SetPoint1::<Identity, OFFSET>,
            Point2: Point2::<Identity, OFFSET>,
            SetPoint2: SetPoint2::<Identity, OFFSET>,
            Point3: Point3::<Identity, OFFSET>,
            SetPoint3: SetPoint3::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBezierSegment as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBezierSegment_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Point1: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetPoint1: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub Point2: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetPoint2: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub Point3: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetPoint3: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IBezierSegmentStatics,
    IBezierSegmentStatics_Vtbl,
    0x98e74d5c_c97a_50b0_ae0e_d436dc9df16d
);
impl windows_core::RuntimeType for IBezierSegmentStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IBezierSegmentStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IBezierSegmentStatics";
}
pub trait IBezierSegmentStatics_Impl: windows_core::IUnknownImpl {
    fn Point1Property(&self) -> windows_core::Result<super::DependencyProperty>;
    fn Point2Property(&self) -> windows_core::Result<super::DependencyProperty>;
    fn Point3Property(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IBezierSegmentStatics_Vtbl {
    pub const fn new<Identity: IBezierSegmentStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Point1Property<
            Identity: IBezierSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBezierSegmentStatics_Impl::Point1Property(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Point2Property<
            Identity: IBezierSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBezierSegmentStatics_Impl::Point2Property(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Point3Property<
            Identity: IBezierSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBezierSegmentStatics_Impl::Point3Property(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IBezierSegmentStatics, OFFSET>(
            ),
            Point1Property: Point1Property::<Identity, OFFSET>,
            Point2Property: Point2Property::<Identity, OFFSET>,
            Point3Property: Point3Property::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBezierSegmentStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBezierSegmentStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Point1Property: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub Point2Property: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub Point3Property: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IBitmapCache,
    IBitmapCache_Vtbl,
    0x4b3a8983_27a2_592a_bda4_270431eae038
);
impl windows_core::RuntimeType for IBitmapCache {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IBitmapCache {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IBitmapCache";
}
pub trait IBitmapCache_Impl: windows_core::IUnknownImpl {}
impl IBitmapCache_Vtbl {
    pub const fn new<Identity: IBitmapCache_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IBitmapCache, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBitmapCache as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBitmapCache_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(IBrush, IBrush_Vtbl, 0x2de3cb83_1329_5679_88f8_c822bc5442cb);
impl windows_core::RuntimeType for IBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IBrush";
}
pub trait IBrush_Impl: windows_core::IUnknownImpl {
    fn Opacity(&self) -> windows_core::Result<f64>;
    fn SetOpacity(&self, value: f64) -> windows_core::Result<()>;
    fn Transform(&self) -> windows_core::Result<Transform>;
    fn SetTransform(&self, value: windows_core::Ref<'_, Transform>) -> windows_core::Result<()>;
    fn RelativeTransform(&self) -> windows_core::Result<Transform>;
    fn SetRelativeTransform(
        &self,
        value: windows_core::Ref<'_, Transform>,
    ) -> windows_core::Result<()>;
}
impl IBrush_Vtbl {
    pub const fn new<Identity: IBrush_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Opacity<Identity: IBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBrush_Impl::Opacity(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetOpacity<Identity: IBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBrush_Impl::SetOpacity(this, value).into()
            }
        }
        unsafe extern "system" fn Transform<Identity: IBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBrush_Impl::Transform(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTransform<Identity: IBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBrush_Impl::SetTransform(this, core::mem::transmute_copy(&value)).into()
            }
        }
        unsafe extern "system" fn RelativeTransform<Identity: IBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBrush_Impl::RelativeTransform(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRelativeTransform<
            Identity: IBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBrush_Impl::SetRelativeTransform(this, core::mem::transmute_copy(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IBrush, OFFSET>(),
            Opacity: Opacity::<Identity, OFFSET>,
            SetOpacity: SetOpacity::<Identity, OFFSET>,
            Transform: Transform::<Identity, OFFSET>,
            SetTransform: SetTransform::<Identity, OFFSET>,
            RelativeTransform: RelativeTransform::<Identity, OFFSET>,
            SetRelativeTransform: SetRelativeTransform::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBrush as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBrush_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Opacity:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetOpacity: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub Transform: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetTransform: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub RelativeTransform: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetRelativeTransform: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IBrushFactory,
    IBrushFactory_Vtbl,
    0xb5258717_6c49_5ba5_87fd_35df382647a5
);
impl windows_core::RuntimeType for IBrushFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IBrushFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IBrushFactory";
}
#[cfg(feature = "UI_Composition")]
pub trait IBrushFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<Brush>;
}
#[cfg(feature = "UI_Composition")]
impl IBrushFactory_Vtbl {
    pub const fn new<Identity: IBrushFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: IBrushFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBrushFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IBrushFactory, OFFSET>(),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBrushFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBrushFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    CreateInstance: usize,
}
windows_core::imp::define_interface!(
    IBrushOverrides,
    IBrushOverrides_Vtbl,
    0xb6b08394_bacf_53db_9ac7_be1c693e3513
);
impl windows_core::RuntimeType for IBrushOverrides {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IBrushOverrides {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IBrushOverrides";
}
#[cfg(feature = "UI_Composition")]
pub trait IBrushOverrides_Impl: windows_core::IUnknownImpl {
    fn PopulatePropertyInfoOverride(
        &self,
        propertyName: &windows_core::HSTRING,
        animationPropertyInfo: windows_core::Ref<
            '_,
            super::super::Composition::AnimationPropertyInfo,
        >,
    ) -> windows_core::Result<()>;
}
#[cfg(feature = "UI_Composition")]
impl IBrushOverrides_Vtbl {
    pub const fn new<Identity: IBrushOverrides_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn PopulatePropertyInfoOverride<
            Identity: IBrushOverrides_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            propertyname: *mut core::ffi::c_void,
            animationpropertyinfo: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IBrushOverrides_Impl::PopulatePropertyInfoOverride(
                    this,
                    core::mem::transmute(&propertyname),
                    core::mem::transmute_copy(&animationpropertyinfo),
                )
                .into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IBrushOverrides, OFFSET>(),
            PopulatePropertyInfoOverride: PopulatePropertyInfoOverride::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBrushOverrides as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBrushOverrides_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub PopulatePropertyInfoOverride: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    PopulatePropertyInfoOverride: usize,
}
windows_core::imp::define_interface!(
    IBrushStatics,
    IBrushStatics_Vtbl,
    0x5b854f50_f818_5f01_91b0_28132d3f5957
);
impl windows_core::RuntimeType for IBrushStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IBrushStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IBrushStatics";
}
pub trait IBrushStatics_Impl: windows_core::IUnknownImpl {
    fn OpacityProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn TransformProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn RelativeTransformProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IBrushStatics_Vtbl {
    pub const fn new<Identity: IBrushStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn OpacityProperty<
            Identity: IBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBrushStatics_Impl::OpacityProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TransformProperty<
            Identity: IBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBrushStatics_Impl::TransformProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RelativeTransformProperty<
            Identity: IBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IBrushStatics_Impl::RelativeTransformProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IBrushStatics, OFFSET>(),
            OpacityProperty: OpacityProperty::<Identity, OFFSET>,
            TransformProperty: TransformProperty::<Identity, OFFSET>,
            RelativeTransformProperty: RelativeTransformProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IBrushStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IBrushStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub OpacityProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub TransformProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub RelativeTransformProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ICacheMode,
    ICacheMode_Vtbl,
    0x2ff1a1cb_0f48_53fd_b1de_e2223dfb2ff6
);
impl windows_core::RuntimeType for ICacheMode {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ICacheMode {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ICacheMode";
}
pub trait ICacheMode_Impl: windows_core::IUnknownImpl {}
impl ICacheMode_Vtbl {
    pub const fn new<Identity: ICacheMode_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ICacheMode, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICacheMode as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ICacheMode_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    ICacheModeFactory,
    ICacheModeFactory_Vtbl,
    0xe257811e_dcc5_51d8_829a_3e9400198a41
);
impl windows_core::RuntimeType for ICacheModeFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ICacheModeFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ICacheModeFactory";
}
pub trait ICacheModeFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<CacheMode>;
}
impl ICacheModeFactory_Vtbl {
    pub const fn new<Identity: ICacheModeFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: ICacheModeFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICacheModeFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ICacheModeFactory, OFFSET>(),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICacheModeFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ICacheModeFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ICompositeTransform,
    ICompositeTransform_Vtbl,
    0x55c5f8f3_20e4_5b80_a046_ce4d0f62f2fe
);
impl windows_core::RuntimeType for ICompositeTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ICompositeTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ICompositeTransform";
}
pub trait ICompositeTransform_Impl: windows_core::IUnknownImpl {
    fn CenterX(&self) -> windows_core::Result<f64>;
    fn SetCenterX(&self, value: f64) -> windows_core::Result<()>;
    fn CenterY(&self) -> windows_core::Result<f64>;
    fn SetCenterY(&self, value: f64) -> windows_core::Result<()>;
    fn ScaleX(&self) -> windows_core::Result<f64>;
    fn SetScaleX(&self, value: f64) -> windows_core::Result<()>;
    fn ScaleY(&self) -> windows_core::Result<f64>;
    fn SetScaleY(&self, value: f64) -> windows_core::Result<()>;
    fn SkewX(&self) -> windows_core::Result<f64>;
    fn SetSkewX(&self, value: f64) -> windows_core::Result<()>;
    fn SkewY(&self) -> windows_core::Result<f64>;
    fn SetSkewY(&self, value: f64) -> windows_core::Result<()>;
    fn Rotation(&self) -> windows_core::Result<f64>;
    fn SetRotation(&self, value: f64) -> windows_core::Result<()>;
    fn TranslateX(&self) -> windows_core::Result<f64>;
    fn SetTranslateX(&self, value: f64) -> windows_core::Result<()>;
    fn TranslateY(&self) -> windows_core::Result<f64>;
    fn SetTranslateY(&self, value: f64) -> windows_core::Result<()>;
}
impl ICompositeTransform_Vtbl {
    pub const fn new<Identity: ICompositeTransform_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CenterX<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransform_Impl::CenterX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenterX<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositeTransform_Impl::SetCenterX(this, value).into()
            }
        }
        unsafe extern "system" fn CenterY<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransform_Impl::CenterY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenterY<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositeTransform_Impl::SetCenterY(this, value).into()
            }
        }
        unsafe extern "system" fn ScaleX<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransform_Impl::ScaleX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetScaleX<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositeTransform_Impl::SetScaleX(this, value).into()
            }
        }
        unsafe extern "system" fn ScaleY<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransform_Impl::ScaleY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetScaleY<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositeTransform_Impl::SetScaleY(this, value).into()
            }
        }
        unsafe extern "system" fn SkewX<Identity: ICompositeTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransform_Impl::SkewX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSkewX<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositeTransform_Impl::SetSkewX(this, value).into()
            }
        }
        unsafe extern "system" fn SkewY<Identity: ICompositeTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransform_Impl::SkewY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSkewY<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositeTransform_Impl::SetSkewY(this, value).into()
            }
        }
        unsafe extern "system" fn Rotation<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransform_Impl::Rotation(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRotation<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositeTransform_Impl::SetRotation(this, value).into()
            }
        }
        unsafe extern "system" fn TranslateX<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransform_Impl::TranslateX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTranslateX<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositeTransform_Impl::SetTranslateX(this, value).into()
            }
        }
        unsafe extern "system" fn TranslateY<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransform_Impl::TranslateY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTranslateY<
            Identity: ICompositeTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositeTransform_Impl::SetTranslateY(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ICompositeTransform, OFFSET>(),
            CenterX: CenterX::<Identity, OFFSET>,
            SetCenterX: SetCenterX::<Identity, OFFSET>,
            CenterY: CenterY::<Identity, OFFSET>,
            SetCenterY: SetCenterY::<Identity, OFFSET>,
            ScaleX: ScaleX::<Identity, OFFSET>,
            SetScaleX: SetScaleX::<Identity, OFFSET>,
            ScaleY: ScaleY::<Identity, OFFSET>,
            SetScaleY: SetScaleY::<Identity, OFFSET>,
            SkewX: SkewX::<Identity, OFFSET>,
            SetSkewX: SetSkewX::<Identity, OFFSET>,
            SkewY: SkewY::<Identity, OFFSET>,
            SetSkewY: SetSkewY::<Identity, OFFSET>,
            Rotation: Rotation::<Identity, OFFSET>,
            SetRotation: SetRotation::<Identity, OFFSET>,
            TranslateX: TranslateX::<Identity, OFFSET>,
            SetTranslateX: SetTranslateX::<Identity, OFFSET>,
            TranslateY: TranslateY::<Identity, OFFSET>,
            SetTranslateY: SetTranslateY::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICompositeTransform as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ICompositeTransform_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CenterX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCenterX: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub CenterY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCenterY: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub ScaleX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetScaleX: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub ScaleY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetScaleY: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub SkewX: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetSkewX: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub SkewY: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetSkewY: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub Rotation:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetRotation:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub TranslateX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetTranslateX:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub TranslateY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetTranslateY:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ICompositeTransformStatics,
    ICompositeTransformStatics_Vtbl,
    0x7701385b_8eab_5071_bfa5_b453e1e52b43
);
impl windows_core::RuntimeType for ICompositeTransformStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ICompositeTransformStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ICompositeTransformStatics";
}
pub trait ICompositeTransformStatics_Impl: windows_core::IUnknownImpl {
    fn CenterXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn CenterYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn ScaleXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn ScaleYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn SkewXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn SkewYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn RotationProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn TranslateXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn TranslateYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl ICompositeTransformStatics_Vtbl {
    pub const fn new<Identity: ICompositeTransformStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CenterXProperty<
            Identity: ICompositeTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransformStatics_Impl::CenterXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CenterYProperty<
            Identity: ICompositeTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransformStatics_Impl::CenterYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ScaleXProperty<
            Identity: ICompositeTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransformStatics_Impl::ScaleXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ScaleYProperty<
            Identity: ICompositeTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransformStatics_Impl::ScaleYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SkewXProperty<
            Identity: ICompositeTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransformStatics_Impl::SkewXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SkewYProperty<
            Identity: ICompositeTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransformStatics_Impl::SkewYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RotationProperty<
            Identity: ICompositeTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransformStatics_Impl::RotationProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TranslateXProperty<
            Identity: ICompositeTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransformStatics_Impl::TranslateXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TranslateYProperty<
            Identity: ICompositeTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositeTransformStatics_Impl::TranslateYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                ICompositeTransformStatics,
                OFFSET,
            >(),
            CenterXProperty: CenterXProperty::<Identity, OFFSET>,
            CenterYProperty: CenterYProperty::<Identity, OFFSET>,
            ScaleXProperty: ScaleXProperty::<Identity, OFFSET>,
            ScaleYProperty: ScaleYProperty::<Identity, OFFSET>,
            SkewXProperty: SkewXProperty::<Identity, OFFSET>,
            SkewYProperty: SkewYProperty::<Identity, OFFSET>,
            RotationProperty: RotationProperty::<Identity, OFFSET>,
            TranslateXProperty: TranslateXProperty::<Identity, OFFSET>,
            TranslateYProperty: TranslateYProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICompositeTransformStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ICompositeTransformStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CenterXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub CenterYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub ScaleXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub ScaleYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SkewXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SkewYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub RotationProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub TranslateXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub TranslateYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ICompositionTarget,
    ICompositionTarget_Vtbl,
    0x7d938324_e3ad_597c_93f6_520725410e68
);
impl windows_core::RuntimeType for ICompositionTarget {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ICompositionTarget {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ICompositionTarget";
}
pub trait ICompositionTarget_Impl: windows_core::IUnknownImpl {}
impl ICompositionTarget_Vtbl {
    pub const fn new<Identity: ICompositionTarget_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ICompositionTarget, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICompositionTarget as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ICompositionTarget_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    ICompositionTargetStatics,
    ICompositionTargetStatics_Vtbl,
    0x12a4be6f_6db1_5165_b622_d57ab782745b
);
impl windows_core::RuntimeType for ICompositionTargetStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for ICompositionTargetStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ICompositionTargetStatics";
}
#[cfg(feature = "UI_Composition")]
pub trait ICompositionTargetStatics_Impl: windows_core::IUnknownImpl {
    fn Rendering(
        &self,
        handler: windows_core::Ref<
            '_,
            windows::Foundation::EventHandler<windows_core::IInspectable>,
        >,
    ) -> windows_core::Result<i64>;
    fn RemoveRendering(&self, token: i64) -> windows_core::Result<()>;
    fn Rendered(
        &self,
        handler: windows_core::Ref<'_, windows::Foundation::EventHandler<RenderedEventArgs>>,
    ) -> windows_core::Result<i64>;
    fn RemoveRendered(&self, token: i64) -> windows_core::Result<()>;
    fn SurfaceContentsLost(
        &self,
        handler: windows_core::Ref<
            '_,
            windows::Foundation::EventHandler<windows_core::IInspectable>,
        >,
    ) -> windows_core::Result<i64>;
    fn RemoveSurfaceContentsLost(&self, token: i64) -> windows_core::Result<()>;
    fn GetCompositorForCurrentThread(
        &self,
    ) -> windows_core::Result<super::super::Composition::Compositor>;
}
#[cfg(feature = "UI_Composition")]
impl ICompositionTargetStatics_Vtbl {
    pub const fn new<Identity: ICompositionTargetStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Rendering<
            Identity: ICompositionTargetStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            handler: *mut core::ffi::c_void,
            result__: *mut i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositionTargetStatics_Impl::Rendering(
                    this,
                    core::mem::transmute_copy(&handler),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveRendering<
            Identity: ICompositionTargetStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            token: i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositionTargetStatics_Impl::RemoveRendering(this, token).into()
            }
        }
        unsafe extern "system" fn Rendered<
            Identity: ICompositionTargetStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            handler: *mut core::ffi::c_void,
            result__: *mut i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositionTargetStatics_Impl::Rendered(
                    this,
                    core::mem::transmute_copy(&handler),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveRendered<
            Identity: ICompositionTargetStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            token: i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositionTargetStatics_Impl::RemoveRendered(this, token).into()
            }
        }
        unsafe extern "system" fn SurfaceContentsLost<
            Identity: ICompositionTargetStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            handler: *mut core::ffi::c_void,
            result__: *mut i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositionTargetStatics_Impl::SurfaceContentsLost(
                    this,
                    core::mem::transmute_copy(&handler),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveSurfaceContentsLost<
            Identity: ICompositionTargetStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            token: i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ICompositionTargetStatics_Impl::RemoveSurfaceContentsLost(this, token).into()
            }
        }
        unsafe extern "system" fn GetCompositorForCurrentThread<
            Identity: ICompositionTargetStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ICompositionTargetStatics_Impl::GetCompositorForCurrentThread(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                ICompositionTargetStatics,
                OFFSET,
            >(),
            Rendering: Rendering::<Identity, OFFSET>,
            RemoveRendering: RemoveRendering::<Identity, OFFSET>,
            Rendered: Rendered::<Identity, OFFSET>,
            RemoveRendered: RemoveRendered::<Identity, OFFSET>,
            SurfaceContentsLost: SurfaceContentsLost::<Identity, OFFSET>,
            RemoveSurfaceContentsLost: RemoveSurfaceContentsLost::<Identity, OFFSET>,
            GetCompositorForCurrentThread: GetCompositorForCurrentThread::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICompositionTargetStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ICompositionTargetStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Rendering: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i64,
    ) -> windows_core::HRESULT,
    pub RemoveRendering:
        unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    pub Rendered: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i64,
    ) -> windows_core::HRESULT,
    pub RemoveRendered:
        unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    pub SurfaceContentsLost: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i64,
    ) -> windows_core::HRESULT,
    pub RemoveSurfaceContentsLost:
        unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    #[cfg(feature = "UI_Composition")]
    pub GetCompositorForCurrentThread: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    GetCompositorForCurrentThread: usize,
}
windows_core::imp::define_interface!(
    IDesktopAcrylicBackdrop,
    IDesktopAcrylicBackdrop_Vtbl,
    0xbfd9915b_82a6_5df6_aff0_a4824ddc1143
);
impl windows_core::RuntimeType for IDesktopAcrylicBackdrop {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDesktopAcrylicBackdrop {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IDesktopAcrylicBackdrop";
}
pub trait IDesktopAcrylicBackdrop_Impl: windows_core::IUnknownImpl {}
impl IDesktopAcrylicBackdrop_Vtbl {
    pub const fn new<Identity: IDesktopAcrylicBackdrop_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IDesktopAcrylicBackdrop, OFFSET>(
            ),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDesktopAcrylicBackdrop as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDesktopAcrylicBackdrop_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    IDesktopAcrylicBackdropFactory,
    IDesktopAcrylicBackdropFactory_Vtbl,
    0x00922e6d_ae51_564a_bce2_1973d5e463dd
);
impl windows_core::RuntimeType for IDesktopAcrylicBackdropFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDesktopAcrylicBackdropFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IDesktopAcrylicBackdropFactory";
}
pub trait IDesktopAcrylicBackdropFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<DesktopAcrylicBackdrop>;
}
impl IDesktopAcrylicBackdropFactory_Vtbl {
    pub const fn new<Identity: IDesktopAcrylicBackdropFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: IDesktopAcrylicBackdropFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDesktopAcrylicBackdropFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IDesktopAcrylicBackdropFactory,
                OFFSET,
            >(),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDesktopAcrylicBackdropFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDesktopAcrylicBackdropFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IEllipseGeometry,
    IEllipseGeometry_Vtbl,
    0xababd262_d8e4_5b49_bce9_0108a5209d45
);
impl windows_core::RuntimeType for IEllipseGeometry {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IEllipseGeometry {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IEllipseGeometry";
}
pub trait IEllipseGeometry_Impl: windows_core::IUnknownImpl {
    fn Center(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetCenter(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
    fn RadiusX(&self) -> windows_core::Result<f64>;
    fn SetRadiusX(&self, value: f64) -> windows_core::Result<()>;
    fn RadiusY(&self) -> windows_core::Result<f64>;
    fn SetRadiusY(&self, value: f64) -> windows_core::Result<()>;
}
impl IEllipseGeometry_Vtbl {
    pub const fn new<Identity: IEllipseGeometry_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Center<Identity: IEllipseGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEllipseGeometry_Impl::Center(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenter<
            Identity: IEllipseGeometry_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEllipseGeometry_Impl::SetCenter(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn RadiusX<Identity: IEllipseGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEllipseGeometry_Impl::RadiusX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRadiusX<
            Identity: IEllipseGeometry_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEllipseGeometry_Impl::SetRadiusX(this, value).into()
            }
        }
        unsafe extern "system" fn RadiusY<Identity: IEllipseGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEllipseGeometry_Impl::RadiusY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRadiusY<
            Identity: IEllipseGeometry_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IEllipseGeometry_Impl::SetRadiusY(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IEllipseGeometry, OFFSET>(),
            Center: Center::<Identity, OFFSET>,
            SetCenter: SetCenter::<Identity, OFFSET>,
            RadiusX: RadiusX::<Identity, OFFSET>,
            SetRadiusX: SetRadiusX::<Identity, OFFSET>,
            RadiusY: RadiusY::<Identity, OFFSET>,
            SetRadiusY: SetRadiusY::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEllipseGeometry as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IEllipseGeometry_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Center: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetCenter: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub RadiusX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetRadiusX: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub RadiusY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetRadiusY: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IEllipseGeometryStatics,
    IEllipseGeometryStatics_Vtbl,
    0xe8a33c80_d72f_5248_a71f_4b70a0757f89
);
impl windows_core::RuntimeType for IEllipseGeometryStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IEllipseGeometryStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IEllipseGeometryStatics";
}
pub trait IEllipseGeometryStatics_Impl: windows_core::IUnknownImpl {
    fn CenterProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn RadiusXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn RadiusYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IEllipseGeometryStatics_Vtbl {
    pub const fn new<Identity: IEllipseGeometryStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CenterProperty<
            Identity: IEllipseGeometryStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEllipseGeometryStatics_Impl::CenterProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RadiusXProperty<
            Identity: IEllipseGeometryStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEllipseGeometryStatics_Impl::RadiusXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RadiusYProperty<
            Identity: IEllipseGeometryStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IEllipseGeometryStatics_Impl::RadiusYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IEllipseGeometryStatics, OFFSET>(
            ),
            CenterProperty: CenterProperty::<Identity, OFFSET>,
            RadiusXProperty: RadiusXProperty::<Identity, OFFSET>,
            RadiusYProperty: RadiusYProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEllipseGeometryStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IEllipseGeometryStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CenterProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub RadiusXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub RadiusYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IFontFamily,
    IFontFamily_Vtbl,
    0x18fa5bc1_7294_527c_bb02_b213e0b3a2a3
);
impl windows_core::RuntimeType for IFontFamily {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IFontFamily {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IFontFamily";
}
pub trait IFontFamily_Impl: windows_core::IUnknownImpl {
    fn Source(&self) -> windows_core::Result<windows_core::HSTRING>;
}
impl IFontFamily_Vtbl {
    pub const fn new<Identity: IFontFamily_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Source<Identity: IFontFamily_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFontFamily_Impl::Source(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IFontFamily, OFFSET>(),
            Source: Source::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFontFamily as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFontFamily_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Source: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IFontFamilyFactory,
    IFontFamilyFactory_Vtbl,
    0x61b88a77_d0f9_5e9e_8c28_eda01fede22e
);
impl windows_core::RuntimeType for IFontFamilyFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IFontFamilyFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IFontFamilyFactory";
}
pub trait IFontFamilyFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstanceWithName(
        &self,
        familyName: &windows_core::HSTRING,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<FontFamily>;
}
impl IFontFamilyFactory_Vtbl {
    pub const fn new<Identity: IFontFamilyFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstanceWithName<
            Identity: IFontFamilyFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            familyname: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFontFamilyFactory_Impl::CreateInstanceWithName(
                    this,
                    core::mem::transmute(&familyname),
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IFontFamilyFactory, OFFSET>(),
            CreateInstanceWithName: CreateInstanceWithName::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFontFamilyFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFontFamilyFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CreateInstanceWithName: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IFontFamilyStatics,
    IFontFamilyStatics_Vtbl,
    0xb3eadceb_c471_58fe_93d0_d71b04a7fd54
);
impl windows_core::RuntimeType for IFontFamilyStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IFontFamilyStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IFontFamilyStatics";
}
pub trait IFontFamilyStatics_Impl: windows_core::IUnknownImpl {
    fn XamlAutoFontFamily(&self) -> windows_core::Result<FontFamily>;
}
impl IFontFamilyStatics_Vtbl {
    pub const fn new<Identity: IFontFamilyStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn XamlAutoFontFamily<
            Identity: IFontFamilyStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IFontFamilyStatics_Impl::XamlAutoFontFamily(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IFontFamilyStatics, OFFSET>(),
            XamlAutoFontFamily: XamlAutoFontFamily::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFontFamilyStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IFontFamilyStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub XamlAutoFontFamily: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IGeneralTransform,
    IGeneralTransform_Vtbl,
    0x04eedeeb_31e5_54c0_ae3f_8bd06645d339
);
impl windows_core::RuntimeType for IGeneralTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGeneralTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGeneralTransform";
}
pub trait IGeneralTransform_Impl: windows_core::IUnknownImpl {
    fn Inverse(&self) -> windows_core::Result<GeneralTransform>;
    fn TransformPoint(
        &self,
        point: &windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point>;
    fn TryTransform(
        &self,
        inPoint: &windows::Foundation::Point,
        outPoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool>;
    fn TransformBounds(
        &self,
        rect: &windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect>;
}
impl IGeneralTransform_Vtbl {
    pub const fn new<Identity: IGeneralTransform_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Inverse<Identity: IGeneralTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeneralTransform_Impl::Inverse(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TransformPoint<
            Identity: IGeneralTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            point: windows::Foundation::Point,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeneralTransform_Impl::TransformPoint(this, core::mem::transmute(&point)) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TryTransform<
            Identity: IGeneralTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            inpoint: windows::Foundation::Point,
            outpoint: *mut windows::Foundation::Point,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeneralTransform_Impl::TryTransform(
                    this,
                    core::mem::transmute(&inpoint),
                    core::mem::transmute_copy(&outpoint),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TransformBounds<
            Identity: IGeneralTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            rect: windows::Foundation::Rect,
            result__: *mut windows::Foundation::Rect,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeneralTransform_Impl::TransformBounds(this, core::mem::transmute(&rect)) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IGeneralTransform, OFFSET>(),
            Inverse: Inverse::<Identity, OFFSET>,
            TransformPoint: TransformPoint::<Identity, OFFSET>,
            TryTransform: TryTransform::<Identity, OFFSET>,
            TransformBounds: TransformBounds::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGeneralTransform as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGeneralTransform_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Inverse: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub TransformPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub TryTransform: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
        *mut windows::Foundation::Point,
        *mut bool,
    ) -> windows_core::HRESULT,
    pub TransformBounds: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Rect,
        *mut windows::Foundation::Rect,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IGeneralTransformFactory,
    IGeneralTransformFactory_Vtbl,
    0x2f1025a3_5391_5d1b_8382_3caaa1d26a96
);
impl windows_core::RuntimeType for IGeneralTransformFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGeneralTransformFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGeneralTransformFactory";
}
pub trait IGeneralTransformFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<GeneralTransform>;
}
impl IGeneralTransformFactory_Vtbl {
    pub const fn new<Identity: IGeneralTransformFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: IGeneralTransformFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeneralTransformFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IGeneralTransformFactory,
                OFFSET,
            >(),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGeneralTransformFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGeneralTransformFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IGeneralTransformOverrides,
    IGeneralTransformOverrides_Vtbl,
    0xce8970f1_83f8_543f_9cf5_439c461601f1
);
impl windows_core::RuntimeType for IGeneralTransformOverrides {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGeneralTransformOverrides {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGeneralTransformOverrides";
}
pub trait IGeneralTransformOverrides_Impl: windows_core::IUnknownImpl {
    fn InverseCore(&self) -> windows_core::Result<GeneralTransform>;
    fn TryTransformCore(
        &self,
        inPoint: &windows::Foundation::Point,
        outPoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool>;
    fn TransformBoundsCore(
        &self,
        rect: &windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect>;
}
impl IGeneralTransformOverrides_Vtbl {
    pub const fn new<Identity: IGeneralTransformOverrides_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn InverseCore<
            Identity: IGeneralTransformOverrides_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeneralTransformOverrides_Impl::InverseCore(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TryTransformCore<
            Identity: IGeneralTransformOverrides_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            inpoint: windows::Foundation::Point,
            outpoint: *mut windows::Foundation::Point,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeneralTransformOverrides_Impl::TryTransformCore(
                    this,
                    core::mem::transmute(&inpoint),
                    core::mem::transmute_copy(&outpoint),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TransformBoundsCore<
            Identity: IGeneralTransformOverrides_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            rect: windows::Foundation::Rect,
            result__: *mut windows::Foundation::Rect,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeneralTransformOverrides_Impl::TransformBoundsCore(
                    this,
                    core::mem::transmute(&rect),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IGeneralTransformOverrides,
                OFFSET,
            >(),
            InverseCore: InverseCore::<Identity, OFFSET>,
            TryTransformCore: TryTransformCore::<Identity, OFFSET>,
            TransformBoundsCore: TransformBoundsCore::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGeneralTransformOverrides as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGeneralTransformOverrides_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub InverseCore: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub TryTransformCore: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
        *mut windows::Foundation::Point,
        *mut bool,
    ) -> windows_core::HRESULT,
    pub TransformBoundsCore: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Rect,
        *mut windows::Foundation::Rect,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IGeometry,
    IGeometry_Vtbl,
    0xdc102dcc_3be2_5414_8599_94b6e76ef39b
);
impl windows_core::RuntimeType for IGeometry {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGeometry {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGeometry";
}
pub trait IGeometry_Impl: windows_core::IUnknownImpl {
    fn Transform(&self) -> windows_core::Result<Transform>;
    fn SetTransform(&self, value: windows_core::Ref<'_, Transform>) -> windows_core::Result<()>;
    fn Bounds(&self) -> windows_core::Result<windows::Foundation::Rect>;
}
impl IGeometry_Vtbl {
    pub const fn new<Identity: IGeometry_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Transform<Identity: IGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeometry_Impl::Transform(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetTransform<Identity: IGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGeometry_Impl::SetTransform(this, core::mem::transmute_copy(&value)).into()
            }
        }
        unsafe extern "system" fn Bounds<Identity: IGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Rect,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeometry_Impl::Bounds(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IGeometry, OFFSET>(),
            Transform: Transform::<Identity, OFFSET>,
            SetTransform: SetTransform::<Identity, OFFSET>,
            Bounds: Bounds::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGeometry as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGeometry_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Transform: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetTransform: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub Bounds: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Rect,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IGeometryFactory,
    IGeometryFactory_Vtbl,
    0x4edcd536_7949_548a_a9b1_6ff03b951cf3
);
impl windows_core::RuntimeType for IGeometryFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGeometryFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGeometryFactory";
}
pub trait IGeometryFactory_Impl: windows_core::IUnknownImpl {}
impl IGeometryFactory_Vtbl {
    pub const fn new<Identity: IGeometryFactory_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IGeometryFactory, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGeometryFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGeometryFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    IGeometryGroup,
    IGeometryGroup_Vtbl,
    0xb4dde569_ea96_5883_914c_ebb7d818dd3a
);
impl windows_core::RuntimeType for IGeometryGroup {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGeometryGroup {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGeometryGroup";
}
pub trait IGeometryGroup_Impl: windows_core::IUnknownImpl {
    fn FillRule(&self) -> windows_core::Result<FillRule>;
    fn SetFillRule(&self, value: FillRule) -> windows_core::Result<()>;
    fn Children(&self) -> windows_core::Result<GeometryCollection>;
    fn SetChildren(
        &self,
        value: windows_core::Ref<'_, GeometryCollection>,
    ) -> windows_core::Result<()>;
}
impl IGeometryGroup_Vtbl {
    pub const fn new<Identity: IGeometryGroup_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FillRule<Identity: IGeometryGroup_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut FillRule,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeometryGroup_Impl::FillRule(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetFillRule<
            Identity: IGeometryGroup_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: FillRule,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGeometryGroup_Impl::SetFillRule(this, value).into()
            }
        }
        unsafe extern "system" fn Children<Identity: IGeometryGroup_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeometryGroup_Impl::Children(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetChildren<
            Identity: IGeometryGroup_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGeometryGroup_Impl::SetChildren(this, core::mem::transmute_copy(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IGeometryGroup, OFFSET>(),
            FillRule: FillRule::<Identity, OFFSET>,
            SetFillRule: SetFillRule::<Identity, OFFSET>,
            Children: Children::<Identity, OFFSET>,
            SetChildren: SetChildren::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGeometryGroup as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGeometryGroup_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub FillRule:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut FillRule) -> windows_core::HRESULT,
    pub SetFillRule:
        unsafe extern "system" fn(*mut core::ffi::c_void, FillRule) -> windows_core::HRESULT,
    pub Children: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetChildren: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IGeometryGroupStatics,
    IGeometryGroupStatics_Vtbl,
    0x56a23da5_d015_568a_9f8b_11b125cfd9b4
);
impl windows_core::RuntimeType for IGeometryGroupStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGeometryGroupStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGeometryGroupStatics";
}
pub trait IGeometryGroupStatics_Impl: windows_core::IUnknownImpl {
    fn FillRuleProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn ChildrenProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IGeometryGroupStatics_Vtbl {
    pub const fn new<Identity: IGeometryGroupStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FillRuleProperty<
            Identity: IGeometryGroupStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeometryGroupStatics_Impl::FillRuleProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ChildrenProperty<
            Identity: IGeometryGroupStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeometryGroupStatics_Impl::ChildrenProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IGeometryGroupStatics, OFFSET>(
            ),
            FillRuleProperty: FillRuleProperty::<Identity, OFFSET>,
            ChildrenProperty: ChildrenProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGeometryGroupStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGeometryGroupStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub FillRuleProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub ChildrenProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IGeometryStatics,
    IGeometryStatics_Vtbl,
    0x349f78d0_4978_5742_b7d2_b34ea2c95600
);
impl windows_core::RuntimeType for IGeometryStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGeometryStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGeometryStatics";
}
pub trait IGeometryStatics_Impl: windows_core::IUnknownImpl {
    fn Empty(&self) -> windows_core::Result<Geometry>;
    fn StandardFlatteningTolerance(&self) -> windows_core::Result<f64>;
    fn TransformProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IGeometryStatics_Vtbl {
    pub const fn new<Identity: IGeometryStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Empty<Identity: IGeometryStatics_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeometryStatics_Impl::Empty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn StandardFlatteningTolerance<
            Identity: IGeometryStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeometryStatics_Impl::StandardFlatteningTolerance(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TransformProperty<
            Identity: IGeometryStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGeometryStatics_Impl::TransformProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IGeometryStatics, OFFSET>(),
            Empty: Empty::<Identity, OFFSET>,
            StandardFlatteningTolerance: StandardFlatteningTolerance::<Identity, OFFSET>,
            TransformProperty: TransformProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGeometryStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGeometryStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Empty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub StandardFlatteningTolerance:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub TransformProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IGradientBrush,
    IGradientBrush_Vtbl,
    0x77c347fa_c4c4_5174_a945_65cab3aa1c75
);
impl windows_core::RuntimeType for IGradientBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGradientBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGradientBrush";
}
pub trait IGradientBrush_Impl: windows_core::IUnknownImpl {
    fn SpreadMethod(&self) -> windows_core::Result<GradientSpreadMethod>;
    fn SetSpreadMethod(&self, value: GradientSpreadMethod) -> windows_core::Result<()>;
    fn MappingMode(&self) -> windows_core::Result<BrushMappingMode>;
    fn SetMappingMode(&self, value: BrushMappingMode) -> windows_core::Result<()>;
    fn ColorInterpolationMode(&self) -> windows_core::Result<ColorInterpolationMode>;
    fn SetColorInterpolationMode(&self, value: ColorInterpolationMode) -> windows_core::Result<()>;
    fn GradientStops(&self) -> windows_core::Result<GradientStopCollection>;
    fn SetGradientStops(
        &self,
        value: windows_core::Ref<'_, GradientStopCollection>,
    ) -> windows_core::Result<()>;
}
impl IGradientBrush_Vtbl {
    pub const fn new<Identity: IGradientBrush_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SpreadMethod<
            Identity: IGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut GradientSpreadMethod,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientBrush_Impl::SpreadMethod(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSpreadMethod<
            Identity: IGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: GradientSpreadMethod,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGradientBrush_Impl::SetSpreadMethod(this, value).into()
            }
        }
        unsafe extern "system" fn MappingMode<
            Identity: IGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut BrushMappingMode,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientBrush_Impl::MappingMode(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMappingMode<
            Identity: IGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: BrushMappingMode,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGradientBrush_Impl::SetMappingMode(this, value).into()
            }
        }
        unsafe extern "system" fn ColorInterpolationMode<
            Identity: IGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut ColorInterpolationMode,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientBrush_Impl::ColorInterpolationMode(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetColorInterpolationMode<
            Identity: IGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: ColorInterpolationMode,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGradientBrush_Impl::SetColorInterpolationMode(this, value).into()
            }
        }
        unsafe extern "system" fn GradientStops<
            Identity: IGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientBrush_Impl::GradientStops(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetGradientStops<
            Identity: IGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGradientBrush_Impl::SetGradientStops(this, core::mem::transmute_copy(&value))
                    .into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IGradientBrush, OFFSET>(),
            SpreadMethod: SpreadMethod::<Identity, OFFSET>,
            SetSpreadMethod: SetSpreadMethod::<Identity, OFFSET>,
            MappingMode: MappingMode::<Identity, OFFSET>,
            SetMappingMode: SetMappingMode::<Identity, OFFSET>,
            ColorInterpolationMode: ColorInterpolationMode::<Identity, OFFSET>,
            SetColorInterpolationMode: SetColorInterpolationMode::<Identity, OFFSET>,
            GradientStops: GradientStops::<Identity, OFFSET>,
            SetGradientStops: SetGradientStops::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGradientBrush as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGradientBrush_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub SpreadMethod: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut GradientSpreadMethod,
    ) -> windows_core::HRESULT,
    pub SetSpreadMethod: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        GradientSpreadMethod,
    ) -> windows_core::HRESULT,
    pub MappingMode: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut BrushMappingMode,
    ) -> windows_core::HRESULT,
    pub SetMappingMode: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        BrushMappingMode,
    ) -> windows_core::HRESULT,
    pub ColorInterpolationMode: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut ColorInterpolationMode,
    ) -> windows_core::HRESULT,
    pub SetColorInterpolationMode: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        ColorInterpolationMode,
    ) -> windows_core::HRESULT,
    pub GradientStops: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetGradientStops: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IGradientBrushFactory,
    IGradientBrushFactory_Vtbl,
    0x64ff6177_1eda_565b_b7aa_ac50152e3136
);
impl windows_core::RuntimeType for IGradientBrushFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IGradientBrushFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGradientBrushFactory";
}
#[cfg(feature = "UI_Composition")]
pub trait IGradientBrushFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<GradientBrush>;
}
#[cfg(feature = "UI_Composition")]
impl IGradientBrushFactory_Vtbl {
    pub const fn new<Identity: IGradientBrushFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: IGradientBrushFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientBrushFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IGradientBrushFactory, OFFSET>(
            ),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGradientBrushFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGradientBrushFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    CreateInstance: usize,
}
windows_core::imp::define_interface!(
    IGradientBrushStatics,
    IGradientBrushStatics_Vtbl,
    0x4d3697d7_c6db_501c_8fa2_da30b8c8ca3b
);
impl windows_core::RuntimeType for IGradientBrushStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGradientBrushStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGradientBrushStatics";
}
pub trait IGradientBrushStatics_Impl: windows_core::IUnknownImpl {
    fn SpreadMethodProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn MappingModeProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn ColorInterpolationModeProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn GradientStopsProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IGradientBrushStatics_Vtbl {
    pub const fn new<Identity: IGradientBrushStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SpreadMethodProperty<
            Identity: IGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientBrushStatics_Impl::SpreadMethodProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn MappingModeProperty<
            Identity: IGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientBrushStatics_Impl::MappingModeProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ColorInterpolationModeProperty<
            Identity: IGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientBrushStatics_Impl::ColorInterpolationModeProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GradientStopsProperty<
            Identity: IGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientBrushStatics_Impl::GradientStopsProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IGradientBrushStatics, OFFSET>(
            ),
            SpreadMethodProperty: SpreadMethodProperty::<Identity, OFFSET>,
            MappingModeProperty: MappingModeProperty::<Identity, OFFSET>,
            ColorInterpolationModeProperty: ColorInterpolationModeProperty::<Identity, OFFSET>,
            GradientStopsProperty: GradientStopsProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGradientBrushStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGradientBrushStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub SpreadMethodProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub MappingModeProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub ColorInterpolationModeProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub GradientStopsProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IGradientStop,
    IGradientStop_Vtbl,
    0x48bcb039_e8e1_5743_94c3_f766011d3b5d
);
impl windows_core::RuntimeType for IGradientStop {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGradientStop {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGradientStop";
}
pub trait IGradientStop_Impl: windows_core::IUnknownImpl {
    fn Color(&self) -> windows_core::Result<windows::UI::Color>;
    fn SetColor(&self, value: &windows::UI::Color) -> windows_core::Result<()>;
    fn Offset(&self) -> windows_core::Result<f64>;
    fn SetOffset(&self, value: f64) -> windows_core::Result<()>;
}
impl IGradientStop_Vtbl {
    pub const fn new<Identity: IGradientStop_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Color<Identity: IGradientStop_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::UI::Color,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientStop_Impl::Color(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetColor<Identity: IGradientStop_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: windows::UI::Color,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGradientStop_Impl::SetColor(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn Offset<Identity: IGradientStop_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientStop_Impl::Offset(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetOffset<Identity: IGradientStop_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IGradientStop_Impl::SetOffset(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IGradientStop, OFFSET>(),
            Color: Color::<Identity, OFFSET>,
            SetColor: SetColor::<Identity, OFFSET>,
            Offset: Offset::<Identity, OFFSET>,
            SetOffset: SetOffset::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGradientStop as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGradientStop_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Color: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::UI::Color,
    ) -> windows_core::HRESULT,
    pub SetColor: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::UI::Color,
    ) -> windows_core::HRESULT,
    pub Offset:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetOffset: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IGradientStopStatics,
    IGradientStopStatics_Vtbl,
    0x0b566c1b_37de_5bfd_b419_0f7c4c0a0523
);
impl windows_core::RuntimeType for IGradientStopStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IGradientStopStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IGradientStopStatics";
}
pub trait IGradientStopStatics_Impl: windows_core::IUnknownImpl {
    fn ColorProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn OffsetProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IGradientStopStatics_Vtbl {
    pub const fn new<Identity: IGradientStopStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ColorProperty<
            Identity: IGradientStopStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientStopStatics_Impl::ColorProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn OffsetProperty<
            Identity: IGradientStopStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IGradientStopStatics_Impl::OffsetProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IGradientStopStatics, OFFSET>(
            ),
            ColorProperty: ColorProperty::<Identity, OFFSET>,
            OffsetProperty: OffsetProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IGradientStopStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IGradientStopStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub ColorProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub OffsetProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IImageBrush,
    IImageBrush_Vtbl,
    0xedcd91a3_a868_5ba6_9489_5b12b4c29d85
);
impl windows_core::RuntimeType for IImageBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IImageBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IImageBrush";
}
pub trait IImageBrush_Impl: windows_core::IUnknownImpl {
    fn ImageSource(&self) -> windows_core::Result<ImageSource>;
    fn SetImageSource(&self, value: windows_core::Ref<'_, ImageSource>)
        -> windows_core::Result<()>;
    fn ImageFailed(
        &self,
        handler: windows_core::Ref<'_, super::ExceptionRoutedEventHandler>,
    ) -> windows_core::Result<i64>;
    fn RemoveImageFailed(&self, token: i64) -> windows_core::Result<()>;
    fn ImageOpened(
        &self,
        handler: windows_core::Ref<'_, super::RoutedEventHandler>,
    ) -> windows_core::Result<i64>;
    fn RemoveImageOpened(&self, token: i64) -> windows_core::Result<()>;
}
impl IImageBrush_Vtbl {
    pub const fn new<Identity: IImageBrush_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ImageSource<Identity: IImageBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IImageBrush_Impl::ImageSource(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetImageSource<
            Identity: IImageBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IImageBrush_Impl::SetImageSource(this, core::mem::transmute_copy(&value)).into()
            }
        }
        unsafe extern "system" fn ImageFailed<Identity: IImageBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            handler: *mut core::ffi::c_void,
            result__: *mut i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IImageBrush_Impl::ImageFailed(this, core::mem::transmute_copy(&handler)) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveImageFailed<
            Identity: IImageBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            token: i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IImageBrush_Impl::RemoveImageFailed(this, token).into()
            }
        }
        unsafe extern "system" fn ImageOpened<Identity: IImageBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            handler: *mut core::ffi::c_void,
            result__: *mut i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IImageBrush_Impl::ImageOpened(this, core::mem::transmute_copy(&handler)) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveImageOpened<
            Identity: IImageBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            token: i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IImageBrush_Impl::RemoveImageOpened(this, token).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IImageBrush, OFFSET>(),
            ImageSource: ImageSource::<Identity, OFFSET>,
            SetImageSource: SetImageSource::<Identity, OFFSET>,
            ImageFailed: ImageFailed::<Identity, OFFSET>,
            RemoveImageFailed: RemoveImageFailed::<Identity, OFFSET>,
            ImageOpened: ImageOpened::<Identity, OFFSET>,
            RemoveImageOpened: RemoveImageOpened::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IImageBrush as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IImageBrush_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub ImageSource: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetImageSource: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub ImageFailed: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i64,
    ) -> windows_core::HRESULT,
    pub RemoveImageFailed:
        unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    pub ImageOpened: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i64,
    ) -> windows_core::HRESULT,
    pub RemoveImageOpened:
        unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IImageBrushStatics,
    IImageBrushStatics_Vtbl,
    0xce8082dc_a505_5b4f_8861_79630f52c189
);
impl windows_core::RuntimeType for IImageBrushStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IImageBrushStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IImageBrushStatics";
}
pub trait IImageBrushStatics_Impl: windows_core::IUnknownImpl {
    fn ImageSourceProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IImageBrushStatics_Vtbl {
    pub const fn new<Identity: IImageBrushStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ImageSourceProperty<
            Identity: IImageBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IImageBrushStatics_Impl::ImageSourceProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IImageBrushStatics, OFFSET>(),
            ImageSourceProperty: ImageSourceProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IImageBrushStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IImageBrushStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub ImageSourceProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IImageSource,
    IImageSource_Vtbl,
    0x6c2038f6_d6d5_55e9_9b9e_082f12dbff60
);
impl windows_core::RuntimeType for IImageSource {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IImageSource {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IImageSource";
}
pub trait IImageSource_Impl: windows_core::IUnknownImpl {}
impl IImageSource_Vtbl {
    pub const fn new<Identity: IImageSource_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IImageSource, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IImageSource as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IImageSource_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    IImageSourceFactory,
    IImageSourceFactory_Vtbl,
    0x0b1e64a3_e353_5901_b84b_ae9842aea5cd
);
impl windows_core::RuntimeType for IImageSourceFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IImageSourceFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IImageSourceFactory";
}
pub trait IImageSourceFactory_Impl: windows_core::IUnknownImpl {}
impl IImageSourceFactory_Vtbl {
    pub const fn new<Identity: IImageSourceFactory_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IImageSourceFactory, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IImageSourceFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IImageSourceFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    ILineGeometry,
    ILineGeometry_Vtbl,
    0x467ef3c5_bc43_50ed_bb23_16be2c63356e
);
impl windows_core::RuntimeType for ILineGeometry {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ILineGeometry {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ILineGeometry";
}
pub trait ILineGeometry_Impl: windows_core::IUnknownImpl {
    fn StartPoint(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetStartPoint(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
    fn EndPoint(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetEndPoint(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
}
impl ILineGeometry_Vtbl {
    pub const fn new<Identity: ILineGeometry_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn StartPoint<Identity: ILineGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILineGeometry_Impl::StartPoint(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetStartPoint<
            Identity: ILineGeometry_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ILineGeometry_Impl::SetStartPoint(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn EndPoint<Identity: ILineGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILineGeometry_Impl::EndPoint(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetEndPoint<Identity: ILineGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ILineGeometry_Impl::SetEndPoint(this, core::mem::transmute(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ILineGeometry, OFFSET>(),
            StartPoint: StartPoint::<Identity, OFFSET>,
            SetStartPoint: SetStartPoint::<Identity, OFFSET>,
            EndPoint: EndPoint::<Identity, OFFSET>,
            SetEndPoint: SetEndPoint::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ILineGeometry as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ILineGeometry_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub StartPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetStartPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub EndPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetEndPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ILineGeometryStatics,
    ILineGeometryStatics_Vtbl,
    0xce0ecbf3_9389_5304_b7c8_5e610902f258
);
impl windows_core::RuntimeType for ILineGeometryStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ILineGeometryStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ILineGeometryStatics";
}
pub trait ILineGeometryStatics_Impl: windows_core::IUnknownImpl {
    fn StartPointProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn EndPointProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl ILineGeometryStatics_Vtbl {
    pub const fn new<Identity: ILineGeometryStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn StartPointProperty<
            Identity: ILineGeometryStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILineGeometryStatics_Impl::StartPointProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn EndPointProperty<
            Identity: ILineGeometryStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILineGeometryStatics_Impl::EndPointProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ILineGeometryStatics, OFFSET>(
            ),
            StartPointProperty: StartPointProperty::<Identity, OFFSET>,
            EndPointProperty: EndPointProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ILineGeometryStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ILineGeometryStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub StartPointProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub EndPointProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ILineSegment,
    ILineSegment_Vtbl,
    0x0c618e54_d883_588c_8875_bd8dfd6a6a3e
);
impl windows_core::RuntimeType for ILineSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ILineSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ILineSegment";
}
pub trait ILineSegment_Impl: windows_core::IUnknownImpl {
    fn Point(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetPoint(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
}
impl ILineSegment_Vtbl {
    pub const fn new<Identity: ILineSegment_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Point<Identity: ILineSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILineSegment_Impl::Point(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPoint<Identity: ILineSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ILineSegment_Impl::SetPoint(this, core::mem::transmute(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ILineSegment, OFFSET>(),
            Point: Point::<Identity, OFFSET>,
            SetPoint: SetPoint::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ILineSegment as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ILineSegment_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Point: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ILineSegmentStatics,
    ILineSegmentStatics_Vtbl,
    0xc3ec48a9_b9c0_561f_9925_d1d1b2a6bae6
);
impl windows_core::RuntimeType for ILineSegmentStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ILineSegmentStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ILineSegmentStatics";
}
pub trait ILineSegmentStatics_Impl: windows_core::IUnknownImpl {
    fn PointProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl ILineSegmentStatics_Vtbl {
    pub const fn new<Identity: ILineSegmentStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn PointProperty<
            Identity: ILineSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILineSegmentStatics_Impl::PointProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ILineSegmentStatics, OFFSET>(),
            PointProperty: PointProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ILineSegmentStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ILineSegmentStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub PointProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ILinearGradientBrush,
    ILinearGradientBrush_Vtbl,
    0xc0ab9638_1bd9_5fa4_9649_48cfa12f0d1e
);
impl windows_core::RuntimeType for ILinearGradientBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ILinearGradientBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ILinearGradientBrush";
}
pub trait ILinearGradientBrush_Impl: windows_core::IUnknownImpl {
    fn StartPoint(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetStartPoint(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
    fn EndPoint(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetEndPoint(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
}
impl ILinearGradientBrush_Vtbl {
    pub const fn new<Identity: ILinearGradientBrush_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn StartPoint<
            Identity: ILinearGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILinearGradientBrush_Impl::StartPoint(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetStartPoint<
            Identity: ILinearGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ILinearGradientBrush_Impl::SetStartPoint(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn EndPoint<
            Identity: ILinearGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILinearGradientBrush_Impl::EndPoint(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetEndPoint<
            Identity: ILinearGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ILinearGradientBrush_Impl::SetEndPoint(this, core::mem::transmute(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ILinearGradientBrush, OFFSET>(
            ),
            StartPoint: StartPoint::<Identity, OFFSET>,
            SetStartPoint: SetStartPoint::<Identity, OFFSET>,
            EndPoint: EndPoint::<Identity, OFFSET>,
            SetEndPoint: SetEndPoint::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ILinearGradientBrush as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ILinearGradientBrush_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub StartPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetStartPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub EndPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetEndPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ILinearGradientBrushFactory,
    ILinearGradientBrushFactory_Vtbl,
    0xc0ba7de3_ccfd_534c_882f_3ab39ae723f3
);
impl windows_core::RuntimeType for ILinearGradientBrushFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for ILinearGradientBrushFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ILinearGradientBrushFactory";
}
#[cfg(feature = "UI_Composition")]
pub trait ILinearGradientBrushFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstanceWithGradientStopCollectionAndAngle(
        &self,
        gradientStopCollection: windows_core::Ref<'_, GradientStopCollection>,
        angle: f64,
    ) -> windows_core::Result<LinearGradientBrush>;
}
#[cfg(feature = "UI_Composition")]
impl ILinearGradientBrushFactory_Vtbl {
    pub const fn new<Identity: ILinearGradientBrushFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstanceWithGradientStopCollectionAndAngle<
            Identity: ILinearGradientBrushFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            gradientstopcollection: *mut core::ffi::c_void,
            angle: f64,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILinearGradientBrushFactory_Impl:: CreateInstanceWithGradientStopCollectionAndAngle ( this , core::mem::transmute_copy ( & gradientstopcollection ) , angle , ) { Ok ( ok__ ) => { result__ . write ( core::mem::transmute_copy ( & ok__ ) ) ; core::mem::forget ( ok__ ) ; windows_core::HRESULT ( 0 ) } Err ( err ) => err . into ( ) }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                ILinearGradientBrushFactory,
                OFFSET,
            >(),
            CreateInstanceWithGradientStopCollectionAndAngle:
                CreateInstanceWithGradientStopCollectionAndAngle::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ILinearGradientBrushFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ILinearGradientBrushFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub CreateInstanceWithGradientStopCollectionAndAngle:
        unsafe extern "system" fn(
            *mut core::ffi::c_void,
            *mut core::ffi::c_void,
            f64,
            *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    CreateInstanceWithGradientStopCollectionAndAngle: usize,
}
windows_core::imp::define_interface!(
    ILinearGradientBrushStatics,
    ILinearGradientBrushStatics_Vtbl,
    0xdf029e84_f6be_5b7e_ba22_3b4e7a6bceee
);
impl windows_core::RuntimeType for ILinearGradientBrushStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ILinearGradientBrushStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ILinearGradientBrushStatics";
}
pub trait ILinearGradientBrushStatics_Impl: windows_core::IUnknownImpl {
    fn StartPointProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn EndPointProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl ILinearGradientBrushStatics_Vtbl {
    pub const fn new<Identity: ILinearGradientBrushStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn StartPointProperty<
            Identity: ILinearGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILinearGradientBrushStatics_Impl::StartPointProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn EndPointProperty<
            Identity: ILinearGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILinearGradientBrushStatics_Impl::EndPointProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                ILinearGradientBrushStatics,
                OFFSET,
            >(),
            StartPointProperty: StartPointProperty::<Identity, OFFSET>,
            EndPointProperty: EndPointProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ILinearGradientBrushStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ILinearGradientBrushStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub StartPointProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub EndPointProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ILoadedImageSourceLoadCompletedEventArgs,
    ILoadedImageSourceLoadCompletedEventArgs_Vtbl,
    0x4121bb7c_48e8_542d_b950_3ea7e709c0d6
);
impl windows_core::RuntimeType for ILoadedImageSourceLoadCompletedEventArgs {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ILoadedImageSourceLoadCompletedEventArgs {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ILoadedImageSourceLoadCompletedEventArgs";
}
pub trait ILoadedImageSourceLoadCompletedEventArgs_Impl: windows_core::IUnknownImpl {
    fn Status(&self) -> windows_core::Result<LoadedImageSourceLoadStatus>;
}
impl ILoadedImageSourceLoadCompletedEventArgs_Vtbl {
    pub const fn new<
        Identity: ILoadedImageSourceLoadCompletedEventArgs_Impl,
        const OFFSET: isize,
    >() -> Self {
        unsafe extern "system" fn Status<
            Identity: ILoadedImageSourceLoadCompletedEventArgs_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut LoadedImageSourceLoadStatus,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILoadedImageSourceLoadCompletedEventArgs_Impl::Status(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                ILoadedImageSourceLoadCompletedEventArgs,
                OFFSET,
            >(),
            Status: Status::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ILoadedImageSourceLoadCompletedEventArgs as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ILoadedImageSourceLoadCompletedEventArgs_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Status: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut LoadedImageSourceLoadStatus,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ILoadedImageSurface,
    ILoadedImageSurface_Vtbl,
    0xb5275540_1706_5851_95cc_498ee81fb183
);
impl windows_core::RuntimeType for ILoadedImageSurface {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for ILoadedImageSurface {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ILoadedImageSurface";
}
#[cfg(feature = "UI_Composition")]
pub trait ILoadedImageSurface_Impl: windows_core::IUnknownImpl {
    fn DecodedPhysicalSize(&self) -> windows_core::Result<windows::Foundation::Size>;
    fn DecodedSize(&self) -> windows_core::Result<windows::Foundation::Size>;
    fn NaturalSize(&self) -> windows_core::Result<windows::Foundation::Size>;
    fn LoadCompleted(
        &self,
        handler: windows_core::Ref<
            '_,
            windows::Foundation::TypedEventHandler<
                LoadedImageSurface,
                LoadedImageSourceLoadCompletedEventArgs,
            >,
        >,
    ) -> windows_core::Result<i64>;
    fn RemoveLoadCompleted(&self, token: i64) -> windows_core::Result<()>;
}
#[cfg(feature = "UI_Composition")]
impl ILoadedImageSurface_Vtbl {
    pub const fn new<Identity: ILoadedImageSurface_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn DecodedPhysicalSize<
            Identity: ILoadedImageSurface_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Size,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILoadedImageSurface_Impl::DecodedPhysicalSize(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn DecodedSize<
            Identity: ILoadedImageSurface_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Size,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILoadedImageSurface_Impl::DecodedSize(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn NaturalSize<
            Identity: ILoadedImageSurface_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Size,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILoadedImageSurface_Impl::NaturalSize(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn LoadCompleted<
            Identity: ILoadedImageSurface_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            handler: *mut core::ffi::c_void,
            result__: *mut i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILoadedImageSurface_Impl::LoadCompleted(
                    this,
                    core::mem::transmute_copy(&handler),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveLoadCompleted<
            Identity: ILoadedImageSurface_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            token: i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ILoadedImageSurface_Impl::RemoveLoadCompleted(this, token).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ILoadedImageSurface, OFFSET>(),
            DecodedPhysicalSize: DecodedPhysicalSize::<Identity, OFFSET>,
            DecodedSize: DecodedSize::<Identity, OFFSET>,
            NaturalSize: NaturalSize::<Identity, OFFSET>,
            LoadCompleted: LoadCompleted::<Identity, OFFSET>,
            RemoveLoadCompleted: RemoveLoadCompleted::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ILoadedImageSurface as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ILoadedImageSurface_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub DecodedPhysicalSize: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Size,
    ) -> windows_core::HRESULT,
    pub DecodedSize: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Size,
    ) -> windows_core::HRESULT,
    pub NaturalSize: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Size,
    ) -> windows_core::HRESULT,
    #[cfg(feature = "UI_Composition")]
    pub LoadCompleted: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i64,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    LoadCompleted: usize,
    pub RemoveLoadCompleted:
        unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ILoadedImageSurfaceStatics,
    ILoadedImageSurfaceStatics_Vtbl,
    0x25d390c4_4e32_52c2_868f_f2ede74ee442
);
impl windows_core::RuntimeType for ILoadedImageSurfaceStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for ILoadedImageSurfaceStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ILoadedImageSurfaceStatics";
}
#[cfg(feature = "UI_Composition")]
pub trait ILoadedImageSurfaceStatics_Impl: windows_core::IUnknownImpl {
    fn StartLoadFromUriWithSize(
        &self,
        uri: windows_core::Ref<'_, windows::Foundation::Uri>,
        desiredMaxSize: &windows::Foundation::Size,
    ) -> windows_core::Result<LoadedImageSurface>;
    fn StartLoadFromUri(
        &self,
        uri: windows_core::Ref<'_, windows::Foundation::Uri>,
    ) -> windows_core::Result<LoadedImageSurface>;
    fn StartLoadFromStreamWithSize(
        &self,
        stream: windows_core::Ref<'_, windows::Storage::Streams::IRandomAccessStream>,
        desiredMaxSize: &windows::Foundation::Size,
    ) -> windows_core::Result<LoadedImageSurface>;
    fn StartLoadFromStream(
        &self,
        stream: windows_core::Ref<'_, windows::Storage::Streams::IRandomAccessStream>,
    ) -> windows_core::Result<LoadedImageSurface>;
}
#[cfg(feature = "UI_Composition")]
impl ILoadedImageSurfaceStatics_Vtbl {
    pub const fn new<Identity: ILoadedImageSurfaceStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn StartLoadFromUriWithSize<
            Identity: ILoadedImageSurfaceStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            uri: *mut core::ffi::c_void,
            desiredmaxsize: windows::Foundation::Size,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILoadedImageSurfaceStatics_Impl::StartLoadFromUriWithSize(
                    this,
                    core::mem::transmute_copy(&uri),
                    core::mem::transmute(&desiredmaxsize),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn StartLoadFromUri<
            Identity: ILoadedImageSurfaceStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            uri: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILoadedImageSurfaceStatics_Impl::StartLoadFromUri(
                    this,
                    core::mem::transmute_copy(&uri),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn StartLoadFromStreamWithSize<
            Identity: ILoadedImageSurfaceStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            stream: *mut core::ffi::c_void,
            desiredmaxsize: windows::Foundation::Size,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILoadedImageSurfaceStatics_Impl::StartLoadFromStreamWithSize(
                    this,
                    core::mem::transmute_copy(&stream),
                    core::mem::transmute(&desiredmaxsize),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn StartLoadFromStream<
            Identity: ILoadedImageSurfaceStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            stream: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ILoadedImageSurfaceStatics_Impl::StartLoadFromStream(
                    this,
                    core::mem::transmute_copy(&stream),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                ILoadedImageSurfaceStatics,
                OFFSET,
            >(),
            StartLoadFromUriWithSize: StartLoadFromUriWithSize::<Identity, OFFSET>,
            StartLoadFromUri: StartLoadFromUri::<Identity, OFFSET>,
            StartLoadFromStreamWithSize: StartLoadFromStreamWithSize::<Identity, OFFSET>,
            StartLoadFromStream: StartLoadFromStream::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ILoadedImageSurfaceStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ILoadedImageSurfaceStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub StartLoadFromUriWithSize: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        windows::Foundation::Size,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    StartLoadFromUriWithSize: usize,
    #[cfg(feature = "UI_Composition")]
    pub StartLoadFromUri: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    StartLoadFromUri: usize,
    #[cfg(feature = "UI_Composition")]
    pub StartLoadFromStreamWithSize: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        windows::Foundation::Size,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    StartLoadFromStreamWithSize: usize,
    #[cfg(feature = "UI_Composition")]
    pub StartLoadFromStream: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    StartLoadFromStream: usize,
}
windows_core::imp::define_interface!(
    IMatrix3DProjection,
    IMatrix3DProjection_Vtbl,
    0xfc3338ef_f390_5bb1_932e_3b7c08788187
);
impl windows_core::RuntimeType for IMatrix3DProjection {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Xaml_Media_Media3D")]
impl windows_core::RuntimeName for IMatrix3DProjection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IMatrix3DProjection";
}
#[cfg(feature = "UI_Xaml_Media_Media3D")]
pub trait IMatrix3DProjection_Impl: windows_core::IUnknownImpl {
    fn ProjectionMatrix(&self) -> windows_core::Result<Media3D::Matrix3D>;
    fn SetProjectionMatrix(&self, value: &Media3D::Matrix3D) -> windows_core::Result<()>;
}
#[cfg(feature = "UI_Xaml_Media_Media3D")]
impl IMatrix3DProjection_Vtbl {
    pub const fn new<Identity: IMatrix3DProjection_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ProjectionMatrix<
            Identity: IMatrix3DProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut Media3D::Matrix3D,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMatrix3DProjection_Impl::ProjectionMatrix(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetProjectionMatrix<
            Identity: IMatrix3DProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: Media3D::Matrix3D,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMatrix3DProjection_Impl::SetProjectionMatrix(this, core::mem::transmute(&value))
                    .into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IMatrix3DProjection, OFFSET>(),
            ProjectionMatrix: ProjectionMatrix::<Identity, OFFSET>,
            SetProjectionMatrix: SetProjectionMatrix::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMatrix3DProjection as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMatrix3DProjection_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Xaml_Media_Media3D")]
    pub ProjectionMatrix: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut Media3D::Matrix3D,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Xaml_Media_Media3D"))]
    ProjectionMatrix: usize,
    #[cfg(feature = "UI_Xaml_Media_Media3D")]
    pub SetProjectionMatrix: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        Media3D::Matrix3D,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Xaml_Media_Media3D"))]
    SetProjectionMatrix: usize,
}
windows_core::imp::define_interface!(
    IMatrix3DProjectionStatics,
    IMatrix3DProjectionStatics_Vtbl,
    0xa5a7e267_7a5d_58ef_a8cd_b88ebdf82207
);
impl windows_core::RuntimeType for IMatrix3DProjectionStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IMatrix3DProjectionStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IMatrix3DProjectionStatics";
}
pub trait IMatrix3DProjectionStatics_Impl: windows_core::IUnknownImpl {
    fn ProjectionMatrixProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IMatrix3DProjectionStatics_Vtbl {
    pub const fn new<Identity: IMatrix3DProjectionStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ProjectionMatrixProperty<
            Identity: IMatrix3DProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMatrix3DProjectionStatics_Impl::ProjectionMatrixProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IMatrix3DProjectionStatics,
                OFFSET,
            >(),
            ProjectionMatrixProperty: ProjectionMatrixProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMatrix3DProjectionStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMatrix3DProjectionStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub ProjectionMatrixProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IMatrixHelper,
    IMatrixHelper_Vtbl,
    0x9571fd76_cc5c_534d_ac85_cb4ac870c912
);
impl windows_core::RuntimeType for IMatrixHelper {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IMatrixHelper {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IMatrixHelper";
}
pub trait IMatrixHelper_Impl: windows_core::IUnknownImpl {}
impl IMatrixHelper_Vtbl {
    pub const fn new<Identity: IMatrixHelper_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IMatrixHelper, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMatrixHelper as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMatrixHelper_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    IMatrixHelperStatics,
    IMatrixHelperStatics_Vtbl,
    0x5762cf6b_4fb0_532f_8368_de960042701f
);
impl windows_core::RuntimeType for IMatrixHelperStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IMatrixHelperStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IMatrixHelperStatics";
}
pub trait IMatrixHelperStatics_Impl: windows_core::IUnknownImpl {
    fn Identity(&self) -> windows_core::Result<Matrix>;
    fn FromElements(
        &self,
        m11: f64,
        m12: f64,
        m21: f64,
        m22: f64,
        offsetX: f64,
        offsetY: f64,
    ) -> windows_core::Result<Matrix>;
    fn GetIsIdentity(&self, target: &Matrix) -> windows_core::Result<bool>;
    fn Transform(
        &self,
        target: &Matrix,
        point: &windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point>;
}
impl IMatrixHelperStatics_Vtbl {
    pub const fn new<Identity: IMatrixHelperStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Identity<
            Identity: IMatrixHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut Matrix,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMatrixHelperStatics_Impl::Identity(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn FromElements<
            Identity: IMatrixHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            m11: f64,
            m12: f64,
            m21: f64,
            m22: f64,
            offsetx: f64,
            offsety: f64,
            result__: *mut Matrix,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMatrixHelperStatics_Impl::FromElements(
                    this, m11, m12, m21, m22, offsetx, offsety,
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetIsIdentity<
            Identity: IMatrixHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            target: Matrix,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMatrixHelperStatics_Impl::GetIsIdentity(this, core::mem::transmute(&target))
                {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Transform<
            Identity: IMatrixHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            target: Matrix,
            point: windows::Foundation::Point,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMatrixHelperStatics_Impl::Transform(
                    this,
                    core::mem::transmute(&target),
                    core::mem::transmute(&point),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IMatrixHelperStatics, OFFSET>(
            ),
            Identity: Identity::<Identity, OFFSET>,
            FromElements: FromElements::<Identity, OFFSET>,
            GetIsIdentity: GetIsIdentity::<Identity, OFFSET>,
            Transform: Transform::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMatrixHelperStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMatrixHelperStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Identity:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut Matrix) -> windows_core::HRESULT,
    pub FromElements: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        f64,
        f64,
        f64,
        f64,
        f64,
        f64,
        *mut Matrix,
    ) -> windows_core::HRESULT,
    pub GetIsIdentity: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        Matrix,
        *mut bool,
    ) -> windows_core::HRESULT,
    pub Transform: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        Matrix,
        windows::Foundation::Point,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IMatrixTransform,
    IMatrixTransform_Vtbl,
    0xf03138e1_addd_59fa_b993_3ea69b888ace
);
impl windows_core::RuntimeType for IMatrixTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IMatrixTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IMatrixTransform";
}
pub trait IMatrixTransform_Impl: windows_core::IUnknownImpl {
    fn Matrix(&self) -> windows_core::Result<Matrix>;
    fn SetMatrix(&self, value: &Matrix) -> windows_core::Result<()>;
}
impl IMatrixTransform_Vtbl {
    pub const fn new<Identity: IMatrixTransform_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Matrix<Identity: IMatrixTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut Matrix,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMatrixTransform_Impl::Matrix(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMatrix<
            Identity: IMatrixTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: Matrix,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMatrixTransform_Impl::SetMatrix(this, core::mem::transmute(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IMatrixTransform, OFFSET>(),
            Matrix: Matrix::<Identity, OFFSET>,
            SetMatrix: SetMatrix::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMatrixTransform as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMatrixTransform_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Matrix:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut Matrix) -> windows_core::HRESULT,
    pub SetMatrix:
        unsafe extern "system" fn(*mut core::ffi::c_void, Matrix) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IMatrixTransformStatics,
    IMatrixTransformStatics_Vtbl,
    0xd7db9de3_5071_5115_98fb_ccad2fd46e44
);
impl windows_core::RuntimeType for IMatrixTransformStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IMatrixTransformStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IMatrixTransformStatics";
}
pub trait IMatrixTransformStatics_Impl: windows_core::IUnknownImpl {
    fn MatrixProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IMatrixTransformStatics_Vtbl {
    pub const fn new<Identity: IMatrixTransformStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn MatrixProperty<
            Identity: IMatrixTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMatrixTransformStatics_Impl::MatrixProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IMatrixTransformStatics, OFFSET>(
            ),
            MatrixProperty: MatrixProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMatrixTransformStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMatrixTransformStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub MatrixProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IMediaTransportControlsThumbnailRequestedEventArgs,
    IMediaTransportControlsThumbnailRequestedEventArgs_Vtbl,
    0xfe0ffb86_74b0_5031_accc_b34d0382a637
);
impl windows_core::RuntimeType for IMediaTransportControlsThumbnailRequestedEventArgs {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IMediaTransportControlsThumbnailRequestedEventArgs {
    const NAME: &'static str =
        "Microsoft.UI.Xaml.Media.IMediaTransportControlsThumbnailRequestedEventArgs";
}
pub trait IMediaTransportControlsThumbnailRequestedEventArgs_Impl:
    windows_core::IUnknownImpl
{
    fn SetThumbnailImage(
        &self,
        source: windows_core::Ref<'_, windows::Storage::Streams::IInputStream>,
    ) -> windows_core::Result<()>;
    fn GetDeferral(&self) -> windows_core::Result<windows::Foundation::Deferral>;
}
impl IMediaTransportControlsThumbnailRequestedEventArgs_Vtbl {
    pub const fn new<
        Identity: IMediaTransportControlsThumbnailRequestedEventArgs_Impl,
        const OFFSET: isize,
    >() -> Self {
        unsafe extern "system" fn SetThumbnailImage<
            Identity: IMediaTransportControlsThumbnailRequestedEventArgs_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            source: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMediaTransportControlsThumbnailRequestedEventArgs_Impl::SetThumbnailImage(
                    this,
                    core::mem::transmute_copy(&source),
                )
                .into()
            }
        }
        unsafe extern "system" fn GetDeferral<
            Identity: IMediaTransportControlsThumbnailRequestedEventArgs_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMediaTransportControlsThumbnailRequestedEventArgs_Impl::GetDeferral(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IMediaTransportControlsThumbnailRequestedEventArgs,
                OFFSET,
            >(),
            SetThumbnailImage: SetThumbnailImage::<Identity, OFFSET>,
            GetDeferral: GetDeferral::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMediaTransportControlsThumbnailRequestedEventArgs as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMediaTransportControlsThumbnailRequestedEventArgs_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub SetThumbnailImage: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub GetDeferral: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IMicaBackdrop,
    IMicaBackdrop_Vtbl,
    0xc156a404_3dac_593a_b1f3_7a33c289dc83
);
impl windows_core::RuntimeType for IMicaBackdrop {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition_SystemBackdrops")]
impl windows_core::RuntimeName for IMicaBackdrop {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IMicaBackdrop";
}
#[cfg(feature = "UI_Composition_SystemBackdrops")]
pub trait IMicaBackdrop_Impl: windows_core::IUnknownImpl {
    fn Kind(&self) -> windows_core::Result<super::super::Composition::SystemBackdrops::MicaKind>;
    fn SetKind(
        &self,
        value: super::super::Composition::SystemBackdrops::MicaKind,
    ) -> windows_core::Result<()>;
}
#[cfg(feature = "UI_Composition_SystemBackdrops")]
impl IMicaBackdrop_Vtbl {
    pub const fn new<Identity: IMicaBackdrop_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Kind<Identity: IMicaBackdrop_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut super::super::Composition::SystemBackdrops::MicaKind,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMicaBackdrop_Impl::Kind(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetKind<Identity: IMicaBackdrop_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: super::super::Composition::SystemBackdrops::MicaKind,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IMicaBackdrop_Impl::SetKind(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IMicaBackdrop, OFFSET>(),
            Kind: Kind::<Identity, OFFSET>,
            SetKind: SetKind::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMicaBackdrop as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMicaBackdrop_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition_SystemBackdrops")]
    pub Kind: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut super::super::Composition::SystemBackdrops::MicaKind,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition_SystemBackdrops"))]
    Kind: usize,
    #[cfg(feature = "UI_Composition_SystemBackdrops")]
    pub SetKind: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        super::super::Composition::SystemBackdrops::MicaKind,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition_SystemBackdrops"))]
    SetKind: usize,
}
windows_core::imp::define_interface!(
    IMicaBackdropFactory,
    IMicaBackdropFactory_Vtbl,
    0x774379ce_74bd_59d4_849d_d99c4184d838
);
impl windows_core::RuntimeType for IMicaBackdropFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IMicaBackdropFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IMicaBackdropFactory";
}
pub trait IMicaBackdropFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<MicaBackdrop>;
}
impl IMicaBackdropFactory_Vtbl {
    pub const fn new<Identity: IMicaBackdropFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: IMicaBackdropFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMicaBackdropFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IMicaBackdropFactory, OFFSET>(
            ),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMicaBackdropFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMicaBackdropFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IMicaBackdropStatics,
    IMicaBackdropStatics_Vtbl,
    0xa63abdce_c796_5509_9f4d_072bc1e599f1
);
impl windows_core::RuntimeType for IMicaBackdropStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IMicaBackdropStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IMicaBackdropStatics";
}
pub trait IMicaBackdropStatics_Impl: windows_core::IUnknownImpl {
    fn KindProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IMicaBackdropStatics_Vtbl {
    pub const fn new<Identity: IMicaBackdropStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn KindProperty<
            Identity: IMicaBackdropStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IMicaBackdropStatics_Impl::KindProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IMicaBackdropStatics, OFFSET>(
            ),
            KindProperty: KindProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMicaBackdropStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IMicaBackdropStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub KindProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IPathFigure,
    IPathFigure_Vtbl,
    0x0ee00712_bf65_5f27_9c06_14abdf6656d7
);
impl windows_core::RuntimeType for IPathFigure {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPathFigure {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPathFigure";
}
pub trait IPathFigure_Impl: windows_core::IUnknownImpl {
    fn Segments(&self) -> windows_core::Result<PathSegmentCollection>;
    fn SetSegments(
        &self,
        value: windows_core::Ref<'_, PathSegmentCollection>,
    ) -> windows_core::Result<()>;
    fn StartPoint(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetStartPoint(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
    fn IsClosed(&self) -> windows_core::Result<bool>;
    fn SetIsClosed(&self, value: bool) -> windows_core::Result<()>;
    fn IsFilled(&self) -> windows_core::Result<bool>;
    fn SetIsFilled(&self, value: bool) -> windows_core::Result<()>;
}
impl IPathFigure_Vtbl {
    pub const fn new<Identity: IPathFigure_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Segments<Identity: IPathFigure_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathFigure_Impl::Segments(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSegments<Identity: IPathFigure_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPathFigure_Impl::SetSegments(this, core::mem::transmute_copy(&value)).into()
            }
        }
        unsafe extern "system" fn StartPoint<Identity: IPathFigure_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathFigure_Impl::StartPoint(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetStartPoint<Identity: IPathFigure_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPathFigure_Impl::SetStartPoint(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn IsClosed<Identity: IPathFigure_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathFigure_Impl::IsClosed(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetIsClosed<Identity: IPathFigure_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPathFigure_Impl::SetIsClosed(this, value).into()
            }
        }
        unsafe extern "system" fn IsFilled<Identity: IPathFigure_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathFigure_Impl::IsFilled(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetIsFilled<Identity: IPathFigure_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPathFigure_Impl::SetIsFilled(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IPathFigure, OFFSET>(),
            Segments: Segments::<Identity, OFFSET>,
            SetSegments: SetSegments::<Identity, OFFSET>,
            StartPoint: StartPoint::<Identity, OFFSET>,
            SetStartPoint: SetStartPoint::<Identity, OFFSET>,
            IsClosed: IsClosed::<Identity, OFFSET>,
            SetIsClosed: SetIsClosed::<Identity, OFFSET>,
            IsFilled: IsFilled::<Identity, OFFSET>,
            SetIsFilled: SetIsFilled::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPathFigure as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPathFigure_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Segments: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetSegments: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub StartPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetStartPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub IsClosed:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut bool) -> windows_core::HRESULT,
    pub SetIsClosed:
        unsafe extern "system" fn(*mut core::ffi::c_void, bool) -> windows_core::HRESULT,
    pub IsFilled:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut bool) -> windows_core::HRESULT,
    pub SetIsFilled:
        unsafe extern "system" fn(*mut core::ffi::c_void, bool) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IPathFigureStatics,
    IPathFigureStatics_Vtbl,
    0x93bc33c4_879a_5edb_b8d7_7ecb861a7314
);
impl windows_core::RuntimeType for IPathFigureStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPathFigureStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPathFigureStatics";
}
pub trait IPathFigureStatics_Impl: windows_core::IUnknownImpl {
    fn SegmentsProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn StartPointProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn IsClosedProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn IsFilledProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IPathFigureStatics_Vtbl {
    pub const fn new<Identity: IPathFigureStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn SegmentsProperty<
            Identity: IPathFigureStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathFigureStatics_Impl::SegmentsProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn StartPointProperty<
            Identity: IPathFigureStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathFigureStatics_Impl::StartPointProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn IsClosedProperty<
            Identity: IPathFigureStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathFigureStatics_Impl::IsClosedProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn IsFilledProperty<
            Identity: IPathFigureStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathFigureStatics_Impl::IsFilledProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IPathFigureStatics, OFFSET>(),
            SegmentsProperty: SegmentsProperty::<Identity, OFFSET>,
            StartPointProperty: StartPointProperty::<Identity, OFFSET>,
            IsClosedProperty: IsClosedProperty::<Identity, OFFSET>,
            IsFilledProperty: IsFilledProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPathFigureStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPathFigureStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub SegmentsProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub StartPointProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub IsClosedProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub IsFilledProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IPathGeometry,
    IPathGeometry_Vtbl,
    0x11b9d95d_d3d9_5337_a05c_73a27a2b5124
);
impl windows_core::RuntimeType for IPathGeometry {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPathGeometry {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPathGeometry";
}
pub trait IPathGeometry_Impl: windows_core::IUnknownImpl {
    fn FillRule(&self) -> windows_core::Result<FillRule>;
    fn SetFillRule(&self, value: FillRule) -> windows_core::Result<()>;
    fn Figures(&self) -> windows_core::Result<PathFigureCollection>;
    fn SetFigures(
        &self,
        value: windows_core::Ref<'_, PathFigureCollection>,
    ) -> windows_core::Result<()>;
}
impl IPathGeometry_Vtbl {
    pub const fn new<Identity: IPathGeometry_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FillRule<Identity: IPathGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut FillRule,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathGeometry_Impl::FillRule(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetFillRule<Identity: IPathGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: FillRule,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPathGeometry_Impl::SetFillRule(this, value).into()
            }
        }
        unsafe extern "system" fn Figures<Identity: IPathGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathGeometry_Impl::Figures(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetFigures<Identity: IPathGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPathGeometry_Impl::SetFigures(this, core::mem::transmute_copy(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IPathGeometry, OFFSET>(),
            FillRule: FillRule::<Identity, OFFSET>,
            SetFillRule: SetFillRule::<Identity, OFFSET>,
            Figures: Figures::<Identity, OFFSET>,
            SetFigures: SetFigures::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPathGeometry as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPathGeometry_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub FillRule:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut FillRule) -> windows_core::HRESULT,
    pub SetFillRule:
        unsafe extern "system" fn(*mut core::ffi::c_void, FillRule) -> windows_core::HRESULT,
    pub Figures: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetFigures: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IPathGeometryStatics,
    IPathGeometryStatics_Vtbl,
    0xd7f408fe_6c3a_5cce_91cc_c5a95d4b345a
);
impl windows_core::RuntimeType for IPathGeometryStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPathGeometryStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPathGeometryStatics";
}
pub trait IPathGeometryStatics_Impl: windows_core::IUnknownImpl {
    fn FillRuleProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn FiguresProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IPathGeometryStatics_Vtbl {
    pub const fn new<Identity: IPathGeometryStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FillRuleProperty<
            Identity: IPathGeometryStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathGeometryStatics_Impl::FillRuleProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn FiguresProperty<
            Identity: IPathGeometryStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPathGeometryStatics_Impl::FiguresProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IPathGeometryStatics, OFFSET>(
            ),
            FillRuleProperty: FillRuleProperty::<Identity, OFFSET>,
            FiguresProperty: FiguresProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPathGeometryStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPathGeometryStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub FillRuleProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub FiguresProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IPathSegment,
    IPathSegment_Vtbl,
    0xb922ebbe_08f0_57e9_8785_7e57097f3bd4
);
impl windows_core::RuntimeType for IPathSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPathSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPathSegment";
}
pub trait IPathSegment_Impl: windows_core::IUnknownImpl {}
impl IPathSegment_Vtbl {
    pub const fn new<Identity: IPathSegment_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IPathSegment, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPathSegment as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPathSegment_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    IPathSegmentFactory,
    IPathSegmentFactory_Vtbl,
    0x0559a4ff_ac4b_5bb7_b541_d373960e083b
);
impl windows_core::RuntimeType for IPathSegmentFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPathSegmentFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPathSegmentFactory";
}
pub trait IPathSegmentFactory_Impl: windows_core::IUnknownImpl {}
impl IPathSegmentFactory_Vtbl {
    pub const fn new<Identity: IPathSegmentFactory_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IPathSegmentFactory, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPathSegmentFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPathSegmentFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    IPlaneProjection,
    IPlaneProjection_Vtbl,
    0xd3e22836_0322_5d75_941c_a5ffb05192b2
);
impl windows_core::RuntimeType for IPlaneProjection {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Xaml_Media_Media3D")]
impl windows_core::RuntimeName for IPlaneProjection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPlaneProjection";
}
#[cfg(feature = "UI_Xaml_Media_Media3D")]
pub trait IPlaneProjection_Impl: windows_core::IUnknownImpl {
    fn LocalOffsetX(&self) -> windows_core::Result<f64>;
    fn SetLocalOffsetX(&self, value: f64) -> windows_core::Result<()>;
    fn LocalOffsetY(&self) -> windows_core::Result<f64>;
    fn SetLocalOffsetY(&self, value: f64) -> windows_core::Result<()>;
    fn LocalOffsetZ(&self) -> windows_core::Result<f64>;
    fn SetLocalOffsetZ(&self, value: f64) -> windows_core::Result<()>;
    fn RotationX(&self) -> windows_core::Result<f64>;
    fn SetRotationX(&self, value: f64) -> windows_core::Result<()>;
    fn RotationY(&self) -> windows_core::Result<f64>;
    fn SetRotationY(&self, value: f64) -> windows_core::Result<()>;
    fn RotationZ(&self) -> windows_core::Result<f64>;
    fn SetRotationZ(&self, value: f64) -> windows_core::Result<()>;
    fn CenterOfRotationX(&self) -> windows_core::Result<f64>;
    fn SetCenterOfRotationX(&self, value: f64) -> windows_core::Result<()>;
    fn CenterOfRotationY(&self) -> windows_core::Result<f64>;
    fn SetCenterOfRotationY(&self, value: f64) -> windows_core::Result<()>;
    fn CenterOfRotationZ(&self) -> windows_core::Result<f64>;
    fn SetCenterOfRotationZ(&self, value: f64) -> windows_core::Result<()>;
    fn GlobalOffsetX(&self) -> windows_core::Result<f64>;
    fn SetGlobalOffsetX(&self, value: f64) -> windows_core::Result<()>;
    fn GlobalOffsetY(&self) -> windows_core::Result<f64>;
    fn SetGlobalOffsetY(&self, value: f64) -> windows_core::Result<()>;
    fn GlobalOffsetZ(&self) -> windows_core::Result<f64>;
    fn SetGlobalOffsetZ(&self, value: f64) -> windows_core::Result<()>;
    fn ProjectionMatrix(&self) -> windows_core::Result<Media3D::Matrix3D>;
}
#[cfg(feature = "UI_Xaml_Media_Media3D")]
impl IPlaneProjection_Vtbl {
    pub const fn new<Identity: IPlaneProjection_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn LocalOffsetX<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::LocalOffsetX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetLocalOffsetX<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetLocalOffsetX(this, value).into()
            }
        }
        unsafe extern "system" fn LocalOffsetY<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::LocalOffsetY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetLocalOffsetY<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetLocalOffsetY(this, value).into()
            }
        }
        unsafe extern "system" fn LocalOffsetZ<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::LocalOffsetZ(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetLocalOffsetZ<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetLocalOffsetZ(this, value).into()
            }
        }
        unsafe extern "system" fn RotationX<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::RotationX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRotationX<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetRotationX(this, value).into()
            }
        }
        unsafe extern "system" fn RotationY<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::RotationY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRotationY<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetRotationY(this, value).into()
            }
        }
        unsafe extern "system" fn RotationZ<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::RotationZ(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRotationZ<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetRotationZ(this, value).into()
            }
        }
        unsafe extern "system" fn CenterOfRotationX<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::CenterOfRotationX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenterOfRotationX<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetCenterOfRotationX(this, value).into()
            }
        }
        unsafe extern "system" fn CenterOfRotationY<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::CenterOfRotationY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenterOfRotationY<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetCenterOfRotationY(this, value).into()
            }
        }
        unsafe extern "system" fn CenterOfRotationZ<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::CenterOfRotationZ(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenterOfRotationZ<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetCenterOfRotationZ(this, value).into()
            }
        }
        unsafe extern "system" fn GlobalOffsetX<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::GlobalOffsetX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetGlobalOffsetX<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetGlobalOffsetX(this, value).into()
            }
        }
        unsafe extern "system" fn GlobalOffsetY<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::GlobalOffsetY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetGlobalOffsetY<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetGlobalOffsetY(this, value).into()
            }
        }
        unsafe extern "system" fn GlobalOffsetZ<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::GlobalOffsetZ(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetGlobalOffsetZ<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPlaneProjection_Impl::SetGlobalOffsetZ(this, value).into()
            }
        }
        unsafe extern "system" fn ProjectionMatrix<
            Identity: IPlaneProjection_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut Media3D::Matrix3D,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjection_Impl::ProjectionMatrix(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IPlaneProjection, OFFSET>(),
            LocalOffsetX: LocalOffsetX::<Identity, OFFSET>,
            SetLocalOffsetX: SetLocalOffsetX::<Identity, OFFSET>,
            LocalOffsetY: LocalOffsetY::<Identity, OFFSET>,
            SetLocalOffsetY: SetLocalOffsetY::<Identity, OFFSET>,
            LocalOffsetZ: LocalOffsetZ::<Identity, OFFSET>,
            SetLocalOffsetZ: SetLocalOffsetZ::<Identity, OFFSET>,
            RotationX: RotationX::<Identity, OFFSET>,
            SetRotationX: SetRotationX::<Identity, OFFSET>,
            RotationY: RotationY::<Identity, OFFSET>,
            SetRotationY: SetRotationY::<Identity, OFFSET>,
            RotationZ: RotationZ::<Identity, OFFSET>,
            SetRotationZ: SetRotationZ::<Identity, OFFSET>,
            CenterOfRotationX: CenterOfRotationX::<Identity, OFFSET>,
            SetCenterOfRotationX: SetCenterOfRotationX::<Identity, OFFSET>,
            CenterOfRotationY: CenterOfRotationY::<Identity, OFFSET>,
            SetCenterOfRotationY: SetCenterOfRotationY::<Identity, OFFSET>,
            CenterOfRotationZ: CenterOfRotationZ::<Identity, OFFSET>,
            SetCenterOfRotationZ: SetCenterOfRotationZ::<Identity, OFFSET>,
            GlobalOffsetX: GlobalOffsetX::<Identity, OFFSET>,
            SetGlobalOffsetX: SetGlobalOffsetX::<Identity, OFFSET>,
            GlobalOffsetY: GlobalOffsetY::<Identity, OFFSET>,
            SetGlobalOffsetY: SetGlobalOffsetY::<Identity, OFFSET>,
            GlobalOffsetZ: GlobalOffsetZ::<Identity, OFFSET>,
            SetGlobalOffsetZ: SetGlobalOffsetZ::<Identity, OFFSET>,
            ProjectionMatrix: ProjectionMatrix::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPlaneProjection as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPlaneProjection_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub LocalOffsetX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetLocalOffsetX:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub LocalOffsetY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetLocalOffsetY:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub LocalOffsetZ:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetLocalOffsetZ:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub RotationX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetRotationX:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub RotationY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetRotationY:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub RotationZ:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetRotationZ:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub CenterOfRotationX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCenterOfRotationX:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub CenterOfRotationY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCenterOfRotationY:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub CenterOfRotationZ:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCenterOfRotationZ:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub GlobalOffsetX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetGlobalOffsetX:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub GlobalOffsetY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetGlobalOffsetY:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub GlobalOffsetZ:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetGlobalOffsetZ:
        unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    #[cfg(feature = "UI_Xaml_Media_Media3D")]
    pub ProjectionMatrix: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut Media3D::Matrix3D,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Xaml_Media_Media3D"))]
    ProjectionMatrix: usize,
}
windows_core::imp::define_interface!(
    IPlaneProjectionStatics,
    IPlaneProjectionStatics_Vtbl,
    0x96d86c18_90dd_564a_828a_8735e4219b1d
);
impl windows_core::RuntimeType for IPlaneProjectionStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPlaneProjectionStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPlaneProjectionStatics";
}
pub trait IPlaneProjectionStatics_Impl: windows_core::IUnknownImpl {
    fn LocalOffsetXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn LocalOffsetYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn LocalOffsetZProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn RotationXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn RotationYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn RotationZProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn CenterOfRotationXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn CenterOfRotationYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn CenterOfRotationZProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn GlobalOffsetXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn GlobalOffsetYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn GlobalOffsetZProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn ProjectionMatrixProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IPlaneProjectionStatics_Vtbl {
    pub const fn new<Identity: IPlaneProjectionStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn LocalOffsetXProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::LocalOffsetXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn LocalOffsetYProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::LocalOffsetYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn LocalOffsetZProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::LocalOffsetZProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RotationXProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::RotationXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RotationYProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::RotationYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RotationZProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::RotationZProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CenterOfRotationXProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::CenterOfRotationXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CenterOfRotationYProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::CenterOfRotationYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CenterOfRotationZProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::CenterOfRotationZProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GlobalOffsetXProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::GlobalOffsetXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GlobalOffsetYProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::GlobalOffsetYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GlobalOffsetZProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::GlobalOffsetZProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ProjectionMatrixProperty<
            Identity: IPlaneProjectionStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPlaneProjectionStatics_Impl::ProjectionMatrixProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IPlaneProjectionStatics, OFFSET>(
            ),
            LocalOffsetXProperty: LocalOffsetXProperty::<Identity, OFFSET>,
            LocalOffsetYProperty: LocalOffsetYProperty::<Identity, OFFSET>,
            LocalOffsetZProperty: LocalOffsetZProperty::<Identity, OFFSET>,
            RotationXProperty: RotationXProperty::<Identity, OFFSET>,
            RotationYProperty: RotationYProperty::<Identity, OFFSET>,
            RotationZProperty: RotationZProperty::<Identity, OFFSET>,
            CenterOfRotationXProperty: CenterOfRotationXProperty::<Identity, OFFSET>,
            CenterOfRotationYProperty: CenterOfRotationYProperty::<Identity, OFFSET>,
            CenterOfRotationZProperty: CenterOfRotationZProperty::<Identity, OFFSET>,
            GlobalOffsetXProperty: GlobalOffsetXProperty::<Identity, OFFSET>,
            GlobalOffsetYProperty: GlobalOffsetYProperty::<Identity, OFFSET>,
            GlobalOffsetZProperty: GlobalOffsetZProperty::<Identity, OFFSET>,
            ProjectionMatrixProperty: ProjectionMatrixProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPlaneProjectionStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPlaneProjectionStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub LocalOffsetXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub LocalOffsetYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub LocalOffsetZProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub RotationXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub RotationYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub RotationZProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub CenterOfRotationXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub CenterOfRotationYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub CenterOfRotationZProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub GlobalOffsetXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub GlobalOffsetYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub GlobalOffsetZProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub ProjectionMatrixProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IPolyBezierSegment,
    IPolyBezierSegment_Vtbl,
    0xd7f760a0_b93a_562a_8118_6330ed22c307
);
impl windows_core::RuntimeType for IPolyBezierSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPolyBezierSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPolyBezierSegment";
}
pub trait IPolyBezierSegment_Impl: windows_core::IUnknownImpl {
    fn Points(&self) -> windows_core::Result<PointCollection>;
    fn SetPoints(&self, value: windows_core::Ref<'_, PointCollection>) -> windows_core::Result<()>;
}
impl IPolyBezierSegment_Vtbl {
    pub const fn new<Identity: IPolyBezierSegment_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Points<Identity: IPolyBezierSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPolyBezierSegment_Impl::Points(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPoints<
            Identity: IPolyBezierSegment_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPolyBezierSegment_Impl::SetPoints(this, core::mem::transmute_copy(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IPolyBezierSegment, OFFSET>(),
            Points: Points::<Identity, OFFSET>,
            SetPoints: SetPoints::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPolyBezierSegment as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPolyBezierSegment_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Points: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetPoints: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IPolyBezierSegmentStatics,
    IPolyBezierSegmentStatics_Vtbl,
    0x738ef089_a80f_53e0_816f_f787a4461907
);
impl windows_core::RuntimeType for IPolyBezierSegmentStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPolyBezierSegmentStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPolyBezierSegmentStatics";
}
pub trait IPolyBezierSegmentStatics_Impl: windows_core::IUnknownImpl {
    fn PointsProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IPolyBezierSegmentStatics_Vtbl {
    pub const fn new<Identity: IPolyBezierSegmentStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn PointsProperty<
            Identity: IPolyBezierSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPolyBezierSegmentStatics_Impl::PointsProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IPolyBezierSegmentStatics,
                OFFSET,
            >(),
            PointsProperty: PointsProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPolyBezierSegmentStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPolyBezierSegmentStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub PointsProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IPolyLineSegment,
    IPolyLineSegment_Vtbl,
    0x426ef287_0287_536f_ad9e_6a05ecbb323a
);
impl windows_core::RuntimeType for IPolyLineSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPolyLineSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPolyLineSegment";
}
pub trait IPolyLineSegment_Impl: windows_core::IUnknownImpl {
    fn Points(&self) -> windows_core::Result<PointCollection>;
    fn SetPoints(&self, value: windows_core::Ref<'_, PointCollection>) -> windows_core::Result<()>;
}
impl IPolyLineSegment_Vtbl {
    pub const fn new<Identity: IPolyLineSegment_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Points<Identity: IPolyLineSegment_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPolyLineSegment_Impl::Points(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPoints<
            Identity: IPolyLineSegment_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPolyLineSegment_Impl::SetPoints(this, core::mem::transmute_copy(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IPolyLineSegment, OFFSET>(),
            Points: Points::<Identity, OFFSET>,
            SetPoints: SetPoints::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPolyLineSegment as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPolyLineSegment_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Points: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetPoints: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IPolyLineSegmentStatics,
    IPolyLineSegmentStatics_Vtbl,
    0xcf54e568_101a_5349_9189_6f9a1e7f5280
);
impl windows_core::RuntimeType for IPolyLineSegmentStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPolyLineSegmentStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPolyLineSegmentStatics";
}
pub trait IPolyLineSegmentStatics_Impl: windows_core::IUnknownImpl {
    fn PointsProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IPolyLineSegmentStatics_Vtbl {
    pub const fn new<Identity: IPolyLineSegmentStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn PointsProperty<
            Identity: IPolyLineSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPolyLineSegmentStatics_Impl::PointsProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IPolyLineSegmentStatics, OFFSET>(
            ),
            PointsProperty: PointsProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPolyLineSegmentStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPolyLineSegmentStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub PointsProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IPolyQuadraticBezierSegment,
    IPolyQuadraticBezierSegment_Vtbl,
    0x56372f4c_c531_5c3e_b0e0_1645f5a8d872
);
impl windows_core::RuntimeType for IPolyQuadraticBezierSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPolyQuadraticBezierSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPolyQuadraticBezierSegment";
}
pub trait IPolyQuadraticBezierSegment_Impl: windows_core::IUnknownImpl {
    fn Points(&self) -> windows_core::Result<PointCollection>;
    fn SetPoints(&self, value: windows_core::Ref<'_, PointCollection>) -> windows_core::Result<()>;
}
impl IPolyQuadraticBezierSegment_Vtbl {
    pub const fn new<Identity: IPolyQuadraticBezierSegment_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Points<
            Identity: IPolyQuadraticBezierSegment_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPolyQuadraticBezierSegment_Impl::Points(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPoints<
            Identity: IPolyQuadraticBezierSegment_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IPolyQuadraticBezierSegment_Impl::SetPoints(this, core::mem::transmute_copy(&value))
                    .into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IPolyQuadraticBezierSegment,
                OFFSET,
            >(),
            Points: Points::<Identity, OFFSET>,
            SetPoints: SetPoints::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPolyQuadraticBezierSegment as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPolyQuadraticBezierSegment_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Points: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetPoints: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IPolyQuadraticBezierSegmentStatics,
    IPolyQuadraticBezierSegmentStatics_Vtbl,
    0x7eb6374d_cd30_5507_b2ab_c4e3a7dc60bf
);
impl windows_core::RuntimeType for IPolyQuadraticBezierSegmentStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IPolyQuadraticBezierSegmentStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IPolyQuadraticBezierSegmentStatics";
}
pub trait IPolyQuadraticBezierSegmentStatics_Impl: windows_core::IUnknownImpl {
    fn PointsProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IPolyQuadraticBezierSegmentStatics_Vtbl {
    pub const fn new<Identity: IPolyQuadraticBezierSegmentStatics_Impl, const OFFSET: isize>(
    ) -> Self {
        unsafe extern "system" fn PointsProperty<
            Identity: IPolyQuadraticBezierSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IPolyQuadraticBezierSegmentStatics_Impl::PointsProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IPolyQuadraticBezierSegmentStatics,
                OFFSET,
            >(),
            PointsProperty: PointsProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPolyQuadraticBezierSegmentStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IPolyQuadraticBezierSegmentStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub PointsProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IProjection,
    IProjection_Vtbl,
    0xc95364b3_6058_5ee5_9e28_d38b7679fcd4
);
impl windows_core::RuntimeType for IProjection {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IProjection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IProjection";
}
pub trait IProjection_Impl: windows_core::IUnknownImpl {}
impl IProjection_Vtbl {
    pub const fn new<Identity: IProjection_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IProjection, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IProjection as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IProjection_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    IProjectionFactory,
    IProjectionFactory_Vtbl,
    0x870ea34f_db61_5b75_89ad_e0480c802937
);
impl windows_core::RuntimeType for IProjectionFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IProjectionFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IProjectionFactory";
}
pub trait IProjectionFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<Projection>;
}
impl IProjectionFactory_Vtbl {
    pub const fn new<Identity: IProjectionFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: IProjectionFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IProjectionFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IProjectionFactory, OFFSET>(),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IProjectionFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IProjectionFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IQuadraticBezierSegment,
    IQuadraticBezierSegment_Vtbl,
    0x6048abe4_7a12_5195_bd61_71dfd0361c38
);
impl windows_core::RuntimeType for IQuadraticBezierSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IQuadraticBezierSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IQuadraticBezierSegment";
}
pub trait IQuadraticBezierSegment_Impl: windows_core::IUnknownImpl {
    fn Point1(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetPoint1(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
    fn Point2(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetPoint2(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
}
impl IQuadraticBezierSegment_Vtbl {
    pub const fn new<Identity: IQuadraticBezierSegment_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Point1<
            Identity: IQuadraticBezierSegment_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IQuadraticBezierSegment_Impl::Point1(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPoint1<
            Identity: IQuadraticBezierSegment_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IQuadraticBezierSegment_Impl::SetPoint1(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn Point2<
            Identity: IQuadraticBezierSegment_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IQuadraticBezierSegment_Impl::Point2(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetPoint2<
            Identity: IQuadraticBezierSegment_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IQuadraticBezierSegment_Impl::SetPoint2(this, core::mem::transmute(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IQuadraticBezierSegment, OFFSET>(
            ),
            Point1: Point1::<Identity, OFFSET>,
            SetPoint1: SetPoint1::<Identity, OFFSET>,
            Point2: Point2::<Identity, OFFSET>,
            SetPoint2: SetPoint2::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IQuadraticBezierSegment as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IQuadraticBezierSegment_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Point1: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetPoint1: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub Point2: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetPoint2: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IQuadraticBezierSegmentStatics,
    IQuadraticBezierSegmentStatics_Vtbl,
    0x4d56ea65_0a1a_528a_a5b6_41da03ac71f4
);
impl windows_core::RuntimeType for IQuadraticBezierSegmentStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IQuadraticBezierSegmentStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IQuadraticBezierSegmentStatics";
}
pub trait IQuadraticBezierSegmentStatics_Impl: windows_core::IUnknownImpl {
    fn Point1Property(&self) -> windows_core::Result<super::DependencyProperty>;
    fn Point2Property(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IQuadraticBezierSegmentStatics_Vtbl {
    pub const fn new<Identity: IQuadraticBezierSegmentStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Point1Property<
            Identity: IQuadraticBezierSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IQuadraticBezierSegmentStatics_Impl::Point1Property(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn Point2Property<
            Identity: IQuadraticBezierSegmentStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IQuadraticBezierSegmentStatics_Impl::Point2Property(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IQuadraticBezierSegmentStatics,
                OFFSET,
            >(),
            Point1Property: Point1Property::<Identity, OFFSET>,
            Point2Property: Point2Property::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IQuadraticBezierSegmentStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IQuadraticBezierSegmentStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Point1Property: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub Point2Property: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IRadialGradientBrush,
    IRadialGradientBrush_Vtbl,
    0x5d493ce1_b844_546a_b772_b3bcba7e98ee
);
impl windows_core::RuntimeType for IRadialGradientBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IRadialGradientBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IRadialGradientBrush";
}
#[cfg(feature = "UI_Composition")]
pub trait IRadialGradientBrush_Impl: windows_core::IUnknownImpl {
    fn Center(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetCenter(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
    fn RadiusX(&self) -> windows_core::Result<f64>;
    fn SetRadiusX(&self, value: f64) -> windows_core::Result<()>;
    fn RadiusY(&self) -> windows_core::Result<f64>;
    fn SetRadiusY(&self, value: f64) -> windows_core::Result<()>;
    fn GradientOrigin(&self) -> windows_core::Result<windows::Foundation::Point>;
    fn SetGradientOrigin(&self, value: &windows::Foundation::Point) -> windows_core::Result<()>;
    fn MappingMode(&self) -> windows_core::Result<BrushMappingMode>;
    fn SetMappingMode(&self, value: BrushMappingMode) -> windows_core::Result<()>;
    fn InterpolationSpace(
        &self,
    ) -> windows_core::Result<super::super::Composition::CompositionColorSpace>;
    fn SetInterpolationSpace(
        &self,
        value: super::super::Composition::CompositionColorSpace,
    ) -> windows_core::Result<()>;
    fn SpreadMethod(&self) -> windows_core::Result<GradientSpreadMethod>;
    fn SetSpreadMethod(&self, value: GradientSpreadMethod) -> windows_core::Result<()>;
    fn GradientStops(
        &self,
    ) -> windows_core::Result<windows::Foundation::Collections::IObservableVector<GradientStop>>;
}
#[cfg(feature = "UI_Composition")]
impl IRadialGradientBrush_Vtbl {
    pub const fn new<Identity: IRadialGradientBrush_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Center<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrush_Impl::Center(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenter<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRadialGradientBrush_Impl::SetCenter(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn RadiusX<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrush_Impl::RadiusX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRadiusX<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRadialGradientBrush_Impl::SetRadiusX(this, value).into()
            }
        }
        unsafe extern "system" fn RadiusY<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrush_Impl::RadiusY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRadiusY<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRadialGradientBrush_Impl::SetRadiusY(this, value).into()
            }
        }
        unsafe extern "system" fn GradientOrigin<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrush_Impl::GradientOrigin(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetGradientOrigin<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Point,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRadialGradientBrush_Impl::SetGradientOrigin(this, core::mem::transmute(&value))
                    .into()
            }
        }
        unsafe extern "system" fn MappingMode<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut BrushMappingMode,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrush_Impl::MappingMode(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetMappingMode<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: BrushMappingMode,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRadialGradientBrush_Impl::SetMappingMode(this, value).into()
            }
        }
        unsafe extern "system" fn InterpolationSpace<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut super::super::Composition::CompositionColorSpace,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrush_Impl::InterpolationSpace(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetInterpolationSpace<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: super::super::Composition::CompositionColorSpace,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRadialGradientBrush_Impl::SetInterpolationSpace(this, value).into()
            }
        }
        unsafe extern "system" fn SpreadMethod<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut GradientSpreadMethod,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrush_Impl::SpreadMethod(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetSpreadMethod<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: GradientSpreadMethod,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRadialGradientBrush_Impl::SetSpreadMethod(this, value).into()
            }
        }
        unsafe extern "system" fn GradientStops<
            Identity: IRadialGradientBrush_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrush_Impl::GradientStops(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IRadialGradientBrush, OFFSET>(
            ),
            Center: Center::<Identity, OFFSET>,
            SetCenter: SetCenter::<Identity, OFFSET>,
            RadiusX: RadiusX::<Identity, OFFSET>,
            SetRadiusX: SetRadiusX::<Identity, OFFSET>,
            RadiusY: RadiusY::<Identity, OFFSET>,
            SetRadiusY: SetRadiusY::<Identity, OFFSET>,
            GradientOrigin: GradientOrigin::<Identity, OFFSET>,
            SetGradientOrigin: SetGradientOrigin::<Identity, OFFSET>,
            MappingMode: MappingMode::<Identity, OFFSET>,
            SetMappingMode: SetMappingMode::<Identity, OFFSET>,
            InterpolationSpace: InterpolationSpace::<Identity, OFFSET>,
            SetInterpolationSpace: SetInterpolationSpace::<Identity, OFFSET>,
            SpreadMethod: SpreadMethod::<Identity, OFFSET>,
            SetSpreadMethod: SetSpreadMethod::<Identity, OFFSET>,
            GradientStops: GradientStops::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IRadialGradientBrush as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IRadialGradientBrush_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Center: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetCenter: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub RadiusX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetRadiusX: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub RadiusY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetRadiusY: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub GradientOrigin: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub SetGradientOrigin: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
    ) -> windows_core::HRESULT,
    pub MappingMode: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut BrushMappingMode,
    ) -> windows_core::HRESULT,
    pub SetMappingMode: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        BrushMappingMode,
    ) -> windows_core::HRESULT,
    #[cfg(feature = "UI_Composition")]
    pub InterpolationSpace: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut super::super::Composition::CompositionColorSpace,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    InterpolationSpace: usize,
    #[cfg(feature = "UI_Composition")]
    pub SetInterpolationSpace: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        super::super::Composition::CompositionColorSpace,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    SetInterpolationSpace: usize,
    pub SpreadMethod: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut GradientSpreadMethod,
    ) -> windows_core::HRESULT,
    pub SetSpreadMethod: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        GradientSpreadMethod,
    ) -> windows_core::HRESULT,
    pub GradientStops: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IRadialGradientBrushFactory,
    IRadialGradientBrushFactory_Vtbl,
    0xd90ba26e_9e67_54bd_a2d9_61c8f9f1d433
);
impl windows_core::RuntimeType for IRadialGradientBrushFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IRadialGradientBrushFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IRadialGradientBrushFactory";
}
#[cfg(feature = "UI_Composition")]
pub trait IRadialGradientBrushFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<RadialGradientBrush>;
}
#[cfg(feature = "UI_Composition")]
impl IRadialGradientBrushFactory_Vtbl {
    pub const fn new<Identity: IRadialGradientBrushFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: IRadialGradientBrushFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrushFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IRadialGradientBrushFactory,
                OFFSET,
            >(),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IRadialGradientBrushFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IRadialGradientBrushFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    CreateInstance: usize,
}
windows_core::imp::define_interface!(
    IRadialGradientBrushStatics,
    IRadialGradientBrushStatics_Vtbl,
    0xf275a0b8_66f9_5b7d_a415_7eda65fe6dd3
);
impl windows_core::RuntimeType for IRadialGradientBrushStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IRadialGradientBrushStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IRadialGradientBrushStatics";
}
pub trait IRadialGradientBrushStatics_Impl: windows_core::IUnknownImpl {
    fn CenterProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn RadiusXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn RadiusYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn GradientOriginProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn InterpolationSpaceProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn MappingModeProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn SpreadMethodProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IRadialGradientBrushStatics_Vtbl {
    pub const fn new<Identity: IRadialGradientBrushStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CenterProperty<
            Identity: IRadialGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrushStatics_Impl::CenterProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RadiusXProperty<
            Identity: IRadialGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrushStatics_Impl::RadiusXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RadiusYProperty<
            Identity: IRadialGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrushStatics_Impl::RadiusYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GradientOriginProperty<
            Identity: IRadialGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrushStatics_Impl::GradientOriginProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn InterpolationSpaceProperty<
            Identity: IRadialGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrushStatics_Impl::InterpolationSpaceProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn MappingModeProperty<
            Identity: IRadialGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrushStatics_Impl::MappingModeProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SpreadMethodProperty<
            Identity: IRadialGradientBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRadialGradientBrushStatics_Impl::SpreadMethodProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IRadialGradientBrushStatics,
                OFFSET,
            >(),
            CenterProperty: CenterProperty::<Identity, OFFSET>,
            RadiusXProperty: RadiusXProperty::<Identity, OFFSET>,
            RadiusYProperty: RadiusYProperty::<Identity, OFFSET>,
            GradientOriginProperty: GradientOriginProperty::<Identity, OFFSET>,
            InterpolationSpaceProperty: InterpolationSpaceProperty::<Identity, OFFSET>,
            MappingModeProperty: MappingModeProperty::<Identity, OFFSET>,
            SpreadMethodProperty: SpreadMethodProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IRadialGradientBrushStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IRadialGradientBrushStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CenterProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub RadiusXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub RadiusYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub GradientOriginProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub InterpolationSpaceProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub MappingModeProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SpreadMethodProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IRectangleGeometry,
    IRectangleGeometry_Vtbl,
    0xb6143890_a5f5_54e0_ab42_d88bab451f04
);
impl windows_core::RuntimeType for IRectangleGeometry {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IRectangleGeometry {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IRectangleGeometry";
}
pub trait IRectangleGeometry_Impl: windows_core::IUnknownImpl {
    fn Rect(&self) -> windows_core::Result<windows::Foundation::Rect>;
    fn SetRect(&self, value: &windows::Foundation::Rect) -> windows_core::Result<()>;
}
impl IRectangleGeometry_Vtbl {
    pub const fn new<Identity: IRectangleGeometry_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Rect<Identity: IRectangleGeometry_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::Rect,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRectangleGeometry_Impl::Rect(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetRect<
            Identity: IRectangleGeometry_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::Rect,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRectangleGeometry_Impl::SetRect(this, core::mem::transmute(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IRectangleGeometry, OFFSET>(),
            Rect: Rect::<Identity, OFFSET>,
            SetRect: SetRect::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IRectangleGeometry as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IRectangleGeometry_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Rect: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::Rect,
    ) -> windows_core::HRESULT,
    pub SetRect: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Rect,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IRectangleGeometryStatics,
    IRectangleGeometryStatics_Vtbl,
    0x1ae7ac26_8a8b_55a5_b035_586e2b642919
);
impl windows_core::RuntimeType for IRectangleGeometryStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IRectangleGeometryStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IRectangleGeometryStatics";
}
pub trait IRectangleGeometryStatics_Impl: windows_core::IUnknownImpl {
    fn RectProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IRectangleGeometryStatics_Vtbl {
    pub const fn new<Identity: IRectangleGeometryStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn RectProperty<
            Identity: IRectangleGeometryStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRectangleGeometryStatics_Impl::RectProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IRectangleGeometryStatics,
                OFFSET,
            >(),
            RectProperty: RectProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IRectangleGeometryStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IRectangleGeometryStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub RectProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IRenderedEventArgs,
    IRenderedEventArgs_Vtbl,
    0xb268b885_118d_5b66_8099_3b6bb8644726
);
impl windows_core::RuntimeType for IRenderedEventArgs {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IRenderedEventArgs {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IRenderedEventArgs";
}
pub trait IRenderedEventArgs_Impl: windows_core::IUnknownImpl {
    fn FrameDuration(&self) -> windows_core::Result<windows::Foundation::TimeSpan>;
}
impl IRenderedEventArgs_Vtbl {
    pub const fn new<Identity: IRenderedEventArgs_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FrameDuration<
            Identity: IRenderedEventArgs_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::TimeSpan,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRenderedEventArgs_Impl::FrameDuration(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IRenderedEventArgs, OFFSET>(),
            FrameDuration: FrameDuration::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IRenderedEventArgs as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IRenderedEventArgs_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub FrameDuration: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::TimeSpan,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IRenderingEventArgs,
    IRenderingEventArgs_Vtbl,
    0xa67c8f8d_1885_5fc9_975c_901224f79b1e
);
impl windows_core::RuntimeType for IRenderingEventArgs {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IRenderingEventArgs {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IRenderingEventArgs";
}
pub trait IRenderingEventArgs_Impl: windows_core::IUnknownImpl {
    fn RenderingTime(&self) -> windows_core::Result<windows::Foundation::TimeSpan>;
}
impl IRenderingEventArgs_Vtbl {
    pub const fn new<Identity: IRenderingEventArgs_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn RenderingTime<
            Identity: IRenderingEventArgs_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::TimeSpan,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRenderingEventArgs_Impl::RenderingTime(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IRenderingEventArgs, OFFSET>(),
            RenderingTime: RenderingTime::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IRenderingEventArgs as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IRenderingEventArgs_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub RenderingTime: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::TimeSpan,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IRotateTransform,
    IRotateTransform_Vtbl,
    0xd4686e7c_a374_5cac_8927_0ef07c5b254d
);
impl windows_core::RuntimeType for IRotateTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IRotateTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IRotateTransform";
}
pub trait IRotateTransform_Impl: windows_core::IUnknownImpl {
    fn CenterX(&self) -> windows_core::Result<f64>;
    fn SetCenterX(&self, value: f64) -> windows_core::Result<()>;
    fn CenterY(&self) -> windows_core::Result<f64>;
    fn SetCenterY(&self, value: f64) -> windows_core::Result<()>;
    fn Angle(&self) -> windows_core::Result<f64>;
    fn SetAngle(&self, value: f64) -> windows_core::Result<()>;
}
impl IRotateTransform_Vtbl {
    pub const fn new<Identity: IRotateTransform_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CenterX<Identity: IRotateTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRotateTransform_Impl::CenterX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenterX<
            Identity: IRotateTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRotateTransform_Impl::SetCenterX(this, value).into()
            }
        }
        unsafe extern "system" fn CenterY<Identity: IRotateTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRotateTransform_Impl::CenterY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenterY<
            Identity: IRotateTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRotateTransform_Impl::SetCenterY(this, value).into()
            }
        }
        unsafe extern "system" fn Angle<Identity: IRotateTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRotateTransform_Impl::Angle(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAngle<Identity: IRotateTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IRotateTransform_Impl::SetAngle(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IRotateTransform, OFFSET>(),
            CenterX: CenterX::<Identity, OFFSET>,
            SetCenterX: SetCenterX::<Identity, OFFSET>,
            CenterY: CenterY::<Identity, OFFSET>,
            SetCenterY: SetCenterY::<Identity, OFFSET>,
            Angle: Angle::<Identity, OFFSET>,
            SetAngle: SetAngle::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IRotateTransform as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IRotateTransform_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CenterX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCenterX: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub CenterY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCenterY: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub Angle: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetAngle: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IRotateTransformStatics,
    IRotateTransformStatics_Vtbl,
    0x8ec4c662_04f8_51d7_bcb2_17f10c2faa38
);
impl windows_core::RuntimeType for IRotateTransformStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IRotateTransformStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IRotateTransformStatics";
}
pub trait IRotateTransformStatics_Impl: windows_core::IUnknownImpl {
    fn CenterXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn CenterYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn AngleProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IRotateTransformStatics_Vtbl {
    pub const fn new<Identity: IRotateTransformStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CenterXProperty<
            Identity: IRotateTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRotateTransformStatics_Impl::CenterXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CenterYProperty<
            Identity: IRotateTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRotateTransformStatics_Impl::CenterYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AngleProperty<
            Identity: IRotateTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IRotateTransformStatics_Impl::AngleProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IRotateTransformStatics, OFFSET>(
            ),
            CenterXProperty: CenterXProperty::<Identity, OFFSET>,
            CenterYProperty: CenterYProperty::<Identity, OFFSET>,
            AngleProperty: AngleProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IRotateTransformStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IRotateTransformStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CenterXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub CenterYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub AngleProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IScaleTransform,
    IScaleTransform_Vtbl,
    0x94b064a4_34f0_5ef9_8b67_444f5699f52a
);
impl windows_core::RuntimeType for IScaleTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IScaleTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IScaleTransform";
}
pub trait IScaleTransform_Impl: windows_core::IUnknownImpl {
    fn CenterX(&self) -> windows_core::Result<f64>;
    fn SetCenterX(&self, value: f64) -> windows_core::Result<()>;
    fn CenterY(&self) -> windows_core::Result<f64>;
    fn SetCenterY(&self, value: f64) -> windows_core::Result<()>;
    fn ScaleX(&self) -> windows_core::Result<f64>;
    fn SetScaleX(&self, value: f64) -> windows_core::Result<()>;
    fn ScaleY(&self) -> windows_core::Result<f64>;
    fn SetScaleY(&self, value: f64) -> windows_core::Result<()>;
}
impl IScaleTransform_Vtbl {
    pub const fn new<Identity: IScaleTransform_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CenterX<Identity: IScaleTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IScaleTransform_Impl::CenterX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenterX<
            Identity: IScaleTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IScaleTransform_Impl::SetCenterX(this, value).into()
            }
        }
        unsafe extern "system" fn CenterY<Identity: IScaleTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IScaleTransform_Impl::CenterY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenterY<
            Identity: IScaleTransform_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IScaleTransform_Impl::SetCenterY(this, value).into()
            }
        }
        unsafe extern "system" fn ScaleX<Identity: IScaleTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IScaleTransform_Impl::ScaleX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetScaleX<Identity: IScaleTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IScaleTransform_Impl::SetScaleX(this, value).into()
            }
        }
        unsafe extern "system" fn ScaleY<Identity: IScaleTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IScaleTransform_Impl::ScaleY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetScaleY<Identity: IScaleTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IScaleTransform_Impl::SetScaleY(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IScaleTransform, OFFSET>(),
            CenterX: CenterX::<Identity, OFFSET>,
            SetCenterX: SetCenterX::<Identity, OFFSET>,
            CenterY: CenterY::<Identity, OFFSET>,
            SetCenterY: SetCenterY::<Identity, OFFSET>,
            ScaleX: ScaleX::<Identity, OFFSET>,
            SetScaleX: SetScaleX::<Identity, OFFSET>,
            ScaleY: ScaleY::<Identity, OFFSET>,
            SetScaleY: SetScaleY::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IScaleTransform as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IScaleTransform_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CenterX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCenterX: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub CenterY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCenterY: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub ScaleX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetScaleX: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub ScaleY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetScaleY: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IScaleTransformStatics,
    IScaleTransformStatics_Vtbl,
    0x76485bd5_a5bf_5790_a837_8193c84df353
);
impl windows_core::RuntimeType for IScaleTransformStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IScaleTransformStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IScaleTransformStatics";
}
pub trait IScaleTransformStatics_Impl: windows_core::IUnknownImpl {
    fn CenterXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn CenterYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn ScaleXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn ScaleYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IScaleTransformStatics_Vtbl {
    pub const fn new<Identity: IScaleTransformStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CenterXProperty<
            Identity: IScaleTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IScaleTransformStatics_Impl::CenterXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CenterYProperty<
            Identity: IScaleTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IScaleTransformStatics_Impl::CenterYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ScaleXProperty<
            Identity: IScaleTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IScaleTransformStatics_Impl::ScaleXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ScaleYProperty<
            Identity: IScaleTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IScaleTransformStatics_Impl::ScaleYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IScaleTransformStatics, OFFSET>(
            ),
            CenterXProperty: CenterXProperty::<Identity, OFFSET>,
            CenterYProperty: CenterYProperty::<Identity, OFFSET>,
            ScaleXProperty: ScaleXProperty::<Identity, OFFSET>,
            ScaleYProperty: ScaleYProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IScaleTransformStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IScaleTransformStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CenterXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub CenterYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub ScaleXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub ScaleYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IShadow,
    IShadow_Vtbl,
    0xcc12fd6a_50aa_5eb3_9a0e_b938b454c439
);
impl windows_core::RuntimeType for IShadow {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IShadow {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IShadow";
}
pub trait IShadow_Impl: windows_core::IUnknownImpl {}
impl IShadow_Vtbl {
    pub const fn new<Identity: IShadow_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IShadow, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IShadow as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IShadow_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    IShadowFactory,
    IShadowFactory_Vtbl,
    0xc9115fbb_fcc3_52bf_b8ee_c348102a46e0
);
impl windows_core::RuntimeType for IShadowFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IShadowFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IShadowFactory";
}
pub trait IShadowFactory_Impl: windows_core::IUnknownImpl {}
impl IShadowFactory_Vtbl {
    pub const fn new<Identity: IShadowFactory_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IShadowFactory, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IShadowFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IShadowFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    ISkewTransform,
    ISkewTransform_Vtbl,
    0x230abaa6_a9b6_5210_873f_36bea29d7c06
);
impl windows_core::RuntimeType for ISkewTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ISkewTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ISkewTransform";
}
pub trait ISkewTransform_Impl: windows_core::IUnknownImpl {
    fn CenterX(&self) -> windows_core::Result<f64>;
    fn SetCenterX(&self, value: f64) -> windows_core::Result<()>;
    fn CenterY(&self) -> windows_core::Result<f64>;
    fn SetCenterY(&self, value: f64) -> windows_core::Result<()>;
    fn AngleX(&self) -> windows_core::Result<f64>;
    fn SetAngleX(&self, value: f64) -> windows_core::Result<()>;
    fn AngleY(&self) -> windows_core::Result<f64>;
    fn SetAngleY(&self, value: f64) -> windows_core::Result<()>;
}
impl ISkewTransform_Vtbl {
    pub const fn new<Identity: ISkewTransform_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CenterX<Identity: ISkewTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISkewTransform_Impl::CenterX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenterX<Identity: ISkewTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ISkewTransform_Impl::SetCenterX(this, value).into()
            }
        }
        unsafe extern "system" fn CenterY<Identity: ISkewTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISkewTransform_Impl::CenterY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCenterY<Identity: ISkewTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ISkewTransform_Impl::SetCenterY(this, value).into()
            }
        }
        unsafe extern "system" fn AngleX<Identity: ISkewTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISkewTransform_Impl::AngleX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAngleX<Identity: ISkewTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ISkewTransform_Impl::SetAngleX(this, value).into()
            }
        }
        unsafe extern "system" fn AngleY<Identity: ISkewTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISkewTransform_Impl::AngleY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAngleY<Identity: ISkewTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ISkewTransform_Impl::SetAngleY(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ISkewTransform, OFFSET>(),
            CenterX: CenterX::<Identity, OFFSET>,
            SetCenterX: SetCenterX::<Identity, OFFSET>,
            CenterY: CenterY::<Identity, OFFSET>,
            SetCenterY: SetCenterY::<Identity, OFFSET>,
            AngleX: AngleX::<Identity, OFFSET>,
            SetAngleX: SetAngleX::<Identity, OFFSET>,
            AngleY: AngleY::<Identity, OFFSET>,
            SetAngleY: SetAngleY::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ISkewTransform as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ISkewTransform_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CenterX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCenterX: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub CenterY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetCenterY: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub AngleX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetAngleX: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub AngleY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetAngleY: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ISkewTransformStatics,
    ISkewTransformStatics_Vtbl,
    0x93265150_53d0_52e3_88a3_3d93e2ed861a
);
impl windows_core::RuntimeType for ISkewTransformStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ISkewTransformStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ISkewTransformStatics";
}
pub trait ISkewTransformStatics_Impl: windows_core::IUnknownImpl {
    fn CenterXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn CenterYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn AngleXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn AngleYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl ISkewTransformStatics_Vtbl {
    pub const fn new<Identity: ISkewTransformStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CenterXProperty<
            Identity: ISkewTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISkewTransformStatics_Impl::CenterXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CenterYProperty<
            Identity: ISkewTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISkewTransformStatics_Impl::CenterYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AngleXProperty<
            Identity: ISkewTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISkewTransformStatics_Impl::AngleXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AngleYProperty<
            Identity: ISkewTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISkewTransformStatics_Impl::AngleYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ISkewTransformStatics, OFFSET>(
            ),
            CenterXProperty: CenterXProperty::<Identity, OFFSET>,
            CenterYProperty: CenterYProperty::<Identity, OFFSET>,
            AngleXProperty: AngleXProperty::<Identity, OFFSET>,
            AngleYProperty: AngleYProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ISkewTransformStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ISkewTransformStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CenterXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub CenterYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub AngleXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub AngleYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ISolidColorBrush,
    ISolidColorBrush_Vtbl,
    0xb3865c31_37c8_55c1_8a72_d41c67642e2a
);
impl windows_core::RuntimeType for ISolidColorBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ISolidColorBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ISolidColorBrush";
}
pub trait ISolidColorBrush_Impl: windows_core::IUnknownImpl {
    fn Color(&self) -> windows_core::Result<windows::UI::Color>;
    fn SetColor(&self, value: &windows::UI::Color) -> windows_core::Result<()>;
}
impl ISolidColorBrush_Vtbl {
    pub const fn new<Identity: ISolidColorBrush_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Color<Identity: ISolidColorBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut windows::UI::Color,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISolidColorBrush_Impl::Color(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetColor<Identity: ISolidColorBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: windows::UI::Color,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ISolidColorBrush_Impl::SetColor(this, core::mem::transmute(&value)).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ISolidColorBrush, OFFSET>(),
            Color: Color::<Identity, OFFSET>,
            SetColor: SetColor::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ISolidColorBrush as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ISolidColorBrush_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Color: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::UI::Color,
    ) -> windows_core::HRESULT,
    pub SetColor: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::UI::Color,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ISolidColorBrushFactory,
    ISolidColorBrushFactory_Vtbl,
    0x7b559384_4daa_54f4_91ef_33a23fd816ca
);
impl windows_core::RuntimeType for ISolidColorBrushFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for ISolidColorBrushFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ISolidColorBrushFactory";
}
#[cfg(feature = "UI_Composition")]
pub trait ISolidColorBrushFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstanceWithColor(
        &self,
        color: &windows::UI::Color,
    ) -> windows_core::Result<SolidColorBrush>;
}
#[cfg(feature = "UI_Composition")]
impl ISolidColorBrushFactory_Vtbl {
    pub const fn new<Identity: ISolidColorBrushFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstanceWithColor<
            Identity: ISolidColorBrushFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            color: windows::UI::Color,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISolidColorBrushFactory_Impl::CreateInstanceWithColor(
                    this,
                    core::mem::transmute(&color),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ISolidColorBrushFactory, OFFSET>(
            ),
            CreateInstanceWithColor: CreateInstanceWithColor::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ISolidColorBrushFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ISolidColorBrushFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub CreateInstanceWithColor: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::UI::Color,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    CreateInstanceWithColor: usize,
}
windows_core::imp::define_interface!(
    ISolidColorBrushStatics,
    ISolidColorBrushStatics_Vtbl,
    0x6bc16da0_c4e6_59b8_995b_b31e48424c07
);
impl windows_core::RuntimeType for ISolidColorBrushStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ISolidColorBrushStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ISolidColorBrushStatics";
}
pub trait ISolidColorBrushStatics_Impl: windows_core::IUnknownImpl {
    fn ColorProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl ISolidColorBrushStatics_Vtbl {
    pub const fn new<Identity: ISolidColorBrushStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ColorProperty<
            Identity: ISolidColorBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISolidColorBrushStatics_Impl::ColorProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ISolidColorBrushStatics, OFFSET>(
            ),
            ColorProperty: ColorProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ISolidColorBrushStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ISolidColorBrushStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub ColorProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ISystemBackdrop,
    ISystemBackdrop_Vtbl,
    0x5aeed5c4_37ac_5852_b73f_1b76ebc3205f
);
impl windows_core::RuntimeType for ISystemBackdrop {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition_SystemBackdrops")]
impl windows_core::RuntimeName for ISystemBackdrop {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ISystemBackdrop";
}
#[cfg(feature = "UI_Composition_SystemBackdrops")]
pub trait ISystemBackdrop_Impl: windows_core::IUnknownImpl {
    fn GetDefaultSystemBackdropConfiguration(
        &self,
        target: windows_core::Ref<
            '_,
            super::super::Composition::ICompositionSupportsSystemBackdrop,
        >,
        xamlRoot: windows_core::Ref<'_, super::XamlRoot>,
    ) -> windows_core::Result<super::super::Composition::SystemBackdrops::SystemBackdropConfiguration>;
}
#[cfg(feature = "UI_Composition_SystemBackdrops")]
impl ISystemBackdrop_Vtbl {
    pub const fn new<Identity: ISystemBackdrop_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetDefaultSystemBackdropConfiguration<
            Identity: ISystemBackdrop_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            target: *mut core::ffi::c_void,
            xamlroot: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISystemBackdrop_Impl::GetDefaultSystemBackdropConfiguration(
                    this,
                    core::mem::transmute_copy(&target),
                    core::mem::transmute_copy(&xamlroot),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ISystemBackdrop, OFFSET>(),
            GetDefaultSystemBackdropConfiguration: GetDefaultSystemBackdropConfiguration::<
                Identity,
                OFFSET,
            >,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ISystemBackdrop as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ISystemBackdrop_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition_SystemBackdrops")]
    pub GetDefaultSystemBackdropConfiguration: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    )
        -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition_SystemBackdrops"))]
    GetDefaultSystemBackdropConfiguration: usize,
}
windows_core::imp::define_interface!(
    ISystemBackdropFactory,
    ISystemBackdropFactory_Vtbl,
    0x1e07656b_fad2_5b29_913f_b6748bc45942
);
impl windows_core::RuntimeType for ISystemBackdropFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ISystemBackdropFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ISystemBackdropFactory";
}
pub trait ISystemBackdropFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<SystemBackdrop>;
}
impl ISystemBackdropFactory_Vtbl {
    pub const fn new<Identity: ISystemBackdropFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: ISystemBackdropFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ISystemBackdropFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ISystemBackdropFactory, OFFSET>(
            ),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ISystemBackdropFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ISystemBackdropFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ISystemBackdropOverrides,
    ISystemBackdropOverrides_Vtbl,
    0xeb1f5399_cad7_5611_b637_09d76a07e708
);
impl windows_core::RuntimeType for ISystemBackdropOverrides {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for ISystemBackdropOverrides {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ISystemBackdropOverrides";
}
#[cfg(feature = "UI_Composition")]
pub trait ISystemBackdropOverrides_Impl: windows_core::IUnknownImpl {
    fn OnTargetConnected(
        &self,
        connectedTarget: windows_core::Ref<
            '_,
            super::super::Composition::ICompositionSupportsSystemBackdrop,
        >,
        xamlRoot: windows_core::Ref<'_, super::XamlRoot>,
    ) -> windows_core::Result<()>;
    fn OnTargetDisconnected(
        &self,
        disconnectedTarget: windows_core::Ref<
            '_,
            super::super::Composition::ICompositionSupportsSystemBackdrop,
        >,
    ) -> windows_core::Result<()>;
    fn OnDefaultSystemBackdropConfigurationChanged(
        &self,
        target: windows_core::Ref<
            '_,
            super::super::Composition::ICompositionSupportsSystemBackdrop,
        >,
        xamlRoot: windows_core::Ref<'_, super::XamlRoot>,
    ) -> windows_core::Result<()>;
}
#[cfg(feature = "UI_Composition")]
impl ISystemBackdropOverrides_Vtbl {
    pub const fn new<Identity: ISystemBackdropOverrides_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn OnTargetConnected<
            Identity: ISystemBackdropOverrides_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            connectedtarget: *mut core::ffi::c_void,
            xamlroot: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ISystemBackdropOverrides_Impl::OnTargetConnected(
                    this,
                    core::mem::transmute_copy(&connectedtarget),
                    core::mem::transmute_copy(&xamlroot),
                )
                .into()
            }
        }
        unsafe extern "system" fn OnTargetDisconnected<
            Identity: ISystemBackdropOverrides_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            disconnectedtarget: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ISystemBackdropOverrides_Impl::OnTargetDisconnected(
                    this,
                    core::mem::transmute_copy(&disconnectedtarget),
                )
                .into()
            }
        }
        unsafe extern "system" fn OnDefaultSystemBackdropConfigurationChanged<
            Identity: ISystemBackdropOverrides_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            target: *mut core::ffi::c_void,
            xamlroot: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ISystemBackdropOverrides_Impl::OnDefaultSystemBackdropConfigurationChanged(
                    this,
                    core::mem::transmute_copy(&target),
                    core::mem::transmute_copy(&xamlroot),
                )
                .into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                ISystemBackdropOverrides,
                OFFSET,
            >(),
            OnTargetConnected: OnTargetConnected::<Identity, OFFSET>,
            OnTargetDisconnected: OnTargetDisconnected::<Identity, OFFSET>,
            OnDefaultSystemBackdropConfigurationChanged:
                OnDefaultSystemBackdropConfigurationChanged::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ISystemBackdropOverrides as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ISystemBackdropOverrides_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub OnTargetConnected: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    OnTargetConnected: usize,
    #[cfg(feature = "UI_Composition")]
    pub OnTargetDisconnected: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    OnTargetDisconnected: usize,
    #[cfg(feature = "UI_Composition")]
    pub OnDefaultSystemBackdropConfigurationChanged:
        unsafe extern "system" fn(
            *mut core::ffi::c_void,
            *mut core::ffi::c_void,
            *mut core::ffi::c_void,
        ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    OnDefaultSystemBackdropConfigurationChanged: usize,
}
windows_core::imp::define_interface!(
    IThemeShadow,
    IThemeShadow_Vtbl,
    0xc264208a_d1f4_58ae_8a88_fc59148bee69
);
impl windows_core::RuntimeType for IThemeShadow {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IThemeShadow {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IThemeShadow";
}
#[cfg(feature = "UI_Composition")]
pub trait IThemeShadow_Impl: windows_core::IUnknownImpl {
    fn Receivers(&self) -> windows_core::Result<super::UIElementWeakCollection>;
}
#[cfg(feature = "UI_Composition")]
impl IThemeShadow_Vtbl {
    pub const fn new<Identity: IThemeShadow_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Receivers<Identity: IThemeShadow_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IThemeShadow_Impl::Receivers(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IThemeShadow, OFFSET>(),
            Receivers: Receivers::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IThemeShadow as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IThemeShadow_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub Receivers: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    Receivers: usize,
}
windows_core::imp::define_interface!(
    IThemeShadowFactory,
    IThemeShadowFactory_Vtbl,
    0x704a9c96_76a0_569e_8ceb_34e92a23fe11
);
impl windows_core::RuntimeType for IThemeShadowFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IThemeShadowFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IThemeShadowFactory";
}
pub trait IThemeShadowFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<ThemeShadow>;
}
impl IThemeShadowFactory_Vtbl {
    pub const fn new<Identity: IThemeShadowFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: IThemeShadowFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IThemeShadowFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IThemeShadowFactory, OFFSET>(),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IThemeShadowFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IThemeShadowFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ITileBrush,
    ITileBrush_Vtbl,
    0xee46060d_cabc_505d_883c_75d2e0e45875
);
impl windows_core::RuntimeType for ITileBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ITileBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ITileBrush";
}
pub trait ITileBrush_Impl: windows_core::IUnknownImpl {
    fn AlignmentX(&self) -> windows_core::Result<AlignmentX>;
    fn SetAlignmentX(&self, value: AlignmentX) -> windows_core::Result<()>;
    fn AlignmentY(&self) -> windows_core::Result<AlignmentY>;
    fn SetAlignmentY(&self, value: AlignmentY) -> windows_core::Result<()>;
    fn Stretch(&self) -> windows_core::Result<Stretch>;
    fn SetStretch(&self, value: Stretch) -> windows_core::Result<()>;
}
impl ITileBrush_Vtbl {
    pub const fn new<Identity: ITileBrush_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AlignmentX<Identity: ITileBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut AlignmentX,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITileBrush_Impl::AlignmentX(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAlignmentX<Identity: ITileBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: AlignmentX,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ITileBrush_Impl::SetAlignmentX(this, value).into()
            }
        }
        unsafe extern "system" fn AlignmentY<Identity: ITileBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut AlignmentY,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITileBrush_Impl::AlignmentY(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetAlignmentY<Identity: ITileBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: AlignmentY,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ITileBrush_Impl::SetAlignmentY(this, value).into()
            }
        }
        unsafe extern "system" fn Stretch<Identity: ITileBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut Stretch,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITileBrush_Impl::Stretch(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetStretch<Identity: ITileBrush_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: Stretch,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ITileBrush_Impl::SetStretch(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ITileBrush, OFFSET>(),
            AlignmentX: AlignmentX::<Identity, OFFSET>,
            SetAlignmentX: SetAlignmentX::<Identity, OFFSET>,
            AlignmentY: AlignmentY::<Identity, OFFSET>,
            SetAlignmentY: SetAlignmentY::<Identity, OFFSET>,
            Stretch: Stretch::<Identity, OFFSET>,
            SetStretch: SetStretch::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITileBrush as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ITileBrush_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub AlignmentX:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut AlignmentX) -> windows_core::HRESULT,
    pub SetAlignmentX:
        unsafe extern "system" fn(*mut core::ffi::c_void, AlignmentX) -> windows_core::HRESULT,
    pub AlignmentY:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut AlignmentY) -> windows_core::HRESULT,
    pub SetAlignmentY:
        unsafe extern "system" fn(*mut core::ffi::c_void, AlignmentY) -> windows_core::HRESULT,
    pub Stretch:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut Stretch) -> windows_core::HRESULT,
    pub SetStretch:
        unsafe extern "system" fn(*mut core::ffi::c_void, Stretch) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ITileBrushFactory,
    ITileBrushFactory_Vtbl,
    0x8542e5e6_5177_506f_8a3b_aa7da651f099
);
impl windows_core::RuntimeType for ITileBrushFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for ITileBrushFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ITileBrushFactory";
}
#[cfg(feature = "UI_Composition")]
pub trait ITileBrushFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<TileBrush>;
}
#[cfg(feature = "UI_Composition")]
impl ITileBrushFactory_Vtbl {
    pub const fn new<Identity: ITileBrushFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: ITileBrushFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITileBrushFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ITileBrushFactory, OFFSET>(),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITileBrushFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ITileBrushFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    CreateInstance: usize,
}
windows_core::imp::define_interface!(
    ITileBrushStatics,
    ITileBrushStatics_Vtbl,
    0xf402197b_9047_5f8a_90bc_6f5d8c748a5f
);
impl windows_core::RuntimeType for ITileBrushStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ITileBrushStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ITileBrushStatics";
}
pub trait ITileBrushStatics_Impl: windows_core::IUnknownImpl {
    fn AlignmentXProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn AlignmentYProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn StretchProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl ITileBrushStatics_Vtbl {
    pub const fn new<Identity: ITileBrushStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AlignmentXProperty<
            Identity: ITileBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITileBrushStatics_Impl::AlignmentXProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn AlignmentYProperty<
            Identity: ITileBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITileBrushStatics_Impl::AlignmentYProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn StretchProperty<
            Identity: ITileBrushStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITileBrushStatics_Impl::StretchProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ITileBrushStatics, OFFSET>(),
            AlignmentXProperty: AlignmentXProperty::<Identity, OFFSET>,
            AlignmentYProperty: AlignmentYProperty::<Identity, OFFSET>,
            StretchProperty: StretchProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITileBrushStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ITileBrushStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub AlignmentXProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub AlignmentYProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub StretchProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ITransform,
    ITransform_Vtbl,
    0x92a8dee5_1413_56b9_8cca_3c46918fde1b
);
impl windows_core::RuntimeType for ITransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ITransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ITransform";
}
pub trait ITransform_Impl: windows_core::IUnknownImpl {}
impl ITransform_Vtbl {
    pub const fn new<Identity: ITransform_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ITransform, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITransform as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ITransform_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    ITransformFactory,
    ITransformFactory_Vtbl,
    0x7da293f9_b82e_5d15_b623_c08210cbb640
);
impl windows_core::RuntimeType for ITransformFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ITransformFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ITransformFactory";
}
pub trait ITransformFactory_Impl: windows_core::IUnknownImpl {}
impl ITransformFactory_Vtbl {
    pub const fn new<Identity: ITransformFactory_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ITransformFactory, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITransformFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ITransformFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    ITransformGroup,
    ITransformGroup_Vtbl,
    0x17c55f3b_899c_588f_8bd4_40fa3a5fcb04
);
impl windows_core::RuntimeType for ITransformGroup {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ITransformGroup {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ITransformGroup";
}
pub trait ITransformGroup_Impl: windows_core::IUnknownImpl {
    fn Children(&self) -> windows_core::Result<TransformCollection>;
    fn SetChildren(
        &self,
        value: windows_core::Ref<'_, TransformCollection>,
    ) -> windows_core::Result<()>;
    fn Value(&self) -> windows_core::Result<Matrix>;
}
impl ITransformGroup_Vtbl {
    pub const fn new<Identity: ITransformGroup_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Children<Identity: ITransformGroup_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITransformGroup_Impl::Children(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetChildren<
            Identity: ITransformGroup_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ITransformGroup_Impl::SetChildren(this, core::mem::transmute_copy(&value)).into()
            }
        }
        unsafe extern "system" fn Value<Identity: ITransformGroup_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut Matrix,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITransformGroup_Impl::Value(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ITransformGroup, OFFSET>(),
            Children: Children::<Identity, OFFSET>,
            SetChildren: SetChildren::<Identity, OFFSET>,
            Value: Value::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITransformGroup as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ITransformGroup_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Children: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub SetChildren: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub Value:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut Matrix) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ITransformGroupStatics,
    ITransformGroupStatics_Vtbl,
    0x8f1508f6_7dcf_53d5_bbc0_d8fcd96d7399
);
impl windows_core::RuntimeType for ITransformGroupStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ITransformGroupStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ITransformGroupStatics";
}
pub trait ITransformGroupStatics_Impl: windows_core::IUnknownImpl {
    fn ChildrenProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl ITransformGroupStatics_Vtbl {
    pub const fn new<Identity: ITransformGroupStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ChildrenProperty<
            Identity: ITransformGroupStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITransformGroupStatics_Impl::ChildrenProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ITransformGroupStatics, OFFSET>(
            ),
            ChildrenProperty: ChildrenProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITransformGroupStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ITransformGroupStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub ChildrenProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ITranslateTransform,
    ITranslateTransform_Vtbl,
    0xcfa21ca9_b79f_5450_b459_a96c48cb2c8f
);
impl windows_core::RuntimeType for ITranslateTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ITranslateTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ITranslateTransform";
}
pub trait ITranslateTransform_Impl: windows_core::IUnknownImpl {
    fn X(&self) -> windows_core::Result<f64>;
    fn SetX(&self, value: f64) -> windows_core::Result<()>;
    fn Y(&self) -> windows_core::Result<f64>;
    fn SetY(&self, value: f64) -> windows_core::Result<()>;
}
impl ITranslateTransform_Vtbl {
    pub const fn new<Identity: ITranslateTransform_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn X<Identity: ITranslateTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITranslateTransform_Impl::X(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetX<Identity: ITranslateTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ITranslateTransform_Impl::SetX(this, value).into()
            }
        }
        unsafe extern "system" fn Y<Identity: ITranslateTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITranslateTransform_Impl::Y(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetY<Identity: ITranslateTransform_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            value: f64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                ITranslateTransform_Impl::SetY(this, value).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, ITranslateTransform, OFFSET>(),
            X: X::<Identity, OFFSET>,
            SetX: SetX::<Identity, OFFSET>,
            Y: Y::<Identity, OFFSET>,
            SetY: SetY::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITranslateTransform as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ITranslateTransform_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub X: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetX: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
    pub Y: unsafe extern "system" fn(*mut core::ffi::c_void, *mut f64) -> windows_core::HRESULT,
    pub SetY: unsafe extern "system" fn(*mut core::ffi::c_void, f64) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    ITranslateTransformStatics,
    ITranslateTransformStatics_Vtbl,
    0x1342eb11_5a6e_5263_ab3e_9b672a86fc0c
);
impl windows_core::RuntimeType for ITranslateTransformStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for ITranslateTransformStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ITranslateTransformStatics";
}
pub trait ITranslateTransformStatics_Impl: windows_core::IUnknownImpl {
    fn XProperty(&self) -> windows_core::Result<super::DependencyProperty>;
    fn YProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl ITranslateTransformStatics_Vtbl {
    pub const fn new<Identity: ITranslateTransformStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn XProperty<
            Identity: ITranslateTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITranslateTransformStatics_Impl::XProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn YProperty<
            Identity: ITranslateTransformStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match ITranslateTransformStatics_Impl::YProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                ITranslateTransformStatics,
                OFFSET,
            >(),
            XProperty: XProperty::<Identity, OFFSET>,
            YProperty: YProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITranslateTransformStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ITranslateTransformStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub XProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub YProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IVisualTreeHelper,
    IVisualTreeHelper_Vtbl,
    0x5f69ac1e_6504_5e3f_a11c_87684c1db814
);
impl windows_core::RuntimeType for IVisualTreeHelper {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IVisualTreeHelper {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IVisualTreeHelper";
}
pub trait IVisualTreeHelper_Impl: windows_core::IUnknownImpl {}
impl IVisualTreeHelper_Vtbl {
    pub const fn new<Identity: IVisualTreeHelper_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IVisualTreeHelper, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVisualTreeHelper as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVisualTreeHelper_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    IVisualTreeHelperStatics,
    IVisualTreeHelperStatics_Vtbl,
    0x5aece43c_7651_5bb5_855c_2198496e455e
);
impl windows_core::RuntimeType for IVisualTreeHelperStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(all(feature = "UI_Composition", feature = "UI_Xaml_Controls_Primitives"))]
impl windows_core::RuntimeName for IVisualTreeHelperStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IVisualTreeHelperStatics";
}
#[cfg(all(feature = "UI_Composition", feature = "UI_Xaml_Controls_Primitives"))]
pub trait IVisualTreeHelperStatics_Impl: windows_core::IUnknownImpl {
    fn FindElementsInHostCoordinatesPoint(
        &self,
        intersectingPoint: &windows::Foundation::Point,
        subtree: windows_core::Ref<'_, super::UIElement>,
    ) -> windows_core::Result<windows_collections::IIterable<super::UIElement>>;
    fn FindElementsInHostCoordinatesRect(
        &self,
        intersectingRect: &windows::Foundation::Rect,
        subtree: windows_core::Ref<'_, super::UIElement>,
    ) -> windows_core::Result<windows_collections::IIterable<super::UIElement>>;
    fn FindAllElementsInHostCoordinatesPoint(
        &self,
        intersectingPoint: &windows::Foundation::Point,
        subtree: windows_core::Ref<'_, super::UIElement>,
        includeAllElements: bool,
    ) -> windows_core::Result<windows_collections::IIterable<super::UIElement>>;
    fn FindAllElementsInHostCoordinatesRect(
        &self,
        intersectingRect: &windows::Foundation::Rect,
        subtree: windows_core::Ref<'_, super::UIElement>,
        includeAllElements: bool,
    ) -> windows_core::Result<windows_collections::IIterable<super::UIElement>>;
    fn GetChild(
        &self,
        reference: windows_core::Ref<'_, super::DependencyObject>,
        childIndex: i32,
    ) -> windows_core::Result<super::DependencyObject>;
    fn GetChildrenCount(
        &self,
        reference: windows_core::Ref<'_, super::DependencyObject>,
    ) -> windows_core::Result<i32>;
    fn GetParent(
        &self,
        reference: windows_core::Ref<'_, super::DependencyObject>,
    ) -> windows_core::Result<super::DependencyObject>;
    fn DisconnectChildrenRecursive(
        &self,
        element: windows_core::Ref<'_, super::UIElement>,
    ) -> windows_core::Result<()>;
    fn GetOpenPopups(
        &self,
        window: windows_core::Ref<'_, super::Window>,
    ) -> windows_core::Result<windows_collections::IVectorView<super::Controls::Primitives::Popup>>;
    fn GetOpenPopupsForXamlRoot(
        &self,
        xamlRoot: windows_core::Ref<'_, super::XamlRoot>,
    ) -> windows_core::Result<windows_collections::IVectorView<super::Controls::Primitives::Popup>>;
}
#[cfg(all(feature = "UI_Composition", feature = "UI_Xaml_Controls_Primitives"))]
impl IVisualTreeHelperStatics_Vtbl {
    pub const fn new<Identity: IVisualTreeHelperStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FindElementsInHostCoordinatesPoint<
            Identity: IVisualTreeHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            intersectingpoint: windows::Foundation::Point,
            subtree: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVisualTreeHelperStatics_Impl::FindElementsInHostCoordinatesPoint(
                    this,
                    core::mem::transmute(&intersectingpoint),
                    core::mem::transmute_copy(&subtree),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn FindElementsInHostCoordinatesRect<
            Identity: IVisualTreeHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            intersectingrect: windows::Foundation::Rect,
            subtree: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVisualTreeHelperStatics_Impl::FindElementsInHostCoordinatesRect(
                    this,
                    core::mem::transmute(&intersectingrect),
                    core::mem::transmute_copy(&subtree),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn FindAllElementsInHostCoordinatesPoint<
            Identity: IVisualTreeHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            intersectingpoint: windows::Foundation::Point,
            subtree: *mut core::ffi::c_void,
            includeallelements: bool,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVisualTreeHelperStatics_Impl::FindAllElementsInHostCoordinatesPoint(
                    this,
                    core::mem::transmute(&intersectingpoint),
                    core::mem::transmute_copy(&subtree),
                    includeallelements,
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn FindAllElementsInHostCoordinatesRect<
            Identity: IVisualTreeHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            intersectingrect: windows::Foundation::Rect,
            subtree: *mut core::ffi::c_void,
            includeallelements: bool,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVisualTreeHelperStatics_Impl::FindAllElementsInHostCoordinatesRect(
                    this,
                    core::mem::transmute(&intersectingrect),
                    core::mem::transmute_copy(&subtree),
                    includeallelements,
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetChild<
            Identity: IVisualTreeHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            reference: *mut core::ffi::c_void,
            childindex: i32,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVisualTreeHelperStatics_Impl::GetChild(
                    this,
                    core::mem::transmute_copy(&reference),
                    childindex,
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetChildrenCount<
            Identity: IVisualTreeHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            reference: *mut core::ffi::c_void,
            result__: *mut i32,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVisualTreeHelperStatics_Impl::GetChildrenCount(
                    this,
                    core::mem::transmute_copy(&reference),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetParent<
            Identity: IVisualTreeHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            reference: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVisualTreeHelperStatics_Impl::GetParent(
                    this,
                    core::mem::transmute_copy(&reference),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn DisconnectChildrenRecursive<
            Identity: IVisualTreeHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            element: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IVisualTreeHelperStatics_Impl::DisconnectChildrenRecursive(
                    this,
                    core::mem::transmute_copy(&element),
                )
                .into()
            }
        }
        unsafe extern "system" fn GetOpenPopups<
            Identity: IVisualTreeHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            window: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVisualTreeHelperStatics_Impl::GetOpenPopups(
                    this,
                    core::mem::transmute_copy(&window),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn GetOpenPopupsForXamlRoot<
            Identity: IVisualTreeHelperStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            xamlroot: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IVisualTreeHelperStatics_Impl::GetOpenPopupsForXamlRoot(
                    this,
                    core::mem::transmute_copy(&xamlroot),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IVisualTreeHelperStatics,
                OFFSET,
            >(),
            FindElementsInHostCoordinatesPoint: FindElementsInHostCoordinatesPoint::<
                Identity,
                OFFSET,
            >,
            FindElementsInHostCoordinatesRect: FindElementsInHostCoordinatesRect::<Identity, OFFSET>,
            FindAllElementsInHostCoordinatesPoint: FindAllElementsInHostCoordinatesPoint::<
                Identity,
                OFFSET,
            >,
            FindAllElementsInHostCoordinatesRect: FindAllElementsInHostCoordinatesRect::<
                Identity,
                OFFSET,
            >,
            GetChild: GetChild::<Identity, OFFSET>,
            GetChildrenCount: GetChildrenCount::<Identity, OFFSET>,
            GetParent: GetParent::<Identity, OFFSET>,
            DisconnectChildrenRecursive: DisconnectChildrenRecursive::<Identity, OFFSET>,
            GetOpenPopups: GetOpenPopups::<Identity, OFFSET>,
            GetOpenPopupsForXamlRoot: GetOpenPopupsForXamlRoot::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IVisualTreeHelperStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IVisualTreeHelperStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub FindElementsInHostCoordinatesPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    FindElementsInHostCoordinatesPoint: usize,
    #[cfg(feature = "UI_Composition")]
    pub FindElementsInHostCoordinatesRect: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Rect,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    FindElementsInHostCoordinatesRect: usize,
    #[cfg(feature = "UI_Composition")]
    pub FindAllElementsInHostCoordinatesPoint: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Point,
        *mut core::ffi::c_void,
        bool,
        *mut *mut core::ffi::c_void,
    )
        -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    FindAllElementsInHostCoordinatesPoint: usize,
    #[cfg(feature = "UI_Composition")]
    pub FindAllElementsInHostCoordinatesRect: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::Rect,
        *mut core::ffi::c_void,
        bool,
        *mut *mut core::ffi::c_void,
    )
        -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    FindAllElementsInHostCoordinatesRect: usize,
    pub GetChild: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        i32,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub GetChildrenCount: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i32,
    ) -> windows_core::HRESULT,
    pub GetParent: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(feature = "UI_Composition")]
    pub DisconnectChildrenRecursive: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    DisconnectChildrenRecursive: usize,
    #[cfg(all(feature = "UI_Composition", feature = "UI_Xaml_Controls_Primitives"))]
    pub GetOpenPopups: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "UI_Composition", feature = "UI_Xaml_Controls_Primitives")))]
    GetOpenPopups: usize,
    #[cfg(all(feature = "UI_Composition", feature = "UI_Xaml_Controls_Primitives"))]
    pub GetOpenPopupsForXamlRoot: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(all(feature = "UI_Composition", feature = "UI_Xaml_Controls_Primitives")))]
    GetOpenPopupsForXamlRoot: usize,
}
windows_core::imp::define_interface!(
    IXamlCompositionBrushBase,
    IXamlCompositionBrushBase_Vtbl,
    0xfeaead28_5cd0_5e58_bcea_8670f832aca9
);
impl windows_core::RuntimeType for IXamlCompositionBrushBase {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IXamlCompositionBrushBase {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IXamlCompositionBrushBase";
}
pub trait IXamlCompositionBrushBase_Impl: windows_core::IUnknownImpl {
    fn FallbackColor(&self) -> windows_core::Result<windows::UI::Color>;
    fn SetFallbackColor(&self, value: &windows::UI::Color) -> windows_core::Result<()>;
}
impl IXamlCompositionBrushBase_Vtbl {
    pub const fn new<Identity: IXamlCompositionBrushBase_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn FallbackColor<
            Identity: IXamlCompositionBrushBase_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::UI::Color,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IXamlCompositionBrushBase_Impl::FallbackColor(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetFallbackColor<
            Identity: IXamlCompositionBrushBase_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::UI::Color,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IXamlCompositionBrushBase_Impl::SetFallbackColor(this, core::mem::transmute(&value))
                    .into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IXamlCompositionBrushBase,
                OFFSET,
            >(),
            FallbackColor: FallbackColor::<Identity, OFFSET>,
            SetFallbackColor: SetFallbackColor::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IXamlCompositionBrushBase as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IXamlCompositionBrushBase_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub FallbackColor: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::UI::Color,
    ) -> windows_core::HRESULT,
    pub SetFallbackColor: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::UI::Color,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IXamlCompositionBrushBaseFactory,
    IXamlCompositionBrushBaseFactory_Vtbl,
    0xb1626d56_0f6f_5416_ada4_5c8105d3f082
);
impl windows_core::RuntimeType for IXamlCompositionBrushBaseFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IXamlCompositionBrushBaseFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IXamlCompositionBrushBaseFactory";
}
#[cfg(feature = "UI_Composition")]
pub trait IXamlCompositionBrushBaseFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<XamlCompositionBrushBase>;
}
#[cfg(feature = "UI_Composition")]
impl IXamlCompositionBrushBaseFactory_Vtbl {
    pub const fn new<Identity: IXamlCompositionBrushBaseFactory_Impl, const OFFSET: isize>() -> Self
    {
        unsafe extern "system" fn CreateInstance<
            Identity: IXamlCompositionBrushBaseFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IXamlCompositionBrushBaseFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IXamlCompositionBrushBaseFactory,
                OFFSET,
            >(),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IXamlCompositionBrushBaseFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IXamlCompositionBrushBaseFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    CreateInstance: usize,
}
windows_core::imp::define_interface!(
    IXamlCompositionBrushBaseOverrides,
    IXamlCompositionBrushBaseOverrides_Vtbl,
    0x8881b559_54a0_56c4_a79a_135152fb1dfa
);
impl windows_core::RuntimeType for IXamlCompositionBrushBaseOverrides {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IXamlCompositionBrushBaseOverrides {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IXamlCompositionBrushBaseOverrides";
}
pub trait IXamlCompositionBrushBaseOverrides_Impl: windows_core::IUnknownImpl {
    fn OnConnected(&self) -> windows_core::Result<()>;
    fn OnDisconnected(&self) -> windows_core::Result<()>;
}
impl IXamlCompositionBrushBaseOverrides_Vtbl {
    pub const fn new<Identity: IXamlCompositionBrushBaseOverrides_Impl, const OFFSET: isize>(
    ) -> Self {
        unsafe extern "system" fn OnConnected<
            Identity: IXamlCompositionBrushBaseOverrides_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IXamlCompositionBrushBaseOverrides_Impl::OnConnected(this).into()
            }
        }
        unsafe extern "system" fn OnDisconnected<
            Identity: IXamlCompositionBrushBaseOverrides_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IXamlCompositionBrushBaseOverrides_Impl::OnDisconnected(this).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IXamlCompositionBrushBaseOverrides,
                OFFSET,
            >(),
            OnConnected: OnConnected::<Identity, OFFSET>,
            OnDisconnected: OnDisconnected::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IXamlCompositionBrushBaseOverrides as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IXamlCompositionBrushBaseOverrides_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub OnConnected: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub OnDisconnected: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IXamlCompositionBrushBaseProtected,
    IXamlCompositionBrushBaseProtected_Vtbl,
    0x6617e1a5_e27a_5b95_b03e_6758b58f92a0
);
impl windows_core::RuntimeType for IXamlCompositionBrushBaseProtected {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IXamlCompositionBrushBaseProtected {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IXamlCompositionBrushBaseProtected";
}
#[cfg(feature = "UI_Composition")]
pub trait IXamlCompositionBrushBaseProtected_Impl: windows_core::IUnknownImpl {
    fn CompositionBrush(&self)
        -> windows_core::Result<super::super::Composition::CompositionBrush>;
    fn SetCompositionBrush(
        &self,
        value: windows_core::Ref<'_, super::super::Composition::CompositionBrush>,
    ) -> windows_core::Result<()>;
}
#[cfg(feature = "UI_Composition")]
impl IXamlCompositionBrushBaseProtected_Vtbl {
    pub const fn new<Identity: IXamlCompositionBrushBaseProtected_Impl, const OFFSET: isize>(
    ) -> Self {
        unsafe extern "system" fn CompositionBrush<
            Identity: IXamlCompositionBrushBaseProtected_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IXamlCompositionBrushBaseProtected_Impl::CompositionBrush(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCompositionBrush<
            Identity: IXamlCompositionBrushBaseProtected_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IXamlCompositionBrushBaseProtected_Impl::SetCompositionBrush(
                    this,
                    core::mem::transmute_copy(&value),
                )
                .into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IXamlCompositionBrushBaseProtected,
                OFFSET,
            >(),
            CompositionBrush: CompositionBrush::<Identity, OFFSET>,
            SetCompositionBrush: SetCompositionBrush::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IXamlCompositionBrushBaseProtected as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IXamlCompositionBrushBaseProtected_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub CompositionBrush: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    CompositionBrush: usize,
    #[cfg(feature = "UI_Composition")]
    pub SetCompositionBrush: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    SetCompositionBrush: usize,
}
windows_core::imp::define_interface!(
    IXamlCompositionBrushBaseStatics,
    IXamlCompositionBrushBaseStatics_Vtbl,
    0x3eed6e16_c386_5a1c_b70d_ef1c0015e691
);
impl windows_core::RuntimeType for IXamlCompositionBrushBaseStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IXamlCompositionBrushBaseStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IXamlCompositionBrushBaseStatics";
}
pub trait IXamlCompositionBrushBaseStatics_Impl: windows_core::IUnknownImpl {
    fn FallbackColorProperty(&self) -> windows_core::Result<super::DependencyProperty>;
}
impl IXamlCompositionBrushBaseStatics_Vtbl {
    pub const fn new<Identity: IXamlCompositionBrushBaseStatics_Impl, const OFFSET: isize>() -> Self
    {
        unsafe extern "system" fn FallbackColorProperty<
            Identity: IXamlCompositionBrushBaseStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IXamlCompositionBrushBaseStatics_Impl::FallbackColorProperty(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IXamlCompositionBrushBaseStatics,
                OFFSET,
            >(),
            FallbackColorProperty: FallbackColorProperty::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IXamlCompositionBrushBaseStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IXamlCompositionBrushBaseStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub FallbackColorProperty: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IXamlLight,
    IXamlLight_Vtbl,
    0xdcd20139_8cd5_5da5_a25c_2b7b813d8d58
);
impl windows_core::RuntimeType for IXamlLight {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IXamlLight {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IXamlLight";
}
pub trait IXamlLight_Impl: windows_core::IUnknownImpl {}
impl IXamlLight_Vtbl {
    pub const fn new<Identity: IXamlLight_Impl, const OFFSET: isize>() -> Self {
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IXamlLight, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IXamlLight as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IXamlLight_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
}
windows_core::imp::define_interface!(
    IXamlLightFactory,
    IXamlLightFactory_Vtbl,
    0x76da6306_96fc_553e_bb39_9a4801d06f48
);
impl windows_core::RuntimeType for IXamlLightFactory {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IXamlLightFactory {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IXamlLightFactory";
}
pub trait IXamlLightFactory_Impl: windows_core::IUnknownImpl {
    fn CreateInstance(
        &self,
        baseInterface: windows_core::Ref<'_, windows_core::IInspectable>,
        innerInterface: windows_core::OutRef<'_, windows_core::IInspectable>,
    ) -> windows_core::Result<XamlLight>;
}
impl IXamlLightFactory_Vtbl {
    pub const fn new<Identity: IXamlLightFactory_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateInstance<
            Identity: IXamlLightFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            baseinterface: *mut core::ffi::c_void,
            innerinterface: *mut *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IXamlLightFactory_Impl::CreateInstance(
                    this,
                    core::mem::transmute_copy(&baseinterface),
                    core::mem::transmute_copy(&innerinterface),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IXamlLightFactory, OFFSET>(),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IXamlLightFactory as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IXamlLightFactory_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IXamlLightOverrides,
    IXamlLightOverrides_Vtbl,
    0x696d4f30_92ee_540d_ad70_33d4489514d0
);
impl windows_core::RuntimeType for IXamlLightOverrides {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IXamlLightOverrides {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IXamlLightOverrides";
}
#[cfg(feature = "UI_Composition")]
pub trait IXamlLightOverrides_Impl: windows_core::IUnknownImpl {
    fn GetId(&self) -> windows_core::Result<windows_core::HSTRING>;
    fn OnConnected(
        &self,
        newElement: windows_core::Ref<'_, super::UIElement>,
    ) -> windows_core::Result<()>;
    fn OnDisconnected(
        &self,
        oldElement: windows_core::Ref<'_, super::UIElement>,
    ) -> windows_core::Result<()>;
}
#[cfg(feature = "UI_Composition")]
impl IXamlLightOverrides_Vtbl {
    pub const fn new<Identity: IXamlLightOverrides_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetId<Identity: IXamlLightOverrides_Impl, const OFFSET: isize>(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IXamlLightOverrides_Impl::GetId(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn OnConnected<
            Identity: IXamlLightOverrides_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            newelement: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IXamlLightOverrides_Impl::OnConnected(this, core::mem::transmute_copy(&newelement))
                    .into()
            }
        }
        unsafe extern "system" fn OnDisconnected<
            Identity: IXamlLightOverrides_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            oldelement: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IXamlLightOverrides_Impl::OnDisconnected(
                    this,
                    core::mem::transmute_copy(&oldelement),
                )
                .into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IXamlLightOverrides, OFFSET>(),
            GetId: GetId::<Identity, OFFSET>,
            OnConnected: OnConnected::<Identity, OFFSET>,
            OnDisconnected: OnDisconnected::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IXamlLightOverrides as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IXamlLightOverrides_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub GetId: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(feature = "UI_Composition")]
    pub OnConnected: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    OnConnected: usize,
    #[cfg(feature = "UI_Composition")]
    pub OnDisconnected: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    OnDisconnected: usize,
}
windows_core::imp::define_interface!(
    IXamlLightProtected,
    IXamlLightProtected_Vtbl,
    0xc307bf12_fdaf_54ca_a631_ad0e86263c6e
);
impl windows_core::RuntimeType for IXamlLightProtected {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IXamlLightProtected {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IXamlLightProtected";
}
#[cfg(feature = "UI_Composition")]
pub trait IXamlLightProtected_Impl: windows_core::IUnknownImpl {
    fn CompositionLight(&self)
        -> windows_core::Result<super::super::Composition::CompositionLight>;
    fn SetCompositionLight(
        &self,
        value: windows_core::Ref<'_, super::super::Composition::CompositionLight>,
    ) -> windows_core::Result<()>;
}
#[cfg(feature = "UI_Composition")]
impl IXamlLightProtected_Vtbl {
    pub const fn new<Identity: IXamlLightProtected_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CompositionLight<
            Identity: IXamlLightProtected_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IXamlLightProtected_Impl::CompositionLight(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetCompositionLight<
            Identity: IXamlLightProtected_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IXamlLightProtected_Impl::SetCompositionLight(
                    this,
                    core::mem::transmute_copy(&value),
                )
                .into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IXamlLightProtected, OFFSET>(),
            CompositionLight: CompositionLight::<Identity, OFFSET>,
            SetCompositionLight: SetCompositionLight::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IXamlLightProtected as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IXamlLightProtected_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub CompositionLight: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    CompositionLight: usize,
    #[cfg(feature = "UI_Composition")]
    pub SetCompositionLight: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    SetCompositionLight: usize,
}
windows_core::imp::define_interface!(
    IXamlLightStatics,
    IXamlLightStatics_Vtbl,
    0xa2d8ea26_26ff_5374_b1dd_f232d5604f6a
);
impl windows_core::RuntimeType for IXamlLightStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for IXamlLightStatics {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.IXamlLightStatics";
}
#[cfg(feature = "UI_Composition")]
pub trait IXamlLightStatics_Impl: windows_core::IUnknownImpl {
    fn AddTargetElement(
        &self,
        lightId: &windows_core::HSTRING,
        element: windows_core::Ref<'_, super::UIElement>,
    ) -> windows_core::Result<()>;
    fn RemoveTargetElement(
        &self,
        lightId: &windows_core::HSTRING,
        element: windows_core::Ref<'_, super::UIElement>,
    ) -> windows_core::Result<()>;
    fn AddTargetBrush(
        &self,
        lightId: &windows_core::HSTRING,
        brush: windows_core::Ref<'_, Brush>,
    ) -> windows_core::Result<()>;
    fn RemoveTargetBrush(
        &self,
        lightId: &windows_core::HSTRING,
        brush: windows_core::Ref<'_, Brush>,
    ) -> windows_core::Result<()>;
}
#[cfg(feature = "UI_Composition")]
impl IXamlLightStatics_Vtbl {
    pub const fn new<Identity: IXamlLightStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn AddTargetElement<
            Identity: IXamlLightStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            lightid: *mut core::ffi::c_void,
            element: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IXamlLightStatics_Impl::AddTargetElement(
                    this,
                    core::mem::transmute(&lightid),
                    core::mem::transmute_copy(&element),
                )
                .into()
            }
        }
        unsafe extern "system" fn RemoveTargetElement<
            Identity: IXamlLightStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            lightid: *mut core::ffi::c_void,
            element: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IXamlLightStatics_Impl::RemoveTargetElement(
                    this,
                    core::mem::transmute(&lightid),
                    core::mem::transmute_copy(&element),
                )
                .into()
            }
        }
        unsafe extern "system" fn AddTargetBrush<
            Identity: IXamlLightStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            lightid: *mut core::ffi::c_void,
            brush: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IXamlLightStatics_Impl::AddTargetBrush(
                    this,
                    core::mem::transmute(&lightid),
                    core::mem::transmute_copy(&brush),
                )
                .into()
            }
        }
        unsafe extern "system" fn RemoveTargetBrush<
            Identity: IXamlLightStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            lightid: *mut core::ffi::c_void,
            brush: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IXamlLightStatics_Impl::RemoveTargetBrush(
                    this,
                    core::mem::transmute(&lightid),
                    core::mem::transmute_copy(&brush),
                )
                .into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IXamlLightStatics, OFFSET>(),
            AddTargetElement: AddTargetElement::<Identity, OFFSET>,
            RemoveTargetElement: RemoveTargetElement::<Identity, OFFSET>,
            AddTargetBrush: AddTargetBrush::<Identity, OFFSET>,
            RemoveTargetBrush: RemoveTargetBrush::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IXamlLightStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IXamlLightStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    #[cfg(feature = "UI_Composition")]
    pub AddTargetElement: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    AddTargetElement: usize,
    #[cfg(feature = "UI_Composition")]
    pub RemoveTargetElement: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    RemoveTargetElement: usize,
    #[cfg(feature = "UI_Composition")]
    pub AddTargetBrush: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    AddTargetBrush: usize,
    #[cfg(feature = "UI_Composition")]
    pub RemoveTargetBrush: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    #[cfg(not(feature = "UI_Composition"))]
    RemoveTargetBrush: usize,
}
#[cfg(feature = "UI_Composition")]
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ImageBrush(windows_core::IUnknown);
#[cfg(feature = "UI_Composition")]
windows_core::imp::interface_hierarchy!(
    ImageBrush,
    windows_core::IUnknown,
    windows_core::IInspectable
);
#[cfg(feature = "UI_Composition")]
windows_core::imp::required_hierarchy!(
    ImageBrush,
    super::super::Composition::IAnimationObject,
    TileBrush,
    Brush,
    super::DependencyObject
);
#[cfg(feature = "UI_Composition")]
impl ImageBrush {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            ImageBrush,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn PopulatePropertyInfo<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        propertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this =
            &windows_core::Interface::cast::<super::super::Composition::IAnimationObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfo)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                propertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn Opacity(&self) -> windows_core::Result<f64> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Opacity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetOpacity(&self, value: f64) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetOpacity)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RelativeTransform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RelativeTransform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetRelativeTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetRelativeTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn PopulatePropertyInfoOverride<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        animationpropertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this = &windows_core::Interface::cast::<IBrushOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfoOverride)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                animationpropertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn ImageSource(&self) -> windows_core::Result<ImageSource> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ImageSource)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetImageSource<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<ImageSource>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetImageSource)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ImageFailed<P0>(&self, handler: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::ExceptionRoutedEventHandler>,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ImageFailed)(
                windows_core::Interface::as_raw(this),
                handler.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveImageFailed(&self, token: i64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveImageFailed)(
                windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn ImageOpened<P0>(&self, handler: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::RoutedEventHandler>,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ImageOpened)(
                windows_core::Interface::as_raw(this),
                handler.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveImageOpened(&self, token: i64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveImageOpened)(
                windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn ImageSourceProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IImageBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ImageSourceProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn AlignmentX(&self) -> windows_core::Result<AlignmentX> {
        let this = &windows_core::Interface::cast::<ITileBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AlignmentX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAlignmentX(&self, value: AlignmentX) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<ITileBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetAlignmentX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn AlignmentY(&self) -> windows_core::Result<AlignmentY> {
        let this = &windows_core::Interface::cast::<ITileBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AlignmentY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAlignmentY(&self, value: AlignmentY) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<ITileBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetAlignmentY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Stretch(&self) -> windows_core::Result<Stretch> {
        let this = &windows_core::Interface::cast::<ITileBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Stretch)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetStretch(&self, value: Stretch) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<ITileBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetStretch)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    fn IImageBrushStatics<R, F: FnOnce(&IImageBrushStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<ImageBrush, IImageBrushStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeType for ImageBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IImageBrush>();
}
#[cfg(feature = "UI_Composition")]
unsafe impl windows_core::Interface for ImageBrush {
    type Vtable = <IImageBrush as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IImageBrush as windows_core::Interface>::IID;
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for ImageBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ImageBrush";
}
#[cfg(feature = "UI_Composition")]
unsafe impl Send for ImageBrush {}
#[cfg(feature = "UI_Composition")]
unsafe impl Sync for ImageBrush {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ImageSource(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    ImageSource,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(ImageSource, super::DependencyObject);
impl ImageSource {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
impl windows_core::RuntimeType for ImageSource {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IImageSource>();
}
unsafe impl windows_core::Interface for ImageSource {
    type Vtable = <IImageSource as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IImageSource as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for ImageSource {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ImageSource";
}
unsafe impl Send for ImageSource {}
unsafe impl Sync for ImageSource {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LineGeometry(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    LineGeometry,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(LineGeometry, Geometry, super::DependencyObject);
impl LineGeometry {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            LineGeometry,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn Bounds(&self) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Bounds)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn StartPoint(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StartPoint)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetStartPoint(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetStartPoint)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn EndPoint(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).EndPoint)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetEndPoint(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetEndPoint)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn StartPointProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ILineGeometryStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StartPointProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn EndPointProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ILineGeometryStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).EndPointProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn ILineGeometryStatics<R, F: FnOnce(&ILineGeometryStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<LineGeometry, ILineGeometryStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for LineGeometry {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ILineGeometry>();
}
unsafe impl windows_core::Interface for LineGeometry {
    type Vtable = <ILineGeometry as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ILineGeometry as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for LineGeometry {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.LineGeometry";
}
unsafe impl Send for LineGeometry {}
unsafe impl Sync for LineGeometry {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LineSegment(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    LineSegment,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(LineSegment, PathSegment, super::DependencyObject);
impl LineSegment {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            LineSegment,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Point(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetPoint(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetPoint)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn PointProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ILineSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).PointProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn ILineSegmentStatics<R, F: FnOnce(&ILineSegmentStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<LineSegment, ILineSegmentStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for LineSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ILineSegment>();
}
unsafe impl windows_core::Interface for LineSegment {
    type Vtable = <ILineSegment as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ILineSegment as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for LineSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.LineSegment";
}
unsafe impl Send for LineSegment {}
unsafe impl Sync for LineSegment {}
#[cfg(feature = "UI_Composition")]
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LinearGradientBrush(windows_core::IUnknown);
#[cfg(feature = "UI_Composition")]
windows_core::imp::interface_hierarchy!(
    LinearGradientBrush,
    windows_core::IUnknown,
    windows_core::IInspectable
);
#[cfg(feature = "UI_Composition")]
windows_core::imp::required_hierarchy!(
    LinearGradientBrush,
    super::super::Composition::IAnimationObject,
    GradientBrush,
    Brush,
    super::DependencyObject
);
#[cfg(feature = "UI_Composition")]
impl LinearGradientBrush {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            LinearGradientBrush,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn PopulatePropertyInfo<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        propertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this =
            &windows_core::Interface::cast::<super::super::Composition::IAnimationObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfo)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                propertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn Opacity(&self) -> windows_core::Result<f64> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Opacity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetOpacity(&self, value: f64) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetOpacity)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RelativeTransform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RelativeTransform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetRelativeTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetRelativeTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn PopulatePropertyInfoOverride<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        animationpropertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this = &windows_core::Interface::cast::<IBrushOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfoOverride)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                animationpropertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SpreadMethod(&self) -> windows_core::Result<GradientSpreadMethod> {
        let this = &windows_core::Interface::cast::<IGradientBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SpreadMethod)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetSpreadMethod(&self, value: GradientSpreadMethod) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IGradientBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetSpreadMethod)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn MappingMode(&self) -> windows_core::Result<BrushMappingMode> {
        let this = &windows_core::Interface::cast::<IGradientBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).MappingMode)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetMappingMode(&self, value: BrushMappingMode) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IGradientBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetMappingMode)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn ColorInterpolationMode(&self) -> windows_core::Result<ColorInterpolationMode> {
        let this = &windows_core::Interface::cast::<IGradientBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ColorInterpolationMode)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetColorInterpolationMode(
        &self,
        value: ColorInterpolationMode,
    ) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IGradientBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetColorInterpolationMode)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn GradientStops(&self) -> windows_core::Result<GradientStopCollection> {
        let this = &windows_core::Interface::cast::<IGradientBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GradientStops)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetGradientStops<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<GradientStopCollection>,
    {
        let this = &windows_core::Interface::cast::<IGradientBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetGradientStops)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn StartPoint(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StartPoint)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetStartPoint(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetStartPoint)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn EndPoint(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).EndPoint)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetEndPoint(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetEndPoint)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CreateInstanceWithGradientStopCollectionAndAngle<P0>(
        gradientstopcollection: P0,
        angle: f64,
    ) -> windows_core::Result<LinearGradientBrush>
    where
        P0: windows_core::Param<GradientStopCollection>,
    {
        Self::ILinearGradientBrushFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            ( windows_core::Interface::vtable ( this ) . CreateInstanceWithGradientStopCollectionAndAngle ) ( windows_core::Interface::as_raw ( this ) , gradientstopcollection . param ( ) . abi ( ) , angle , & mut result__ ) . and_then ( || windows_core::Type::from_abi ( result__ ) )
        })
    }
    pub fn StartPointProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ILinearGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StartPointProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn EndPointProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ILinearGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).EndPointProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn ILinearGradientBrushFactory<
        R,
        F: FnOnce(&ILinearGradientBrushFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            LinearGradientBrush,
            ILinearGradientBrushFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn ILinearGradientBrushStatics<
        R,
        F: FnOnce(&ILinearGradientBrushStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            LinearGradientBrush,
            ILinearGradientBrushStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeType for LinearGradientBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ILinearGradientBrush>();
}
#[cfg(feature = "UI_Composition")]
unsafe impl windows_core::Interface for LinearGradientBrush {
    type Vtable = <ILinearGradientBrush as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ILinearGradientBrush as windows_core::Interface>::IID;
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for LinearGradientBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.LinearGradientBrush";
}
#[cfg(feature = "UI_Composition")]
unsafe impl Send for LinearGradientBrush {}
#[cfg(feature = "UI_Composition")]
unsafe impl Sync for LinearGradientBrush {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LoadedImageSourceLoadCompletedEventArgs(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    LoadedImageSourceLoadCompletedEventArgs,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl LoadedImageSourceLoadCompletedEventArgs {
    pub fn Status(&self) -> windows_core::Result<LoadedImageSourceLoadStatus> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Status)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
}
impl windows_core::RuntimeType for LoadedImageSourceLoadCompletedEventArgs {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::for_class::<
        Self,
        ILoadedImageSourceLoadCompletedEventArgs,
    >();
}
unsafe impl windows_core::Interface for LoadedImageSourceLoadCompletedEventArgs {
    type Vtable = <ILoadedImageSourceLoadCompletedEventArgs as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID =
        <ILoadedImageSourceLoadCompletedEventArgs as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for LoadedImageSourceLoadCompletedEventArgs {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.LoadedImageSourceLoadCompletedEventArgs";
}
unsafe impl Send for LoadedImageSourceLoadCompletedEventArgs {}
unsafe impl Sync for LoadedImageSourceLoadCompletedEventArgs {}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct LoadedImageSourceLoadStatus(pub i32);
impl LoadedImageSourceLoadStatus {
    pub const Success: Self = Self(0i32);
    pub const NetworkError: Self = Self(1i32);
    pub const InvalidFormat: Self = Self(2i32);
    pub const Other: Self = Self(3i32);
}
impl windows_core::TypeKind for LoadedImageSourceLoadStatus {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for LoadedImageSourceLoadStatus {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::from_slice(
        b"enum(Microsoft.UI.Xaml.Media.LoadedImageSourceLoadStatus;i4)",
    );
}
#[cfg(feature = "UI_Composition")]
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LoadedImageSurface(windows_core::IUnknown);
#[cfg(feature = "UI_Composition")]
windows_core::imp::interface_hierarchy!(
    LoadedImageSurface,
    windows_core::IUnknown,
    windows_core::IInspectable
);
#[cfg(feature = "UI_Composition")]
windows_core::imp::required_hierarchy!(
    LoadedImageSurface,
    windows::Foundation::IClosable,
    super::super::Composition::ICompositionSurface
);
#[cfg(feature = "UI_Composition")]
impl LoadedImageSurface {
    pub fn Close(&self) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<windows::Foundation::IClosable>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).Close)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
    pub fn DecodedPhysicalSize(&self) -> windows_core::Result<windows::Foundation::Size> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DecodedPhysicalSize)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn DecodedSize(&self) -> windows_core::Result<windows::Foundation::Size> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DecodedSize)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn NaturalSize(&self) -> windows_core::Result<windows::Foundation::Size> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).NaturalSize)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn LoadCompleted<P0>(&self, handler: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<
            windows::Foundation::TypedEventHandler<
                LoadedImageSurface,
                LoadedImageSourceLoadCompletedEventArgs,
            >,
        >,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).LoadCompleted)(
                windows_core::Interface::as_raw(this),
                handler.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveLoadCompleted(&self, token: i64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveLoadCompleted)(
                windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn StartLoadFromUriWithSize<P0>(
        uri: P0,
        desiredmaxsize: windows::Foundation::Size,
    ) -> windows_core::Result<LoadedImageSurface>
    where
        P0: windows_core::Param<windows::Foundation::Uri>,
    {
        Self::ILoadedImageSurfaceStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StartLoadFromUriWithSize)(
                windows_core::Interface::as_raw(this),
                uri.param().abi(),
                desiredmaxsize,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn StartLoadFromUri<P0>(uri: P0) -> windows_core::Result<LoadedImageSurface>
    where
        P0: windows_core::Param<windows::Foundation::Uri>,
    {
        Self::ILoadedImageSurfaceStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StartLoadFromUri)(
                windows_core::Interface::as_raw(this),
                uri.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn StartLoadFromStreamWithSize<P0>(
        stream: P0,
        desiredmaxsize: windows::Foundation::Size,
    ) -> windows_core::Result<LoadedImageSurface>
    where
        P0: windows_core::Param<windows::Storage::Streams::IRandomAccessStream>,
    {
        Self::ILoadedImageSurfaceStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StartLoadFromStreamWithSize)(
                windows_core::Interface::as_raw(this),
                stream.param().abi(),
                desiredmaxsize,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn StartLoadFromStream<P0>(stream: P0) -> windows_core::Result<LoadedImageSurface>
    where
        P0: windows_core::Param<windows::Storage::Streams::IRandomAccessStream>,
    {
        Self::ILoadedImageSurfaceStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StartLoadFromStream)(
                windows_core::Interface::as_raw(this),
                stream.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn ILoadedImageSurfaceStatics<
        R,
        F: FnOnce(&ILoadedImageSurfaceStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            LoadedImageSurface,
            ILoadedImageSurfaceStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeType for LoadedImageSurface {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ILoadedImageSurface>();
}
#[cfg(feature = "UI_Composition")]
unsafe impl windows_core::Interface for LoadedImageSurface {
    type Vtable = <ILoadedImageSurface as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ILoadedImageSurface as windows_core::Interface>::IID;
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for LoadedImageSurface {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.LoadedImageSurface";
}
#[cfg(feature = "UI_Composition")]
unsafe impl Send for LoadedImageSurface {}
#[cfg(feature = "UI_Composition")]
unsafe impl Sync for LoadedImageSurface {}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct Matrix {
    pub M11: f64,
    pub M12: f64,
    pub M21: f64,
    pub M22: f64,
    pub OffsetX: f64,
    pub OffsetY: f64,
}
impl windows_core::TypeKind for Matrix {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for Matrix {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::from_slice(
        b"struct(Microsoft.UI.Xaml.Media.Matrix;f8;f8;f8;f8;f8;f8)",
    );
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Matrix3DProjection(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    Matrix3DProjection,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(Matrix3DProjection, Projection, super::DependencyObject);
impl Matrix3DProjection {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            Matrix3DProjection,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Xaml_Media_Media3D")]
    pub fn ProjectionMatrix(&self) -> windows_core::Result<Media3D::Matrix3D> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ProjectionMatrix)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    #[cfg(feature = "UI_Xaml_Media_Media3D")]
    pub fn SetProjectionMatrix(&self, value: Media3D::Matrix3D) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetProjectionMatrix)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn ProjectionMatrixProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IMatrix3DProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ProjectionMatrixProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IMatrix3DProjectionStatics<
        R,
        F: FnOnce(&IMatrix3DProjectionStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            Matrix3DProjection,
            IMatrix3DProjectionStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for Matrix3DProjection {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IMatrix3DProjection>();
}
unsafe impl windows_core::Interface for Matrix3DProjection {
    type Vtable = <IMatrix3DProjection as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IMatrix3DProjection as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for Matrix3DProjection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.Matrix3DProjection";
}
unsafe impl Send for Matrix3DProjection {}
unsafe impl Sync for Matrix3DProjection {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct MatrixHelper(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    MatrixHelper,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl MatrixHelper {
    pub fn Identity() -> windows_core::Result<Matrix> {
        Self::IMatrixHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Identity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        })
    }
    pub fn FromElements(
        m11: f64,
        m12: f64,
        m21: f64,
        m22: f64,
        offsetx: f64,
        offsety: f64,
    ) -> windows_core::Result<Matrix> {
        Self::IMatrixHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FromElements)(
                windows_core::Interface::as_raw(this),
                m11,
                m12,
                m21,
                m22,
                offsetx,
                offsety,
                &mut result__,
            )
            .map(|| result__)
        })
    }
    pub fn GetIsIdentity(target: Matrix) -> windows_core::Result<bool> {
        Self::IMatrixHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetIsIdentity)(
                windows_core::Interface::as_raw(this),
                target,
                &mut result__,
            )
            .map(|| result__)
        })
    }
    pub fn Transform(
        target: Matrix,
        point: windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point> {
        Self::IMatrixHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                target,
                point,
                &mut result__,
            )
            .map(|| result__)
        })
    }
    fn IMatrixHelperStatics<R, F: FnOnce(&IMatrixHelperStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<MatrixHelper, IMatrixHelperStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for MatrixHelper {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IMatrixHelper>();
}
unsafe impl windows_core::Interface for MatrixHelper {
    type Vtable = <IMatrixHelper as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IMatrixHelper as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for MatrixHelper {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.MatrixHelper";
}
unsafe impl Send for MatrixHelper {}
unsafe impl Sync for MatrixHelper {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct MatrixTransform(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    MatrixTransform,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(
    MatrixTransform,
    Transform,
    GeneralTransform,
    super::DependencyObject
);
impl MatrixTransform {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            MatrixTransform,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Inverse(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Inverse)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TransformPoint(
        &self,
        point: windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformPoint)(
                windows_core::Interface::as_raw(this),
                point,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TryTransform(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransform)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBounds(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBounds)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn InverseCore(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).InverseCore)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TryTransformCore(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransformCore)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBoundsCore(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBoundsCore)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn Matrix(&self) -> windows_core::Result<Matrix> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Matrix)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetMatrix(&self, value: Matrix) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetMatrix)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn MatrixProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IMatrixTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).MatrixProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IMatrixTransformStatics<
        R,
        F: FnOnce(&IMatrixTransformStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<MatrixTransform, IMatrixTransformStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for MatrixTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IMatrixTransform>();
}
unsafe impl windows_core::Interface for MatrixTransform {
    type Vtable = <IMatrixTransform as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IMatrixTransform as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for MatrixTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.MatrixTransform";
}
unsafe impl Send for MatrixTransform {}
unsafe impl Sync for MatrixTransform {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct MediaTransportControlsThumbnailRequestedEventArgs(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    MediaTransportControlsThumbnailRequestedEventArgs,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl MediaTransportControlsThumbnailRequestedEventArgs {
    pub fn SetThumbnailImage<P0>(&self, source: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<windows::Storage::Streams::IInputStream>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetThumbnailImage)(
                windows_core::Interface::as_raw(this),
                source.param().abi(),
            )
            .ok()
        }
    }
    pub fn GetDeferral(&self) -> windows_core::Result<windows::Foundation::Deferral> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetDeferral)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
impl windows_core::RuntimeType for MediaTransportControlsThumbnailRequestedEventArgs {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::for_class::<
        Self,
        IMediaTransportControlsThumbnailRequestedEventArgs,
    >();
}
unsafe impl windows_core::Interface for MediaTransportControlsThumbnailRequestedEventArgs {
    type Vtable =
        <IMediaTransportControlsThumbnailRequestedEventArgs as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID =
        <IMediaTransportControlsThumbnailRequestedEventArgs as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for MediaTransportControlsThumbnailRequestedEventArgs {
    const NAME: &'static str =
        "Microsoft.UI.Xaml.Media.MediaTransportControlsThumbnailRequestedEventArgs";
}
unsafe impl Send for MediaTransportControlsThumbnailRequestedEventArgs {}
unsafe impl Sync for MediaTransportControlsThumbnailRequestedEventArgs {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct MicaBackdrop(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    MicaBackdrop,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(MicaBackdrop, SystemBackdrop, super::DependencyObject);
impl MicaBackdrop {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Composition_SystemBackdrops")]
    pub fn Kind(
        &self,
    ) -> windows_core::Result<super::super::Composition::SystemBackdrops::MicaKind> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Kind)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    #[cfg(feature = "UI_Composition_SystemBackdrops")]
    pub fn SetKind(
        &self,
        value: super::super::Composition::SystemBackdrops::MicaKind,
    ) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetKind)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn new() -> windows_core::Result<MicaBackdrop> {
        Self::IMicaBackdropFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn KindProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IMicaBackdropStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).KindProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    #[cfg(feature = "UI_Composition_SystemBackdrops")]
    pub fn GetDefaultSystemBackdropConfiguration<P0, P1>(
        &self,
        target: P0,
        xamlroot: P1,
    ) -> windows_core::Result<super::super::Composition::SystemBackdrops::SystemBackdropConfiguration>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
        P1: windows_core::Param<super::XamlRoot>,
    {
        let this = &windows_core::Interface::cast::<ISystemBackdrop>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetDefaultSystemBackdropConfiguration)(
                windows_core::Interface::as_raw(this),
                target.param().abi(),
                xamlroot.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn OnTargetConnected<P0, P1>(
        &self,
        connectedtarget: P0,
        xamlroot: P1,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
        P1: windows_core::Param<super::XamlRoot>,
    {
        let this = &windows_core::Interface::cast::<ISystemBackdropOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnTargetConnected)(
                windows_core::Interface::as_raw(this),
                connectedtarget.param().abi(),
                xamlroot.param().abi(),
            )
            .ok()
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn OnTargetDisconnected<P0>(&self, disconnectedtarget: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
    {
        let this = &windows_core::Interface::cast::<ISystemBackdropOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnTargetDisconnected)(
                windows_core::Interface::as_raw(this),
                disconnectedtarget.param().abi(),
            )
            .ok()
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn OnDefaultSystemBackdropConfigurationChanged<P0, P1>(
        &self,
        target: P0,
        xamlroot: P1,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
        P1: windows_core::Param<super::XamlRoot>,
    {
        let this = &windows_core::Interface::cast::<ISystemBackdropOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnDefaultSystemBackdropConfigurationChanged)(
                windows_core::Interface::as_raw(this),
                target.param().abi(),
                xamlroot.param().abi(),
            )
            .ok()
        }
    }
    fn IMicaBackdropFactory<R, F: FnOnce(&IMicaBackdropFactory) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<MicaBackdrop, IMicaBackdropFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn IMicaBackdropStatics<R, F: FnOnce(&IMicaBackdropStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<MicaBackdrop, IMicaBackdropStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for MicaBackdrop {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IMicaBackdrop>();
}
unsafe impl windows_core::Interface for MicaBackdrop {
    type Vtable = <IMicaBackdrop as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IMicaBackdrop as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for MicaBackdrop {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.MicaBackdrop";
}
unsafe impl Send for MicaBackdrop {}
unsafe impl Sync for MicaBackdrop {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PathFigure(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    PathFigure,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(PathFigure, super::DependencyObject);
impl PathFigure {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            PathFigure,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Segments(&self) -> windows_core::Result<PathSegmentCollection> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Segments)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetSegments<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<PathSegmentCollection>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetSegments)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn StartPoint(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StartPoint)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetStartPoint(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetStartPoint)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn IsClosed(&self) -> windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IsClosed)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetIsClosed(&self, value: bool) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetIsClosed)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn IsFilled(&self) -> windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IsFilled)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetIsFilled(&self, value: bool) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetIsFilled)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn SegmentsProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPathFigureStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SegmentsProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn StartPointProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPathFigureStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StartPointProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn IsClosedProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPathFigureStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IsClosedProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn IsFilledProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPathFigureStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IsFilledProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IPathFigureStatics<R, F: FnOnce(&IPathFigureStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<PathFigure, IPathFigureStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for PathFigure {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IPathFigure>();
}
unsafe impl windows_core::Interface for PathFigure {
    type Vtable = <IPathFigure as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IPathFigure as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for PathFigure {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.PathFigure";
}
unsafe impl Send for PathFigure {}
unsafe impl Sync for PathFigure {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PathFigureCollection(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    PathFigureCollection,
    windows_core::IUnknown,
    windows_core::IInspectable,
    windows_collections::IVector<PathFigure>
);
windows_core::imp::required_hierarchy!(
    PathFigureCollection,
    windows_collections::IIterable<PathFigure>
);
impl PathFigureCollection {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            PathFigureCollection,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn First(&self) -> windows_core::Result<windows_collections::IIterator<PathFigure>> {
        let this =
            &windows_core::Interface::cast::<windows_collections::IIterable<PathFigure>>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).First)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAt(&self, index: u32) -> windows_core::Result<PathFigure> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAt)(
                windows_core::Interface::as_raw(this),
                index,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Size(&self) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Size)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn GetView(&self) -> windows_core::Result<windows_collections::IVectorView<PathFigure>> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetView)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn IndexOf<P0>(&self, value: P0, index: &mut u32) -> windows_core::Result<bool>
    where
        P0: windows_core::Param<PathFigure>,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IndexOf)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
                index,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<PathFigure>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn InsertAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<PathFigure>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).InsertAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAt(&self, index: u32) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAt)(
                windows_core::Interface::as_raw(this),
                index,
            )
            .ok()
        }
    }
    pub fn Append<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<PathFigure>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Append)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAtEnd(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAtEnd)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn Clear(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Clear)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
    pub fn GetMany(
        &self,
        startindex: u32,
        items: &mut [Option<PathFigure>],
    ) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetMany)(
                windows_core::Interface::as_raw(this),
                startindex,
                items.len().try_into().unwrap(),
                core::mem::transmute_copy(&items),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn ReplaceAll(&self, items: &[Option<PathFigure>]) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).ReplaceAll)(
                windows_core::Interface::as_raw(this),
                items.len().try_into().unwrap(),
                core::mem::transmute(items.as_ptr()),
            )
            .ok()
        }
    }
}
impl windows_core::RuntimeType for PathFigureCollection {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::for_class::<
        Self,
        windows_collections::IVector<PathFigure>,
    >();
}
unsafe impl windows_core::Interface for PathFigureCollection {
    type Vtable = <windows_collections::IVector<PathFigure> as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID =
        <windows_collections::IVector<PathFigure> as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for PathFigureCollection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.PathFigureCollection";
}
unsafe impl Send for PathFigureCollection {}
unsafe impl Sync for PathFigureCollection {}
impl IntoIterator for PathFigureCollection {
    type Item = PathFigure;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        IntoIterator::into_iter(&self)
    }
}
impl IntoIterator for &PathFigureCollection {
    type Item = PathFigure;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        self.First().unwrap()
    }
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PathGeometry(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    PathGeometry,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(PathGeometry, Geometry, super::DependencyObject);
impl PathGeometry {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            PathGeometry,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn Bounds(&self) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Bounds)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn FillRule(&self) -> windows_core::Result<FillRule> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FillRule)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetFillRule(&self, value: FillRule) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetFillRule)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Figures(&self) -> windows_core::Result<PathFigureCollection> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Figures)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetFigures<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<PathFigureCollection>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetFigures)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn FillRuleProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPathGeometryStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FillRuleProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn FiguresProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPathGeometryStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FiguresProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IPathGeometryStatics<R, F: FnOnce(&IPathGeometryStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<PathGeometry, IPathGeometryStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for PathGeometry {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IPathGeometry>();
}
unsafe impl windows_core::Interface for PathGeometry {
    type Vtable = <IPathGeometry as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IPathGeometry as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for PathGeometry {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.PathGeometry";
}
unsafe impl Send for PathGeometry {}
unsafe impl Sync for PathGeometry {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PathSegment(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    PathSegment,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(PathSegment, super::DependencyObject);
impl PathSegment {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
impl windows_core::RuntimeType for PathSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IPathSegment>();
}
unsafe impl windows_core::Interface for PathSegment {
    type Vtable = <IPathSegment as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IPathSegment as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for PathSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.PathSegment";
}
unsafe impl Send for PathSegment {}
unsafe impl Sync for PathSegment {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PathSegmentCollection(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    PathSegmentCollection,
    windows_core::IUnknown,
    windows_core::IInspectable,
    windows_collections::IVector<PathSegment>
);
windows_core::imp::required_hierarchy!(
    PathSegmentCollection,
    windows_collections::IIterable<PathSegment>
);
impl PathSegmentCollection {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            PathSegmentCollection,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn First(&self) -> windows_core::Result<windows_collections::IIterator<PathSegment>> {
        let this =
            &windows_core::Interface::cast::<windows_collections::IIterable<PathSegment>>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).First)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAt(&self, index: u32) -> windows_core::Result<PathSegment> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAt)(
                windows_core::Interface::as_raw(this),
                index,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Size(&self) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Size)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn GetView(&self) -> windows_core::Result<windows_collections::IVectorView<PathSegment>> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetView)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn IndexOf<P0>(&self, value: P0, index: &mut u32) -> windows_core::Result<bool>
    where
        P0: windows_core::Param<PathSegment>,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IndexOf)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
                index,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<PathSegment>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn InsertAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<PathSegment>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).InsertAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAt(&self, index: u32) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAt)(
                windows_core::Interface::as_raw(this),
                index,
            )
            .ok()
        }
    }
    pub fn Append<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<PathSegment>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Append)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAtEnd(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAtEnd)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn Clear(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Clear)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
    pub fn GetMany(
        &self,
        startindex: u32,
        items: &mut [Option<PathSegment>],
    ) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetMany)(
                windows_core::Interface::as_raw(this),
                startindex,
                items.len().try_into().unwrap(),
                core::mem::transmute_copy(&items),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn ReplaceAll(&self, items: &[Option<PathSegment>]) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).ReplaceAll)(
                windows_core::Interface::as_raw(this),
                items.len().try_into().unwrap(),
                core::mem::transmute(items.as_ptr()),
            )
            .ok()
        }
    }
}
impl windows_core::RuntimeType for PathSegmentCollection {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::for_class::<
        Self,
        windows_collections::IVector<PathSegment>,
    >();
}
unsafe impl windows_core::Interface for PathSegmentCollection {
    type Vtable = <windows_collections::IVector<PathSegment> as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID =
        <windows_collections::IVector<PathSegment> as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for PathSegmentCollection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.PathSegmentCollection";
}
unsafe impl Send for PathSegmentCollection {}
unsafe impl Sync for PathSegmentCollection {}
impl IntoIterator for PathSegmentCollection {
    type Item = PathSegment;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        IntoIterator::into_iter(&self)
    }
}
impl IntoIterator for &PathSegmentCollection {
    type Item = PathSegment;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        self.First().unwrap()
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct PenLineCap(pub i32);
impl PenLineCap {
    pub const Flat: Self = Self(0i32);
    pub const Square: Self = Self(1i32);
    pub const Round: Self = Self(2i32);
    pub const Triangle: Self = Self(3i32);
}
impl windows_core::TypeKind for PenLineCap {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for PenLineCap {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::from_slice(b"enum(Microsoft.UI.Xaml.Media.PenLineCap;i4)");
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct PenLineJoin(pub i32);
impl PenLineJoin {
    pub const Miter: Self = Self(0i32);
    pub const Bevel: Self = Self(1i32);
    pub const Round: Self = Self(2i32);
}
impl windows_core::TypeKind for PenLineJoin {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for PenLineJoin {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::from_slice(b"enum(Microsoft.UI.Xaml.Media.PenLineJoin;i4)");
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PlaneProjection(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    PlaneProjection,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(PlaneProjection, Projection, super::DependencyObject);
impl PlaneProjection {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            PlaneProjection,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn LocalOffsetX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).LocalOffsetX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetLocalOffsetX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetLocalOffsetX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn LocalOffsetY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).LocalOffsetY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetLocalOffsetY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetLocalOffsetY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn LocalOffsetZ(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).LocalOffsetZ)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetLocalOffsetZ(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetLocalOffsetZ)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn RotationX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RotationX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetRotationX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetRotationX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn RotationY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RotationY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetRotationY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetRotationY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn RotationZ(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RotationZ)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetRotationZ(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetRotationZ)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterOfRotationX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterOfRotationX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenterOfRotationX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenterOfRotationX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterOfRotationY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterOfRotationY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenterOfRotationY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenterOfRotationY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterOfRotationZ(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterOfRotationZ)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenterOfRotationZ(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenterOfRotationZ)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn GlobalOffsetX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GlobalOffsetX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetGlobalOffsetX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetGlobalOffsetX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn GlobalOffsetY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GlobalOffsetY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetGlobalOffsetY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetGlobalOffsetY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn GlobalOffsetZ(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GlobalOffsetZ)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetGlobalOffsetZ(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetGlobalOffsetZ)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    #[cfg(feature = "UI_Xaml_Media_Media3D")]
    pub fn ProjectionMatrix(&self) -> windows_core::Result<Media3D::Matrix3D> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ProjectionMatrix)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn LocalOffsetXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).LocalOffsetXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn LocalOffsetYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).LocalOffsetYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn LocalOffsetZProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).LocalOffsetZProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn RotationXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RotationXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn RotationYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RotationYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn RotationZProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RotationZProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn CenterOfRotationXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterOfRotationXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn CenterOfRotationYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterOfRotationYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn CenterOfRotationZProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterOfRotationZProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GlobalOffsetXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GlobalOffsetXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GlobalOffsetYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GlobalOffsetYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GlobalOffsetZProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GlobalOffsetZProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn ProjectionMatrixProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPlaneProjectionStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ProjectionMatrixProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IPlaneProjectionStatics<
        R,
        F: FnOnce(&IPlaneProjectionStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<PlaneProjection, IPlaneProjectionStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for PlaneProjection {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IPlaneProjection>();
}
unsafe impl windows_core::Interface for PlaneProjection {
    type Vtable = <IPlaneProjection as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IPlaneProjection as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for PlaneProjection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.PlaneProjection";
}
unsafe impl Send for PlaneProjection {}
unsafe impl Sync for PlaneProjection {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PointCollection(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    PointCollection,
    windows_core::IUnknown,
    windows_core::IInspectable,
    windows_collections::IVector<windows::Foundation::Point>
);
windows_core::imp::required_hierarchy!(
    PointCollection,
    windows_collections::IIterable<windows::Foundation::Point>
);
impl PointCollection {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            PointCollection,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn First(
        &self,
    ) -> windows_core::Result<windows_collections::IIterator<windows::Foundation::Point>> {
        let this = &windows_core::Interface::cast::<
            windows_collections::IIterable<windows::Foundation::Point>,
        >(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).First)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAt(&self, index: u32) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAt)(
                windows_core::Interface::as_raw(this),
                index,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn Size(&self) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Size)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn GetView(
        &self,
    ) -> windows_core::Result<windows_collections::IVectorView<windows::Foundation::Point>> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetView)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn IndexOf(
        &self,
        value: windows::Foundation::Point,
        index: &mut u32,
    ) -> windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IndexOf)(
                windows_core::Interface::as_raw(this),
                value,
                index,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAt(&self, index: u32, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAt)(
                windows_core::Interface::as_raw(this),
                index,
                value,
            )
            .ok()
        }
    }
    pub fn InsertAt(
        &self,
        index: u32,
        value: windows::Foundation::Point,
    ) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).InsertAt)(
                windows_core::Interface::as_raw(this),
                index,
                value,
            )
            .ok()
        }
    }
    pub fn RemoveAt(&self, index: u32) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAt)(
                windows_core::Interface::as_raw(this),
                index,
            )
            .ok()
        }
    }
    pub fn Append(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Append)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn RemoveAtEnd(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAtEnd)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn Clear(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Clear)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
    pub fn GetMany(
        &self,
        startindex: u32,
        items: &mut [windows::Foundation::Point],
    ) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetMany)(
                windows_core::Interface::as_raw(this),
                startindex,
                items.len().try_into().unwrap(),
                items.as_mut_ptr(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn ReplaceAll(&self, items: &[windows::Foundation::Point]) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).ReplaceAll)(
                windows_core::Interface::as_raw(this),
                items.len().try_into().unwrap(),
                items.as_ptr(),
            )
            .ok()
        }
    }
}
impl windows_core::RuntimeType for PointCollection {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::for_class::<
        Self,
        windows_collections::IVector<windows::Foundation::Point>,
    >();
}
unsafe impl windows_core::Interface for PointCollection {
    type Vtable = < windows_collections:: IVector < windows::Foundation:: Point > as windows_core::Interface >::Vtable ;
    const IID: windows_core::GUID =
        <windows_collections::IVector<windows::Foundation::Point> as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for PointCollection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.PointCollection";
}
unsafe impl Send for PointCollection {}
unsafe impl Sync for PointCollection {}
impl IntoIterator for PointCollection {
    type Item = windows::Foundation::Point;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        IntoIterator::into_iter(&self)
    }
}
impl IntoIterator for &PointCollection {
    type Item = windows::Foundation::Point;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        self.First().unwrap()
    }
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PolyBezierSegment(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    PolyBezierSegment,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(PolyBezierSegment, PathSegment, super::DependencyObject);
impl PolyBezierSegment {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            PolyBezierSegment,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Points(&self) -> windows_core::Result<PointCollection> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Points)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetPoints<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<PointCollection>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetPoints)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn PointsProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPolyBezierSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).PointsProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IPolyBezierSegmentStatics<
        R,
        F: FnOnce(&IPolyBezierSegmentStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            PolyBezierSegment,
            IPolyBezierSegmentStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for PolyBezierSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IPolyBezierSegment>();
}
unsafe impl windows_core::Interface for PolyBezierSegment {
    type Vtable = <IPolyBezierSegment as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IPolyBezierSegment as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for PolyBezierSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.PolyBezierSegment";
}
unsafe impl Send for PolyBezierSegment {}
unsafe impl Sync for PolyBezierSegment {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PolyLineSegment(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    PolyLineSegment,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(PolyLineSegment, PathSegment, super::DependencyObject);
impl PolyLineSegment {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            PolyLineSegment,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Points(&self) -> windows_core::Result<PointCollection> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Points)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetPoints<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<PointCollection>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetPoints)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn PointsProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPolyLineSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).PointsProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IPolyLineSegmentStatics<
        R,
        F: FnOnce(&IPolyLineSegmentStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<PolyLineSegment, IPolyLineSegmentStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for PolyLineSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IPolyLineSegment>();
}
unsafe impl windows_core::Interface for PolyLineSegment {
    type Vtable = <IPolyLineSegment as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IPolyLineSegment as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for PolyLineSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.PolyLineSegment";
}
unsafe impl Send for PolyLineSegment {}
unsafe impl Sync for PolyLineSegment {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PolyQuadraticBezierSegment(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    PolyQuadraticBezierSegment,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(
    PolyQuadraticBezierSegment,
    PathSegment,
    super::DependencyObject
);
impl PolyQuadraticBezierSegment {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            PolyQuadraticBezierSegment,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Points(&self) -> windows_core::Result<PointCollection> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Points)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetPoints<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<PointCollection>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetPoints)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn PointsProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IPolyQuadraticBezierSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).PointsProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IPolyQuadraticBezierSegmentStatics<
        R,
        F: FnOnce(&IPolyQuadraticBezierSegmentStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            PolyQuadraticBezierSegment,
            IPolyQuadraticBezierSegmentStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for PolyQuadraticBezierSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IPolyQuadraticBezierSegment>();
}
unsafe impl windows_core::Interface for PolyQuadraticBezierSegment {
    type Vtable = <IPolyQuadraticBezierSegment as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IPolyQuadraticBezierSegment as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for PolyQuadraticBezierSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.PolyQuadraticBezierSegment";
}
unsafe impl Send for PolyQuadraticBezierSegment {}
unsafe impl Sync for PolyQuadraticBezierSegment {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Projection(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    Projection,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(Projection, super::DependencyObject);
impl Projection {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn new() -> windows_core::Result<Projection> {
        Self::IProjectionFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IProjectionFactory<R, F: FnOnce(&IProjectionFactory) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<Projection, IProjectionFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for Projection {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IProjection>();
}
unsafe impl windows_core::Interface for Projection {
    type Vtable = <IProjection as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IProjection as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for Projection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.Projection";
}
unsafe impl Send for Projection {}
unsafe impl Sync for Projection {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct QuadraticBezierSegment(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    QuadraticBezierSegment,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(
    QuadraticBezierSegment,
    PathSegment,
    super::DependencyObject
);
impl QuadraticBezierSegment {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            QuadraticBezierSegment,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Point1(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point1)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetPoint1(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetPoint1)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Point2(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point2)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetPoint2(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetPoint2)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Point1Property() -> windows_core::Result<super::DependencyProperty> {
        Self::IQuadraticBezierSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point1Property)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn Point2Property() -> windows_core::Result<super::DependencyProperty> {
        Self::IQuadraticBezierSegmentStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Point2Property)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IQuadraticBezierSegmentStatics<
        R,
        F: FnOnce(&IQuadraticBezierSegmentStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            QuadraticBezierSegment,
            IQuadraticBezierSegmentStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for QuadraticBezierSegment {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IQuadraticBezierSegment>();
}
unsafe impl windows_core::Interface for QuadraticBezierSegment {
    type Vtable = <IQuadraticBezierSegment as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IQuadraticBezierSegment as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for QuadraticBezierSegment {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.QuadraticBezierSegment";
}
unsafe impl Send for QuadraticBezierSegment {}
unsafe impl Sync for QuadraticBezierSegment {}
#[cfg(feature = "UI_Composition")]
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RadialGradientBrush(windows_core::IUnknown);
#[cfg(feature = "UI_Composition")]
windows_core::imp::interface_hierarchy!(
    RadialGradientBrush,
    windows_core::IUnknown,
    windows_core::IInspectable
);
#[cfg(feature = "UI_Composition")]
windows_core::imp::required_hierarchy!(
    RadialGradientBrush,
    super::super::Composition::IAnimationObject,
    XamlCompositionBrushBase,
    Brush,
    super::DependencyObject
);
#[cfg(feature = "UI_Composition")]
impl RadialGradientBrush {
    pub fn PopulatePropertyInfo<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        propertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this =
            &windows_core::Interface::cast::<super::super::Composition::IAnimationObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfo)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                propertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn Opacity(&self) -> windows_core::Result<f64> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Opacity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetOpacity(&self, value: f64) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetOpacity)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RelativeTransform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RelativeTransform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetRelativeTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetRelativeTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn PopulatePropertyInfoOverride<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        animationpropertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this = &windows_core::Interface::cast::<IBrushOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfoOverride)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                animationpropertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Center(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Center)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenter(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenter)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn RadiusX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RadiusX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetRadiusX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetRadiusX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn RadiusY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RadiusY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetRadiusY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetRadiusY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn GradientOrigin(&self) -> windows_core::Result<windows::Foundation::Point> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GradientOrigin)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetGradientOrigin(&self, value: windows::Foundation::Point) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetGradientOrigin)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn MappingMode(&self) -> windows_core::Result<BrushMappingMode> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).MappingMode)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetMappingMode(&self, value: BrushMappingMode) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetMappingMode)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn InterpolationSpace(
        &self,
    ) -> windows_core::Result<super::super::Composition::CompositionColorSpace> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).InterpolationSpace)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetInterpolationSpace(
        &self,
        value: super::super::Composition::CompositionColorSpace,
    ) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetInterpolationSpace)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn SpreadMethod(&self) -> windows_core::Result<GradientSpreadMethod> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SpreadMethod)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetSpreadMethod(&self, value: GradientSpreadMethod) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetSpreadMethod)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn GradientStops(
        &self,
    ) -> windows_core::Result<windows::Foundation::Collections::IObservableVector<GradientStop>>
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GradientStops)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn new() -> windows_core::Result<RadialGradientBrush> {
        Self::IRadialGradientBrushFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn CenterProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IRadialGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn RadiusXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IRadialGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RadiusXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn RadiusYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IRadialGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RadiusYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GradientOriginProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IRadialGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GradientOriginProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn InterpolationSpaceProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IRadialGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).InterpolationSpaceProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn MappingModeProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IRadialGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).MappingModeProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn SpreadMethodProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IRadialGradientBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).SpreadMethodProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn FallbackColor(&self) -> windows_core::Result<windows::UI::Color> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBase>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FallbackColor)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetFallbackColor(&self, value: windows::UI::Color) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBase>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetFallbackColor)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn OnConnected(&self) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnConnected)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn OnDisconnected(&self) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnDisconnected)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn CompositionBrush(
        &self,
    ) -> windows_core::Result<super::super::Composition::CompositionBrush> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseProtected>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CompositionBrush)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetCompositionBrush<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::CompositionBrush>,
    {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseProtected>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetCompositionBrush)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    fn IRadialGradientBrushFactory<
        R,
        F: FnOnce(&IRadialGradientBrushFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            RadialGradientBrush,
            IRadialGradientBrushFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn IRadialGradientBrushStatics<
        R,
        F: FnOnce(&IRadialGradientBrushStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            RadialGradientBrush,
            IRadialGradientBrushStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeType for RadialGradientBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IRadialGradientBrush>();
}
#[cfg(feature = "UI_Composition")]
unsafe impl windows_core::Interface for RadialGradientBrush {
    type Vtable = <IRadialGradientBrush as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IRadialGradientBrush as windows_core::Interface>::IID;
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for RadialGradientBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.RadialGradientBrush";
}
#[cfg(feature = "UI_Composition")]
unsafe impl Send for RadialGradientBrush {}
#[cfg(feature = "UI_Composition")]
unsafe impl Sync for RadialGradientBrush {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RectangleGeometry(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    RectangleGeometry,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(RectangleGeometry, Geometry, super::DependencyObject);
impl RectangleGeometry {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            RectangleGeometry,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn Bounds(&self) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeometry>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Bounds)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn Rect(&self) -> windows_core::Result<windows::Foundation::Rect> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Rect)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetRect(&self, value: windows::Foundation::Rect) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetRect)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn RectProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IRectangleGeometryStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RectProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IRectangleGeometryStatics<
        R,
        F: FnOnce(&IRectangleGeometryStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            RectangleGeometry,
            IRectangleGeometryStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for RectangleGeometry {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IRectangleGeometry>();
}
unsafe impl windows_core::Interface for RectangleGeometry {
    type Vtable = <IRectangleGeometry as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IRectangleGeometry as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for RectangleGeometry {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.RectangleGeometry";
}
unsafe impl Send for RectangleGeometry {}
unsafe impl Sync for RectangleGeometry {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RenderedEventArgs(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    RenderedEventArgs,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl RenderedEventArgs {
    pub fn FrameDuration(&self) -> windows_core::Result<windows::Foundation::TimeSpan> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FrameDuration)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
}
impl windows_core::RuntimeType for RenderedEventArgs {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IRenderedEventArgs>();
}
unsafe impl windows_core::Interface for RenderedEventArgs {
    type Vtable = <IRenderedEventArgs as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IRenderedEventArgs as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for RenderedEventArgs {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.RenderedEventArgs";
}
unsafe impl Send for RenderedEventArgs {}
unsafe impl Sync for RenderedEventArgs {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RenderingEventArgs(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    RenderingEventArgs,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl RenderingEventArgs {
    pub fn RenderingTime(&self) -> windows_core::Result<windows::Foundation::TimeSpan> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RenderingTime)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
}
impl windows_core::RuntimeType for RenderingEventArgs {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IRenderingEventArgs>();
}
unsafe impl windows_core::Interface for RenderingEventArgs {
    type Vtable = <IRenderingEventArgs as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IRenderingEventArgs as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for RenderingEventArgs {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.RenderingEventArgs";
}
unsafe impl Send for RenderingEventArgs {}
unsafe impl Sync for RenderingEventArgs {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RotateTransform(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    RotateTransform,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(
    RotateTransform,
    Transform,
    GeneralTransform,
    super::DependencyObject
);
impl RotateTransform {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            RotateTransform,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Inverse(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Inverse)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TransformPoint(
        &self,
        point: windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformPoint)(
                windows_core::Interface::as_raw(this),
                point,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TryTransform(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransform)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBounds(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBounds)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn InverseCore(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).InverseCore)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TryTransformCore(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransformCore)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBoundsCore(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBoundsCore)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn CenterX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenterX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenterX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenterY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenterY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Angle(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Angle)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAngle(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAngle)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IRotateTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn CenterYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IRotateTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn AngleProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IRotateTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AngleProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IRotateTransformStatics<
        R,
        F: FnOnce(&IRotateTransformStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<RotateTransform, IRotateTransformStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for RotateTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IRotateTransform>();
}
unsafe impl windows_core::Interface for RotateTransform {
    type Vtable = <IRotateTransform as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IRotateTransform as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for RotateTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.RotateTransform";
}
unsafe impl Send for RotateTransform {}
unsafe impl Sync for RotateTransform {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ScaleTransform(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    ScaleTransform,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(
    ScaleTransform,
    Transform,
    GeneralTransform,
    super::DependencyObject
);
impl ScaleTransform {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            ScaleTransform,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Inverse(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Inverse)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TransformPoint(
        &self,
        point: windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformPoint)(
                windows_core::Interface::as_raw(this),
                point,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TryTransform(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransform)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBounds(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBounds)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn InverseCore(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).InverseCore)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TryTransformCore(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransformCore)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBoundsCore(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBoundsCore)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn CenterX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenterX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenterX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenterY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenterY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn ScaleX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ScaleX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetScaleX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetScaleX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn ScaleY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ScaleY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetScaleY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetScaleY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IScaleTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn CenterYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IScaleTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn ScaleXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IScaleTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ScaleXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn ScaleYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IScaleTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ScaleYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IScaleTransformStatics<R, F: FnOnce(&IScaleTransformStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<ScaleTransform, IScaleTransformStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for ScaleTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IScaleTransform>();
}
unsafe impl windows_core::Interface for ScaleTransform {
    type Vtable = <IScaleTransform as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IScaleTransform as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for ScaleTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ScaleTransform";
}
unsafe impl Send for ScaleTransform {}
unsafe impl Sync for ScaleTransform {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Shadow(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(Shadow, windows_core::IUnknown, windows_core::IInspectable);
windows_core::imp::required_hierarchy!(Shadow, super::DependencyObject);
impl Shadow {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
impl windows_core::RuntimeType for Shadow {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IShadow>();
}
unsafe impl windows_core::Interface for Shadow {
    type Vtable = <IShadow as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IShadow as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for Shadow {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.Shadow";
}
unsafe impl Send for Shadow {}
unsafe impl Sync for Shadow {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SkewTransform(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    SkewTransform,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(
    SkewTransform,
    Transform,
    GeneralTransform,
    super::DependencyObject
);
impl SkewTransform {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            SkewTransform,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Inverse(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Inverse)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TransformPoint(
        &self,
        point: windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformPoint)(
                windows_core::Interface::as_raw(this),
                point,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TryTransform(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransform)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBounds(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBounds)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn InverseCore(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).InverseCore)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TryTransformCore(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransformCore)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBoundsCore(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBoundsCore)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn CenterX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenterX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenterX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetCenterY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetCenterY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn AngleX(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AngleX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAngleX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAngleX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn AngleY(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AngleY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAngleY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAngleY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CenterXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ISkewTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn CenterYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ISkewTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CenterYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn AngleXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ISkewTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AngleXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn AngleYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ISkewTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AngleYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn ISkewTransformStatics<R, F: FnOnce(&ISkewTransformStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<SkewTransform, ISkewTransformStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for SkewTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ISkewTransform>();
}
unsafe impl windows_core::Interface for SkewTransform {
    type Vtable = <ISkewTransform as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ISkewTransform as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for SkewTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.SkewTransform";
}
unsafe impl Send for SkewTransform {}
unsafe impl Sync for SkewTransform {}
#[cfg(feature = "UI_Composition")]
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SolidColorBrush(windows_core::IUnknown);
#[cfg(feature = "UI_Composition")]
windows_core::imp::interface_hierarchy!(
    SolidColorBrush,
    windows_core::IUnknown,
    windows_core::IInspectable
);
#[cfg(feature = "UI_Composition")]
windows_core::imp::required_hierarchy!(
    SolidColorBrush,
    super::super::Composition::IAnimationObject,
    Brush,
    super::DependencyObject
);
#[cfg(feature = "UI_Composition")]
impl SolidColorBrush {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            SolidColorBrush,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn PopulatePropertyInfo<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        propertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this =
            &windows_core::Interface::cast::<super::super::Composition::IAnimationObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfo)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                propertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn Opacity(&self) -> windows_core::Result<f64> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Opacity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetOpacity(&self, value: f64) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetOpacity)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RelativeTransform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RelativeTransform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetRelativeTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetRelativeTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn PopulatePropertyInfoOverride<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        animationpropertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this = &windows_core::Interface::cast::<IBrushOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfoOverride)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                animationpropertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Color(&self) -> windows_core::Result<windows::UI::Color> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Color)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetColor(&self, value: windows::UI::Color) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetColor)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn CreateInstanceWithColor(
        color: windows::UI::Color,
    ) -> windows_core::Result<SolidColorBrush> {
        Self::ISolidColorBrushFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstanceWithColor)(
                windows_core::Interface::as_raw(this),
                color,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn ColorProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ISolidColorBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ColorProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn ISolidColorBrushFactory<
        R,
        F: FnOnce(&ISolidColorBrushFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<SolidColorBrush, ISolidColorBrushFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn ISolidColorBrushStatics<
        R,
        F: FnOnce(&ISolidColorBrushStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<SolidColorBrush, ISolidColorBrushStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeType for SolidColorBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ISolidColorBrush>();
}
#[cfg(feature = "UI_Composition")]
unsafe impl windows_core::Interface for SolidColorBrush {
    type Vtable = <ISolidColorBrush as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ISolidColorBrush as windows_core::Interface>::IID;
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for SolidColorBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.SolidColorBrush";
}
#[cfg(feature = "UI_Composition")]
unsafe impl Send for SolidColorBrush {}
#[cfg(feature = "UI_Composition")]
unsafe impl Sync for SolidColorBrush {}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct Stretch(pub i32);
impl Stretch {
    pub const None: Self = Self(0i32);
    pub const Fill: Self = Self(1i32);
    pub const Uniform: Self = Self(2i32);
    pub const UniformToFill: Self = Self(3i32);
}
impl windows_core::TypeKind for Stretch {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for Stretch {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::from_slice(b"enum(Microsoft.UI.Xaml.Media.Stretch;i4)");
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct StyleSimulations(pub i32);
impl StyleSimulations {
    pub const None: Self = Self(0i32);
    pub const BoldSimulation: Self = Self(1i32);
    pub const ItalicSimulation: Self = Self(2i32);
    pub const BoldItalicSimulation: Self = Self(3i32);
}
impl windows_core::TypeKind for StyleSimulations {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for StyleSimulations {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::from_slice(
        b"enum(Microsoft.UI.Xaml.Media.StyleSimulations;i4)",
    );
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct SweepDirection(pub i32);
impl SweepDirection {
    pub const Counterclockwise: Self = Self(0i32);
    pub const Clockwise: Self = Self(1i32);
}
impl windows_core::TypeKind for SweepDirection {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for SweepDirection {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::from_slice(
        b"enum(Microsoft.UI.Xaml.Media.SweepDirection;i4)",
    );
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SystemBackdrop(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    SystemBackdrop,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(SystemBackdrop, super::DependencyObject);
impl SystemBackdrop {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Composition_SystemBackdrops")]
    pub fn GetDefaultSystemBackdropConfiguration<P0, P1>(
        &self,
        target: P0,
        xamlroot: P1,
    ) -> windows_core::Result<super::super::Composition::SystemBackdrops::SystemBackdropConfiguration>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
        P1: windows_core::Param<super::XamlRoot>,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetDefaultSystemBackdropConfiguration)(
                windows_core::Interface::as_raw(this),
                target.param().abi(),
                xamlroot.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn new() -> windows_core::Result<SystemBackdrop> {
        Self::ISystemBackdropFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    #[cfg(feature = "UI_Composition")]
    pub fn OnTargetConnected<P0, P1>(
        &self,
        connectedtarget: P0,
        xamlroot: P1,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
        P1: windows_core::Param<super::XamlRoot>,
    {
        let this = &windows_core::Interface::cast::<ISystemBackdropOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnTargetConnected)(
                windows_core::Interface::as_raw(this),
                connectedtarget.param().abi(),
                xamlroot.param().abi(),
            )
            .ok()
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn OnTargetDisconnected<P0>(&self, disconnectedtarget: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
    {
        let this = &windows_core::Interface::cast::<ISystemBackdropOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnTargetDisconnected)(
                windows_core::Interface::as_raw(this),
                disconnectedtarget.param().abi(),
            )
            .ok()
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn OnDefaultSystemBackdropConfigurationChanged<P0, P1>(
        &self,
        target: P0,
        xamlroot: P1,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::ICompositionSupportsSystemBackdrop>,
        P1: windows_core::Param<super::XamlRoot>,
    {
        let this = &windows_core::Interface::cast::<ISystemBackdropOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnDefaultSystemBackdropConfigurationChanged)(
                windows_core::Interface::as_raw(this),
                target.param().abi(),
                xamlroot.param().abi(),
            )
            .ok()
        }
    }
    fn ISystemBackdropFactory<R, F: FnOnce(&ISystemBackdropFactory) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<SystemBackdrop, ISystemBackdropFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for SystemBackdrop {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ISystemBackdrop>();
}
unsafe impl windows_core::Interface for SystemBackdrop {
    type Vtable = <ISystemBackdrop as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ISystemBackdrop as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for SystemBackdrop {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.SystemBackdrop";
}
unsafe impl Send for SystemBackdrop {}
unsafe impl Sync for SystemBackdrop {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ThemeShadow(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    ThemeShadow,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(ThemeShadow, Shadow, super::DependencyObject);
impl ThemeShadow {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn Receivers(&self) -> windows_core::Result<super::UIElementWeakCollection> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Receivers)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn new() -> windows_core::Result<ThemeShadow> {
        Self::IThemeShadowFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IThemeShadowFactory<R, F: FnOnce(&IThemeShadowFactory) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<ThemeShadow, IThemeShadowFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for ThemeShadow {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IThemeShadow>();
}
unsafe impl windows_core::Interface for ThemeShadow {
    type Vtable = <IThemeShadow as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IThemeShadow as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for ThemeShadow {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.ThemeShadow";
}
unsafe impl Send for ThemeShadow {}
unsafe impl Sync for ThemeShadow {}
#[cfg(feature = "UI_Composition")]
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct TileBrush(windows_core::IUnknown);
#[cfg(feature = "UI_Composition")]
windows_core::imp::interface_hierarchy!(
    TileBrush,
    windows_core::IUnknown,
    windows_core::IInspectable
);
#[cfg(feature = "UI_Composition")]
windows_core::imp::required_hierarchy!(
    TileBrush,
    super::super::Composition::IAnimationObject,
    Brush,
    super::DependencyObject
);
#[cfg(feature = "UI_Composition")]
impl TileBrush {
    pub fn PopulatePropertyInfo<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        propertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this =
            &windows_core::Interface::cast::<super::super::Composition::IAnimationObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfo)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                propertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn Opacity(&self) -> windows_core::Result<f64> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Opacity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetOpacity(&self, value: f64) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetOpacity)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RelativeTransform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RelativeTransform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetRelativeTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetRelativeTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn PopulatePropertyInfoOverride<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        animationpropertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this = &windows_core::Interface::cast::<IBrushOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfoOverride)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                animationpropertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn AlignmentX(&self) -> windows_core::Result<AlignmentX> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AlignmentX)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAlignmentX(&self, value: AlignmentX) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAlignmentX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn AlignmentY(&self) -> windows_core::Result<AlignmentY> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AlignmentY)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAlignmentY(&self, value: AlignmentY) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAlignmentY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Stretch(&self) -> windows_core::Result<Stretch> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Stretch)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetStretch(&self, value: Stretch) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetStretch)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn new() -> windows_core::Result<TileBrush> {
        Self::ITileBrushFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn AlignmentXProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ITileBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AlignmentXProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn AlignmentYProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ITileBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).AlignmentYProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn StretchProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ITileBrushStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).StretchProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn ITileBrushFactory<R, F: FnOnce(&ITileBrushFactory) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<TileBrush, ITileBrushFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn ITileBrushStatics<R, F: FnOnce(&ITileBrushStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<TileBrush, ITileBrushStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeType for TileBrush {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ITileBrush>();
}
#[cfg(feature = "UI_Composition")]
unsafe impl windows_core::Interface for TileBrush {
    type Vtable = <ITileBrush as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ITileBrush as windows_core::Interface>::IID;
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for TileBrush {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.TileBrush";
}
#[cfg(feature = "UI_Composition")]
unsafe impl Send for TileBrush {}
#[cfg(feature = "UI_Composition")]
unsafe impl Sync for TileBrush {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Transform(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    Transform,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(Transform, GeneralTransform, super::DependencyObject);
impl Transform {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Inverse(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Inverse)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TransformPoint(
        &self,
        point: windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformPoint)(
                windows_core::Interface::as_raw(this),
                point,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TryTransform(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransform)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBounds(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBounds)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn InverseCore(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).InverseCore)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TryTransformCore(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransformCore)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBoundsCore(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBoundsCore)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
}
impl windows_core::RuntimeType for Transform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ITransform>();
}
unsafe impl windows_core::Interface for Transform {
    type Vtable = <ITransform as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ITransform as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for Transform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.Transform";
}
unsafe impl Send for Transform {}
unsafe impl Sync for Transform {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct TransformCollection(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    TransformCollection,
    windows_core::IUnknown,
    windows_core::IInspectable,
    windows_collections::IVector<Transform>
);
windows_core::imp::required_hierarchy!(
    TransformCollection,
    windows_collections::IIterable<Transform>
);
impl TransformCollection {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            TransformCollection,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn First(&self) -> windows_core::Result<windows_collections::IIterator<Transform>> {
        let this =
            &windows_core::Interface::cast::<windows_collections::IIterable<Transform>>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).First)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAt(&self, index: u32) -> windows_core::Result<Transform> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAt)(
                windows_core::Interface::as_raw(this),
                index,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Size(&self) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Size)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn GetView(&self) -> windows_core::Result<windows_collections::IVectorView<Transform>> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetView)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn IndexOf<P0>(&self, value: P0, index: &mut u32) -> windows_core::Result<bool>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IndexOf)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
                index,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<Transform>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn InsertAt<P1>(&self, index: u32, value: P1) -> windows_core::Result<()>
    where
        P1: windows_core::Param<Transform>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).InsertAt)(
                windows_core::Interface::as_raw(this),
                index,
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAt(&self, index: u32) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAt)(
                windows_core::Interface::as_raw(this),
                index,
            )
            .ok()
        }
    }
    pub fn Append<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Append)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RemoveAtEnd(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveAtEnd)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn Clear(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Clear)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
    pub fn GetMany(
        &self,
        startindex: u32,
        items: &mut [Option<Transform>],
    ) -> windows_core::Result<u32> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetMany)(
                windows_core::Interface::as_raw(this),
                startindex,
                items.len().try_into().unwrap(),
                core::mem::transmute_copy(&items),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn ReplaceAll(&self, items: &[Option<Transform>]) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).ReplaceAll)(
                windows_core::Interface::as_raw(this),
                items.len().try_into().unwrap(),
                core::mem::transmute(items.as_ptr()),
            )
            .ok()
        }
    }
}
impl windows_core::RuntimeType for TransformCollection {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, windows_collections::IVector<Transform>>(
        );
}
unsafe impl windows_core::Interface for TransformCollection {
    type Vtable = <windows_collections::IVector<Transform> as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID =
        <windows_collections::IVector<Transform> as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for TransformCollection {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.TransformCollection";
}
unsafe impl Send for TransformCollection {}
unsafe impl Sync for TransformCollection {}
impl IntoIterator for TransformCollection {
    type Item = Transform;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        IntoIterator::into_iter(&self)
    }
}
impl IntoIterator for &TransformCollection {
    type Item = Transform;
    type IntoIter = windows_collections::IIterator<Self::Item>;
    fn into_iter(self) -> Self::IntoIter {
        self.First().unwrap()
    }
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct TransformGroup(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    TransformGroup,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(
    TransformGroup,
    Transform,
    GeneralTransform,
    super::DependencyObject
);
impl TransformGroup {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            TransformGroup,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Inverse(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Inverse)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TransformPoint(
        &self,
        point: windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformPoint)(
                windows_core::Interface::as_raw(this),
                point,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TryTransform(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransform)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBounds(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBounds)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn InverseCore(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).InverseCore)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TryTransformCore(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransformCore)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBoundsCore(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBoundsCore)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn Children(&self) -> windows_core::Result<TransformCollection> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Children)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetChildren<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<TransformCollection>,
    {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetChildren)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn Value(&self) -> windows_core::Result<Matrix> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Value)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn ChildrenProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ITransformGroupStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ChildrenProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn ITransformGroupStatics<R, F: FnOnce(&ITransformGroupStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<TransformGroup, ITransformGroupStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for TransformGroup {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ITransformGroup>();
}
unsafe impl windows_core::Interface for TransformGroup {
    type Vtable = <ITransformGroup as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ITransformGroup as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for TransformGroup {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.TransformGroup";
}
unsafe impl Send for TransformGroup {}
unsafe impl Sync for TransformGroup {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct TranslateTransform(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    TranslateTransform,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(
    TranslateTransform,
    Transform,
    GeneralTransform,
    super::DependencyObject
);
impl TranslateTransform {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            TranslateTransform,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn Inverse(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Inverse)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TransformPoint(
        &self,
        point: windows::Foundation::Point,
    ) -> windows_core::Result<windows::Foundation::Point> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformPoint)(
                windows_core::Interface::as_raw(this),
                point,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TryTransform(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransform)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBounds(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransform>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBounds)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn InverseCore(&self) -> windows_core::Result<GeneralTransform> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).InverseCore)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TryTransformCore(
        &self,
        inpoint: windows::Foundation::Point,
        outpoint: &mut windows::Foundation::Point,
    ) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryTransformCore)(
                windows_core::Interface::as_raw(this),
                inpoint,
                outpoint,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TransformBoundsCore(
        &self,
        rect: windows::Foundation::Rect,
    ) -> windows_core::Result<windows::Foundation::Rect> {
        let this = &windows_core::Interface::cast::<IGeneralTransformOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TransformBoundsCore)(
                windows_core::Interface::as_raw(this),
                rect,
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn X(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).X)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetX(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetX)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Y(&self) -> windows_core::Result<f64> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Y)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetY(&self, value: f64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetY)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn XProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ITranslateTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).XProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn YProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::ITranslateTransformStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).YProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn ITranslateTransformStatics<
        R,
        F: FnOnce(&ITranslateTransformStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            TranslateTransform,
            ITranslateTransformStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for TranslateTransform {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, ITranslateTransform>();
}
unsafe impl windows_core::Interface for TranslateTransform {
    type Vtable = <ITranslateTransform as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <ITranslateTransform as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for TranslateTransform {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.TranslateTransform";
}
unsafe impl Send for TranslateTransform {}
unsafe impl Sync for TranslateTransform {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct VisualTreeHelper(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    VisualTreeHelper,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl VisualTreeHelper {
    #[cfg(feature = "UI_Composition")]
    pub fn FindElementsInHostCoordinatesPoint<P1>(
        intersectingpoint: windows::Foundation::Point,
        subtree: P1,
    ) -> windows_core::Result<windows_collections::IIterable<super::UIElement>>
    where
        P1: windows_core::Param<super::UIElement>,
    {
        Self::IVisualTreeHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FindElementsInHostCoordinatesPoint)(
                windows_core::Interface::as_raw(this),
                intersectingpoint,
                subtree.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    #[cfg(feature = "UI_Composition")]
    pub fn FindElementsInHostCoordinatesRect<P1>(
        intersectingrect: windows::Foundation::Rect,
        subtree: P1,
    ) -> windows_core::Result<windows_collections::IIterable<super::UIElement>>
    where
        P1: windows_core::Param<super::UIElement>,
    {
        Self::IVisualTreeHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FindElementsInHostCoordinatesRect)(
                windows_core::Interface::as_raw(this),
                intersectingrect,
                subtree.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    #[cfg(feature = "UI_Composition")]
    pub fn FindAllElementsInHostCoordinatesPoint<P1>(
        intersectingpoint: windows::Foundation::Point,
        subtree: P1,
        includeallelements: bool,
    ) -> windows_core::Result<windows_collections::IIterable<super::UIElement>>
    where
        P1: windows_core::Param<super::UIElement>,
    {
        Self::IVisualTreeHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FindAllElementsInHostCoordinatesPoint)(
                windows_core::Interface::as_raw(this),
                intersectingpoint,
                subtree.param().abi(),
                includeallelements,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    #[cfg(feature = "UI_Composition")]
    pub fn FindAllElementsInHostCoordinatesRect<P1>(
        intersectingrect: windows::Foundation::Rect,
        subtree: P1,
        includeallelements: bool,
    ) -> windows_core::Result<windows_collections::IIterable<super::UIElement>>
    where
        P1: windows_core::Param<super::UIElement>,
    {
        Self::IVisualTreeHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FindAllElementsInHostCoordinatesRect)(
                windows_core::Interface::as_raw(this),
                intersectingrect,
                subtree.param().abi(),
                includeallelements,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GetChild<P0>(
        reference: P0,
        childindex: i32,
    ) -> windows_core::Result<super::DependencyObject>
    where
        P0: windows_core::Param<super::DependencyObject>,
    {
        Self::IVisualTreeHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetChild)(
                windows_core::Interface::as_raw(this),
                reference.param().abi(),
                childindex,
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GetChildrenCount<P0>(reference: P0) -> windows_core::Result<i32>
    where
        P0: windows_core::Param<super::DependencyObject>,
    {
        Self::IVisualTreeHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetChildrenCount)(
                windows_core::Interface::as_raw(this),
                reference.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        })
    }
    pub fn GetParent<P0>(reference: P0) -> windows_core::Result<super::DependencyObject>
    where
        P0: windows_core::Param<super::DependencyObject>,
    {
        Self::IVisualTreeHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetParent)(
                windows_core::Interface::as_raw(this),
                reference.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    #[cfg(feature = "UI_Composition")]
    pub fn DisconnectChildrenRecursive<P0>(element: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::UIElement>,
    {
        Self::IVisualTreeHelperStatics(|this| unsafe {
            (windows_core::Interface::vtable(this).DisconnectChildrenRecursive)(
                windows_core::Interface::as_raw(this),
                element.param().abi(),
            )
            .ok()
        })
    }
    #[cfg(all(feature = "UI_Composition", feature = "UI_Xaml_Controls_Primitives"))]
    pub fn GetOpenPopups<P0>(
        window: P0,
    ) -> windows_core::Result<windows_collections::IVectorView<super::Controls::Primitives::Popup>>
    where
        P0: windows_core::Param<super::Window>,
    {
        Self::IVisualTreeHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetOpenPopups)(
                windows_core::Interface::as_raw(this),
                window.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    #[cfg(all(feature = "UI_Composition", feature = "UI_Xaml_Controls_Primitives"))]
    pub fn GetOpenPopupsForXamlRoot<P0>(
        xamlroot: P0,
    ) -> windows_core::Result<windows_collections::IVectorView<super::Controls::Primitives::Popup>>
    where
        P0: windows_core::Param<super::XamlRoot>,
    {
        Self::IVisualTreeHelperStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetOpenPopupsForXamlRoot)(
                windows_core::Interface::as_raw(this),
                xamlroot.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IVisualTreeHelperStatics<
        R,
        F: FnOnce(&IVisualTreeHelperStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<VisualTreeHelper, IVisualTreeHelperStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for VisualTreeHelper {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IVisualTreeHelper>();
}
unsafe impl windows_core::Interface for VisualTreeHelper {
    type Vtable = <IVisualTreeHelper as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IVisualTreeHelper as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for VisualTreeHelper {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.VisualTreeHelper";
}
unsafe impl Send for VisualTreeHelper {}
unsafe impl Sync for VisualTreeHelper {}
#[cfg(feature = "UI_Composition")]
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct XamlCompositionBrushBase(windows_core::IUnknown);
#[cfg(feature = "UI_Composition")]
windows_core::imp::interface_hierarchy!(
    XamlCompositionBrushBase,
    windows_core::IUnknown,
    windows_core::IInspectable
);
#[cfg(feature = "UI_Composition")]
windows_core::imp::required_hierarchy!(
    XamlCompositionBrushBase,
    super::super::Composition::IAnimationObject,
    Brush,
    super::DependencyObject
);
#[cfg(feature = "UI_Composition")]
impl XamlCompositionBrushBase {
    pub fn PopulatePropertyInfo<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        propertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this =
            &windows_core::Interface::cast::<super::super::Composition::IAnimationObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfo)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                propertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn Opacity(&self) -> windows_core::Result<f64> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Opacity)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetOpacity(&self, value: f64) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetOpacity)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Transform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Transform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn RelativeTransform(&self) -> windows_core::Result<Transform> {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RelativeTransform)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetRelativeTransform<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<Transform>,
    {
        let this = &windows_core::Interface::cast::<IBrush>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetRelativeTransform)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn PopulatePropertyInfoOverride<P1>(
        &self,
        propertyname: &windows_core::HSTRING,
        animationpropertyinfo: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::super::Composition::AnimationPropertyInfo>,
    {
        let this = &windows_core::Interface::cast::<IBrushOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).PopulatePropertyInfoOverride)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(propertyname),
                animationpropertyinfo.param().abi(),
            )
            .ok()
        }
    }
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn FallbackColor(&self) -> windows_core::Result<windows::UI::Color> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FallbackColor)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetFallbackColor(&self, value: windows::UI::Color) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetFallbackColor)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn new() -> windows_core::Result<XamlCompositionBrushBase> {
        Self::IXamlCompositionBrushBaseFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn OnConnected(&self) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnConnected)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn OnDisconnected(&self) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnDisconnected)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn CompositionBrush(
        &self,
    ) -> windows_core::Result<super::super::Composition::CompositionBrush> {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseProtected>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CompositionBrush)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetCompositionBrush<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::CompositionBrush>,
    {
        let this = &windows_core::Interface::cast::<IXamlCompositionBrushBaseProtected>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetCompositionBrush)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn FallbackColorProperty() -> windows_core::Result<super::DependencyProperty> {
        Self::IXamlCompositionBrushBaseStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FallbackColorProperty)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IXamlCompositionBrushBaseFactory<
        R,
        F: FnOnce(&IXamlCompositionBrushBaseFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            XamlCompositionBrushBase,
            IXamlCompositionBrushBaseFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn IXamlCompositionBrushBaseStatics<
        R,
        F: FnOnce(&IXamlCompositionBrushBaseStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            XamlCompositionBrushBase,
            IXamlCompositionBrushBaseStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeType for XamlCompositionBrushBase {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IXamlCompositionBrushBase>();
}
#[cfg(feature = "UI_Composition")]
unsafe impl windows_core::Interface for XamlCompositionBrushBase {
    type Vtable = <IXamlCompositionBrushBase as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IXamlCompositionBrushBase as windows_core::Interface>::IID;
}
#[cfg(feature = "UI_Composition")]
impl windows_core::RuntimeName for XamlCompositionBrushBase {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.XamlCompositionBrushBase";
}
#[cfg(feature = "UI_Composition")]
unsafe impl Send for XamlCompositionBrushBase {}
#[cfg(feature = "UI_Composition")]
unsafe impl Sync for XamlCompositionBrushBase {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct XamlLight(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    XamlLight,
    windows_core::IUnknown,
    windows_core::IInspectable
);
windows_core::imp::required_hierarchy!(XamlLight, super::DependencyObject);
impl XamlLight {
    pub fn GetValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn SetValue<P0, P1>(&self, dp: P0, value: P1) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<windows_core::IInspectable>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                value.param().abi(),
            )
            .ok()
        }
    }
    pub fn ClearValue<P0>(&self, dp: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ClearValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
            )
            .ok()
        }
    }
    pub fn ReadLocalValue<P0>(&self, dp: P0) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ReadLocalValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn GetAnimationBaseValue<P0>(
        &self,
        dp: P0,
    ) -> windows_core::Result<windows_core::IInspectable>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetAnimationBaseValue)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn RegisterPropertyChangedCallback<P0, P1>(
        &self,
        dp: P0,
        callback: P1,
    ) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<super::DependencyProperty>,
        P1: windows_core::Param<super::DependencyPropertyChangedCallback>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).RegisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn UnregisterPropertyChangedCallback<P0>(
        &self,
        dp: P0,
        token: i64,
    ) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::DependencyProperty>,
    {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).UnregisterPropertyChangedCallback)(
                windows_core::Interface::as_raw(this),
                dp.param().abi(),
                token,
            )
            .ok()
        }
    }
    pub fn Dispatcher(&self) -> windows_core::Result<windows::UI::Core::CoreDispatcher> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Dispatcher)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Dispatching")]
    pub fn DispatcherQueue(
        &self,
    ) -> windows_core::Result<super::super::Dispatching::DispatcherQueue> {
        let this = &windows_core::Interface::cast::<super::IDependencyObject>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn new() -> windows_core::Result<XamlLight> {
        Self::IXamlLightFactory(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateInstance)(
                windows_core::Interface::as_raw(this),
                core::ptr::null_mut(),
                &mut core::ptr::null_mut(),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn GetId(&self) -> windows_core::Result<windows_core::HSTRING> {
        let this = &windows_core::Interface::cast::<IXamlLightOverrides>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetId)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| core::mem::transmute(result__))
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn OnConnected<P0>(&self, newelement: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::UIElement>,
    {
        let this = &windows_core::Interface::cast::<IXamlLightOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnConnected)(
                windows_core::Interface::as_raw(this),
                newelement.param().abi(),
            )
            .ok()
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn OnDisconnected<P0>(&self, oldelement: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::UIElement>,
    {
        let this = &windows_core::Interface::cast::<IXamlLightOverrides>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).OnDisconnected)(
                windows_core::Interface::as_raw(this),
                oldelement.param().abi(),
            )
            .ok()
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn CompositionLight(
        &self,
    ) -> windows_core::Result<super::super::Composition::CompositionLight> {
        let this = &windows_core::Interface::cast::<IXamlLightProtected>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CompositionLight)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn SetCompositionLight<P0>(&self, value: P0) -> windows_core::Result<()>
    where
        P0: windows_core::Param<super::super::Composition::CompositionLight>,
    {
        let this = &windows_core::Interface::cast::<IXamlLightProtected>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).SetCompositionLight)(
                windows_core::Interface::as_raw(this),
                value.param().abi(),
            )
            .ok()
        }
    }
    #[cfg(feature = "UI_Composition")]
    pub fn AddTargetElement<P1>(
        lightid: &windows_core::HSTRING,
        element: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::UIElement>,
    {
        Self::IXamlLightStatics(|this| unsafe {
            (windows_core::Interface::vtable(this).AddTargetElement)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(lightid),
                element.param().abi(),
            )
            .ok()
        })
    }
    #[cfg(feature = "UI_Composition")]
    pub fn RemoveTargetElement<P1>(
        lightid: &windows_core::HSTRING,
        element: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<super::UIElement>,
    {
        Self::IXamlLightStatics(|this| unsafe {
            (windows_core::Interface::vtable(this).RemoveTargetElement)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(lightid),
                element.param().abi(),
            )
            .ok()
        })
    }
    #[cfg(feature = "UI_Composition")]
    pub fn AddTargetBrush<P1>(
        lightid: &windows_core::HSTRING,
        brush: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<Brush>,
    {
        Self::IXamlLightStatics(|this| unsafe {
            (windows_core::Interface::vtable(this).AddTargetBrush)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(lightid),
                brush.param().abi(),
            )
            .ok()
        })
    }
    #[cfg(feature = "UI_Composition")]
    pub fn RemoveTargetBrush<P1>(
        lightid: &windows_core::HSTRING,
        brush: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<Brush>,
    {
        Self::IXamlLightStatics(|this| unsafe {
            (windows_core::Interface::vtable(this).RemoveTargetBrush)(
                windows_core::Interface::as_raw(this),
                core::mem::transmute_copy(lightid),
                brush.param().abi(),
            )
            .ok()
        })
    }
    fn IXamlLightFactory<R, F: FnOnce(&IXamlLightFactory) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<XamlLight, IXamlLightFactory> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    fn IXamlLightStatics<R, F: FnOnce(&IXamlLightStatics) -> windows_core::Result<R>>(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<XamlLight, IXamlLightStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for XamlLight {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IXamlLight>();
}
unsafe impl windows_core::Interface for XamlLight {
    type Vtable = <IXamlLight as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IXamlLight as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for XamlLight {
    const NAME: &'static str = "Microsoft.UI.Xaml.Media.XamlLight";
}
unsafe impl Send for XamlLight {}
unsafe impl Sync for XamlLight {}
