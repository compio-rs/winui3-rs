// Bindings generated by `windows-bindgen` 0.61.1

#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]

#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DispatcherExitDeferral(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    DispatcherExitDeferral,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl DispatcherExitDeferral {
    pub fn new() -> windows_core::Result<Self> {
        Self::IActivationFactory(|f| f.ActivateInstance::<Self>())
    }
    fn IActivationFactory<
        R,
        F: FnOnce(&windows_core::imp::IGenericFactory) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            DispatcherExitDeferral,
            windows_core::imp::IGenericFactory,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
    pub fn Complete(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Complete)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
}
impl windows_core::RuntimeType for DispatcherExitDeferral {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IDispatcherExitDeferral>();
}
unsafe impl windows_core::Interface for DispatcherExitDeferral {
    type Vtable = <IDispatcherExitDeferral as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IDispatcherExitDeferral as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for DispatcherExitDeferral {
    const NAME: &'static str = "Microsoft.UI.Dispatching.DispatcherExitDeferral";
}
unsafe impl Send for DispatcherExitDeferral {}
unsafe impl Sync for DispatcherExitDeferral {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DispatcherQueue(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    DispatcherQueue,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl DispatcherQueue {
    pub fn CreateTimer(&self) -> windows_core::Result<DispatcherQueueTimer> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateTimer)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn TryEnqueue<P0>(&self, callback: P0) -> windows_core::Result<bool>
    where
        P0: windows_core::Param<DispatcherQueueHandler>,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryEnqueue)(
                windows_core::Interface::as_raw(this),
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn TryEnqueueWithPriority<P1>(
        &self,
        priority: DispatcherQueuePriority,
        callback: P1,
    ) -> windows_core::Result<bool>
    where
        P1: windows_core::Param<DispatcherQueueHandler>,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).TryEnqueueWithPriority)(
                windows_core::Interface::as_raw(this),
                priority,
                callback.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn ShutdownStarting<P0>(&self, handler: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<
            windows::Foundation::TypedEventHandler<
                DispatcherQueue,
                DispatcherQueueShutdownStartingEventArgs,
            >,
        >,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ShutdownStarting)(
                windows_core::Interface::as_raw(this),
                handler.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveShutdownStarting(&self, token: i64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveShutdownStarting)(
                windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn ShutdownCompleted<P0>(&self, handler: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<
            windows::Foundation::TypedEventHandler<DispatcherQueue, windows_core::IInspectable>,
        >,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ShutdownCompleted)(
                windows_core::Interface::as_raw(this),
                handler.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveShutdownCompleted(&self, token: i64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveShutdownCompleted)(
                windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn HasThreadAccess(&self) -> windows_core::Result<bool> {
        let this = &windows_core::Interface::cast::<IDispatcherQueue2>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).HasThreadAccess)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn EnqueueEventLoopExit(&self) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IDispatcherQueue3>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).EnqueueEventLoopExit)(
                windows_core::Interface::as_raw(this),
            )
            .ok()
        }
    }
    pub fn EnsureSystemDispatcherQueue(&self) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IDispatcherQueue3>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).EnsureSystemDispatcherQueue)(
                windows_core::Interface::as_raw(this),
            )
            .ok()
        }
    }
    pub fn RunEventLoop(&self) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IDispatcherQueue3>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).RunEventLoop)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn RunEventLoopWithOptions<P1>(
        &self,
        options: DispatcherRunOptions,
        deferral: P1,
    ) -> windows_core::Result<()>
    where
        P1: windows_core::Param<DispatcherExitDeferral>,
    {
        let this = &windows_core::Interface::cast::<IDispatcherQueue3>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).RunEventLoopWithOptions)(
                windows_core::Interface::as_raw(this),
                options,
                deferral.param().abi(),
            )
            .ok()
        }
    }
    pub fn FrameworkShutdownStarting<P0>(&self, handler: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<
            windows::Foundation::TypedEventHandler<
                DispatcherQueue,
                DispatcherQueueShutdownStartingEventArgs,
            >,
        >,
    {
        let this = &windows_core::Interface::cast::<IDispatcherQueue3>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FrameworkShutdownStarting)(
                windows_core::Interface::as_raw(this),
                handler.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveFrameworkShutdownStarting(&self, token: i64) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IDispatcherQueue3>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveFrameworkShutdownStarting)(
                windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn FrameworkShutdownCompleted<P0>(&self, handler: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<
            windows::Foundation::TypedEventHandler<DispatcherQueue, windows_core::IInspectable>,
        >,
    {
        let this = &windows_core::Interface::cast::<IDispatcherQueue3>(self)?;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).FrameworkShutdownCompleted)(
                windows_core::Interface::as_raw(this),
                handler.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveFrameworkShutdownCompleted(&self, token: i64) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IDispatcherQueue3>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveFrameworkShutdownCompleted)(
                windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
    pub fn GetForCurrentThread() -> windows_core::Result<DispatcherQueue> {
        Self::IDispatcherQueueStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetForCurrentThread)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IDispatcherQueueStatics<
        R,
        F: FnOnce(&IDispatcherQueueStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<DispatcherQueue, IDispatcherQueueStatics> =
            windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for DispatcherQueue {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IDispatcherQueue>();
}
unsafe impl windows_core::Interface for DispatcherQueue {
    type Vtable = <IDispatcherQueue as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IDispatcherQueue as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for DispatcherQueue {
    const NAME: &'static str = "Microsoft.UI.Dispatching.DispatcherQueue";
}
unsafe impl Send for DispatcherQueue {}
unsafe impl Sync for DispatcherQueue {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DispatcherQueueController(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    DispatcherQueueController,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl DispatcherQueueController {
    pub fn DispatcherQueue(&self) -> windows_core::Result<DispatcherQueue> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).DispatcherQueue)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn ShutdownQueueAsync(&self) -> windows_core::Result<windows_future::IAsyncAction> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).ShutdownQueueAsync)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
    pub fn ShutdownQueue(&self) -> windows_core::Result<()> {
        let this = &windows_core::Interface::cast::<IDispatcherQueueController2>(self)?;
        unsafe {
            (windows_core::Interface::vtable(this).ShutdownQueue)(windows_core::Interface::as_raw(
                this,
            ))
            .ok()
        }
    }
    pub fn CreateOnDedicatedThread() -> windows_core::Result<DispatcherQueueController> {
        Self::IDispatcherQueueControllerStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateOnDedicatedThread)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    pub fn CreateOnCurrentThread() -> windows_core::Result<DispatcherQueueController> {
        Self::IDispatcherQueueControllerStatics(|this| unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).CreateOnCurrentThread)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        })
    }
    fn IDispatcherQueueControllerStatics<
        R,
        F: FnOnce(&IDispatcherQueueControllerStatics) -> windows_core::Result<R>,
    >(
        callback: F,
    ) -> windows_core::Result<R> {
        static SHARED: windows_core::imp::FactoryCache<
            DispatcherQueueController,
            IDispatcherQueueControllerStatics,
        > = windows_core::imp::FactoryCache::new();
        SHARED.call(callback)
    }
}
impl windows_core::RuntimeType for DispatcherQueueController {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IDispatcherQueueController>();
}
unsafe impl windows_core::Interface for DispatcherQueueController {
    type Vtable = <IDispatcherQueueController as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IDispatcherQueueController as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for DispatcherQueueController {
    const NAME: &'static str = "Microsoft.UI.Dispatching.DispatcherQueueController";
}
unsafe impl Send for DispatcherQueueController {}
unsafe impl Sync for DispatcherQueueController {}
windows_core::imp::define_interface!(
    DispatcherQueueHandler,
    DispatcherQueueHandler_Vtbl,
    0x2e0872a9_4e29_5f14_b688_fb96d5f9d5f8
);
impl windows_core::RuntimeType for DispatcherQueueHandler {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl DispatcherQueueHandler {
    pub fn new<F: FnMut() -> windows_core::Result<()> + Send + 'static>(invoke: F) -> Self {
        let com = DispatcherQueueHandlerBox {
            vtable: &DispatcherQueueHandlerBox::<F>::VTABLE,
            count: windows_core::imp::RefCount::new(1),
            invoke,
        };
        unsafe { core::mem::transmute(windows_core::imp::Box::new(com)) }
    }
    pub fn Invoke(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Invoke)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct DispatcherQueueHandler_Vtbl {
    base__: windows_core::IUnknown_Vtbl,
    Invoke: unsafe extern "system" fn(this: *mut core::ffi::c_void) -> windows_core::HRESULT,
}
#[repr(C)]
struct DispatcherQueueHandlerBox<F: FnMut() -> windows_core::Result<()> + Send + 'static> {
    vtable: *const DispatcherQueueHandler_Vtbl,
    invoke: F,
    count: windows_core::imp::RefCount,
}
impl<F: FnMut() -> windows_core::Result<()> + Send + 'static> DispatcherQueueHandlerBox<F> {
    const VTABLE: DispatcherQueueHandler_Vtbl = DispatcherQueueHandler_Vtbl {
        base__: windows_core::IUnknown_Vtbl {
            QueryInterface: Self::QueryInterface,
            AddRef: Self::AddRef,
            Release: Self::Release,
        },
        Invoke: Self::Invoke,
    };
    unsafe extern "system" fn QueryInterface(
        this: *mut core::ffi::c_void,
        iid: *const windows_core::GUID,
        interface: *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT {
        unsafe {
            let this = this as *mut *mut core::ffi::c_void as *mut Self;
            if iid.is_null() || interface.is_null() {
                return windows_core::HRESULT(-2147467261);
            }
            *interface = if *iid == <DispatcherQueueHandler as windows_core::Interface>::IID
                || *iid == <windows_core::IUnknown as windows_core::Interface>::IID
                || *iid == <windows_core::imp::IAgileObject as windows_core::Interface>::IID
            {
                &mut (*this).vtable as *mut _ as _
            } else if *iid == <windows_core::imp::IMarshal as windows_core::Interface>::IID {
                (*this).count.add_ref();
                return windows_core::imp::marshaler(
                    core::mem::transmute(&mut (*this).vtable as *mut _ as *mut core::ffi::c_void),
                    interface,
                );
            } else {
                core::ptr::null_mut()
            };
            if (*interface).is_null() {
                windows_core::HRESULT(-2147467262)
            } else {
                (*this).count.add_ref();
                windows_core::HRESULT(0)
            }
        }
    }
    unsafe extern "system" fn AddRef(this: *mut core::ffi::c_void) -> u32 {
        unsafe {
            let this = this as *mut *mut core::ffi::c_void as *mut Self;
            (*this).count.add_ref()
        }
    }
    unsafe extern "system" fn Release(this: *mut core::ffi::c_void) -> u32 {
        unsafe {
            let this = this as *mut *mut core::ffi::c_void as *mut Self;
            let remaining = (*this).count.release();
            if remaining == 0 {
                let _ = windows_core::imp::Box::from_raw(this);
            }
            remaining
        }
    }
    unsafe extern "system" fn Invoke(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
        unsafe {
            let this = &mut *(this as *mut *mut core::ffi::c_void as *mut Self);
            (this.invoke)().into()
        }
    }
}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DispatcherQueuePriority(pub i32);
impl DispatcherQueuePriority {
    pub const Low: Self = Self(-10i32);
    pub const Normal: Self = Self(0i32);
    pub const High: Self = Self(10i32);
}
impl windows_core::TypeKind for DispatcherQueuePriority {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for DispatcherQueuePriority {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::from_slice(
        b"enum(Microsoft.UI.Dispatching.DispatcherQueuePriority;i4)",
    );
}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DispatcherQueueShutdownStartingEventArgs(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    DispatcherQueueShutdownStartingEventArgs,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl DispatcherQueueShutdownStartingEventArgs {
    pub fn GetDeferral(&self) -> windows_core::Result<windows::Foundation::Deferral> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).GetDeferral)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .and_then(|| windows_core::Type::from_abi(result__))
        }
    }
}
impl windows_core::RuntimeType for DispatcherQueueShutdownStartingEventArgs {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::for_class::<
        Self,
        IDispatcherQueueShutdownStartingEventArgs,
    >();
}
unsafe impl windows_core::Interface for DispatcherQueueShutdownStartingEventArgs {
    type Vtable = <IDispatcherQueueShutdownStartingEventArgs as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID =
        <IDispatcherQueueShutdownStartingEventArgs as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for DispatcherQueueShutdownStartingEventArgs {
    const NAME: &'static str = "Microsoft.UI.Dispatching.DispatcherQueueShutdownStartingEventArgs";
}
unsafe impl Send for DispatcherQueueShutdownStartingEventArgs {}
unsafe impl Sync for DispatcherQueueShutdownStartingEventArgs {}
#[repr(transparent)]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct DispatcherQueueTimer(windows_core::IUnknown);
windows_core::imp::interface_hierarchy!(
    DispatcherQueueTimer,
    windows_core::IUnknown,
    windows_core::IInspectable
);
impl DispatcherQueueTimer {
    pub fn Interval(&self) -> windows_core::Result<windows::Foundation::TimeSpan> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Interval)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetInterval(&self, value: windows::Foundation::TimeSpan) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetInterval)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn IsRunning(&self) -> windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IsRunning)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn IsRepeating(&self) -> windows_core::Result<bool> {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).IsRepeating)(
                windows_core::Interface::as_raw(this),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn SetIsRepeating(&self, value: bool) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).SetIsRepeating)(
                windows_core::Interface::as_raw(this),
                value,
            )
            .ok()
        }
    }
    pub fn Start(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Start)(windows_core::Interface::as_raw(this))
                .ok()
        }
    }
    pub fn Stop(&self) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).Stop)(windows_core::Interface::as_raw(this)).ok()
        }
    }
    pub fn Tick<P0>(&self, handler: P0) -> windows_core::Result<i64>
    where
        P0: windows_core::Param<
            windows::Foundation::TypedEventHandler<
                DispatcherQueueTimer,
                windows_core::IInspectable,
            >,
        >,
    {
        let this = self;
        unsafe {
            let mut result__ = core::mem::zeroed();
            (windows_core::Interface::vtable(this).Tick)(
                windows_core::Interface::as_raw(this),
                handler.param().abi(),
                &mut result__,
            )
            .map(|| result__)
        }
    }
    pub fn RemoveTick(&self, token: i64) -> windows_core::Result<()> {
        let this = self;
        unsafe {
            (windows_core::Interface::vtable(this).RemoveTick)(
                windows_core::Interface::as_raw(this),
                token,
            )
            .ok()
        }
    }
}
impl windows_core::RuntimeType for DispatcherQueueTimer {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_class::<Self, IDispatcherQueueTimer>();
}
unsafe impl windows_core::Interface for DispatcherQueueTimer {
    type Vtable = <IDispatcherQueueTimer as windows_core::Interface>::Vtable;
    const IID: windows_core::GUID = <IDispatcherQueueTimer as windows_core::Interface>::IID;
}
impl windows_core::RuntimeName for DispatcherQueueTimer {
    const NAME: &'static str = "Microsoft.UI.Dispatching.DispatcherQueueTimer";
}
unsafe impl Send for DispatcherQueueTimer {}
unsafe impl Sync for DispatcherQueueTimer {}
#[repr(transparent)]
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
pub struct DispatcherRunOptions(pub u32);
impl DispatcherRunOptions {
    pub const None: Self = Self(0u32);
    pub const ContinueOnQuit: Self = Self(1u32);
    pub const QuitOnlyLocalLoop: Self = Self(2u32);
}
impl windows_core::TypeKind for DispatcherRunOptions {
    type TypeKind = windows_core::CopyType;
}
impl windows_core::RuntimeType for DispatcherRunOptions {
    const SIGNATURE: windows_core::imp::ConstBuffer = windows_core::imp::ConstBuffer::from_slice(
        b"enum(Microsoft.UI.Dispatching.DispatcherRunOptions;u4)",
    );
}
impl DispatcherRunOptions {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl core::ops::BitOr for DispatcherRunOptions {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl core::ops::BitAnd for DispatcherRunOptions {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl core::ops::BitOrAssign for DispatcherRunOptions {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl core::ops::BitAndAssign for DispatcherRunOptions {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl core::ops::Not for DispatcherRunOptions {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
windows_core::imp::define_interface!(
    IDispatcherExitDeferral,
    IDispatcherExitDeferral_Vtbl,
    0x910b5aac_3310_563e_8418_f3005579729e
);
impl windows_core::RuntimeType for IDispatcherExitDeferral {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDispatcherExitDeferral {
    const NAME: &'static str = "Microsoft.UI.Dispatching.IDispatcherExitDeferral";
}
pub trait IDispatcherExitDeferral_Impl: windows_core::IUnknownImpl {
    fn Complete(&self) -> windows_core::Result<()>;
}
impl IDispatcherExitDeferral_Vtbl {
    pub const fn new<Identity: IDispatcherExitDeferral_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Complete<
            Identity: IDispatcherExitDeferral_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherExitDeferral_Impl::Complete(this).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IDispatcherExitDeferral, OFFSET>(
            ),
            Complete: Complete::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDispatcherExitDeferral as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDispatcherExitDeferral_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Complete: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IDispatcherQueue,
    IDispatcherQueue_Vtbl,
    0xf6ebf8fa_be1c_5bf6_a467_73da28738ae8
);
impl windows_core::RuntimeType for IDispatcherQueue {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDispatcherQueue {
    const NAME: &'static str = "Microsoft.UI.Dispatching.IDispatcherQueue";
}
pub trait IDispatcherQueue_Impl: windows_core::IUnknownImpl {
    fn CreateTimer(&self) -> windows_core::Result<DispatcherQueueTimer>;
    fn TryEnqueue(
        &self,
        callback: windows_core::Ref<'_, DispatcherQueueHandler>,
    ) -> windows_core::Result<bool>;
    fn TryEnqueueWithPriority(
        &self,
        priority: DispatcherQueuePriority,
        callback: windows_core::Ref<'_, DispatcherQueueHandler>,
    ) -> windows_core::Result<bool>;
    fn ShutdownStarting(
        &self,
        handler: windows_core::Ref<
            '_,
            windows::Foundation::TypedEventHandler<
                DispatcherQueue,
                DispatcherQueueShutdownStartingEventArgs,
            >,
        >,
    ) -> windows_core::Result<i64>;
    fn RemoveShutdownStarting(&self, token: i64) -> windows_core::Result<()>;
    fn ShutdownCompleted(
        &self,
        handler: windows_core::Ref<
            '_,
            windows::Foundation::TypedEventHandler<DispatcherQueue, windows_core::IInspectable>,
        >,
    ) -> windows_core::Result<i64>;
    fn RemoveShutdownCompleted(&self, token: i64) -> windows_core::Result<()>;
}
impl IDispatcherQueue_Vtbl {
    pub const fn new<Identity: IDispatcherQueue_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn CreateTimer<
            Identity: IDispatcherQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueue_Impl::CreateTimer(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TryEnqueue<
            Identity: IDispatcherQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            callback: *mut core::ffi::c_void,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueue_Impl::TryEnqueue(this, core::mem::transmute_copy(&callback))
                {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn TryEnqueueWithPriority<
            Identity: IDispatcherQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            priority: DispatcherQueuePriority,
            callback: *mut core::ffi::c_void,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueue_Impl::TryEnqueueWithPriority(
                    this,
                    priority,
                    core::mem::transmute_copy(&callback),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ShutdownStarting<
            Identity: IDispatcherQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            handler: *mut core::ffi::c_void,
            result__: *mut i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueue_Impl::ShutdownStarting(
                    this,
                    core::mem::transmute_copy(&handler),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveShutdownStarting<
            Identity: IDispatcherQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            token: i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueue_Impl::RemoveShutdownStarting(this, token).into()
            }
        }
        unsafe extern "system" fn ShutdownCompleted<
            Identity: IDispatcherQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            handler: *mut core::ffi::c_void,
            result__: *mut i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueue_Impl::ShutdownCompleted(
                    this,
                    core::mem::transmute_copy(&handler),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveShutdownCompleted<
            Identity: IDispatcherQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            token: i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueue_Impl::RemoveShutdownCompleted(this, token).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IDispatcherQueue, OFFSET>(),
            CreateTimer: CreateTimer::<Identity, OFFSET>,
            TryEnqueue: TryEnqueue::<Identity, OFFSET>,
            TryEnqueueWithPriority: TryEnqueueWithPriority::<Identity, OFFSET>,
            ShutdownStarting: ShutdownStarting::<Identity, OFFSET>,
            RemoveShutdownStarting: RemoveShutdownStarting::<Identity, OFFSET>,
            ShutdownCompleted: ShutdownCompleted::<Identity, OFFSET>,
            RemoveShutdownCompleted: RemoveShutdownCompleted::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDispatcherQueue as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDispatcherQueue_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CreateTimer: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub TryEnqueue: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut bool,
    ) -> windows_core::HRESULT,
    pub TryEnqueueWithPriority: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        DispatcherQueuePriority,
        *mut core::ffi::c_void,
        *mut bool,
    ) -> windows_core::HRESULT,
    pub ShutdownStarting: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i64,
    ) -> windows_core::HRESULT,
    pub RemoveShutdownStarting:
        unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    pub ShutdownCompleted: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i64,
    ) -> windows_core::HRESULT,
    pub RemoveShutdownCompleted:
        unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IDispatcherQueue2,
    IDispatcherQueue2_Vtbl,
    0x0cf48751_f1ac_59b8_ba52_6ce7a1444d6f
);
impl windows_core::RuntimeType for IDispatcherQueue2 {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDispatcherQueue2 {
    const NAME: &'static str = "Microsoft.UI.Dispatching.IDispatcherQueue2";
}
pub trait IDispatcherQueue2_Impl: windows_core::IUnknownImpl {
    fn HasThreadAccess(&self) -> windows_core::Result<bool>;
}
impl IDispatcherQueue2_Vtbl {
    pub const fn new<Identity: IDispatcherQueue2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn HasThreadAccess<
            Identity: IDispatcherQueue2_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueue2_Impl::HasThreadAccess(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IDispatcherQueue2, OFFSET>(),
            HasThreadAccess: HasThreadAccess::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDispatcherQueue2 as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDispatcherQueue2_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub HasThreadAccess:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut bool) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IDispatcherQueue3,
    IDispatcherQueue3_Vtbl,
    0x14a7a175_5c27_5a35_b079_21960cf764a8
);
impl windows_core::RuntimeType for IDispatcherQueue3 {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDispatcherQueue3 {
    const NAME: &'static str = "Microsoft.UI.Dispatching.IDispatcherQueue3";
}
pub trait IDispatcherQueue3_Impl: windows_core::IUnknownImpl {
    fn EnqueueEventLoopExit(&self) -> windows_core::Result<()>;
    fn EnsureSystemDispatcherQueue(&self) -> windows_core::Result<()>;
    fn RunEventLoop(&self) -> windows_core::Result<()>;
    fn RunEventLoopWithOptions(
        &self,
        options: DispatcherRunOptions,
        deferral: windows_core::Ref<'_, DispatcherExitDeferral>,
    ) -> windows_core::Result<()>;
    fn FrameworkShutdownStarting(
        &self,
        handler: windows_core::Ref<
            '_,
            windows::Foundation::TypedEventHandler<
                DispatcherQueue,
                DispatcherQueueShutdownStartingEventArgs,
            >,
        >,
    ) -> windows_core::Result<i64>;
    fn RemoveFrameworkShutdownStarting(&self, token: i64) -> windows_core::Result<()>;
    fn FrameworkShutdownCompleted(
        &self,
        handler: windows_core::Ref<
            '_,
            windows::Foundation::TypedEventHandler<DispatcherQueue, windows_core::IInspectable>,
        >,
    ) -> windows_core::Result<i64>;
    fn RemoveFrameworkShutdownCompleted(&self, token: i64) -> windows_core::Result<()>;
}
impl IDispatcherQueue3_Vtbl {
    pub const fn new<Identity: IDispatcherQueue3_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn EnqueueEventLoopExit<
            Identity: IDispatcherQueue3_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueue3_Impl::EnqueueEventLoopExit(this).into()
            }
        }
        unsafe extern "system" fn EnsureSystemDispatcherQueue<
            Identity: IDispatcherQueue3_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueue3_Impl::EnsureSystemDispatcherQueue(this).into()
            }
        }
        unsafe extern "system" fn RunEventLoop<
            Identity: IDispatcherQueue3_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueue3_Impl::RunEventLoop(this).into()
            }
        }
        unsafe extern "system" fn RunEventLoopWithOptions<
            Identity: IDispatcherQueue3_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            options: DispatcherRunOptions,
            deferral: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueue3_Impl::RunEventLoopWithOptions(
                    this,
                    options,
                    core::mem::transmute_copy(&deferral),
                )
                .into()
            }
        }
        unsafe extern "system" fn FrameworkShutdownStarting<
            Identity: IDispatcherQueue3_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            handler: *mut core::ffi::c_void,
            result__: *mut i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueue3_Impl::FrameworkShutdownStarting(
                    this,
                    core::mem::transmute_copy(&handler),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveFrameworkShutdownStarting<
            Identity: IDispatcherQueue3_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            token: i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueue3_Impl::RemoveFrameworkShutdownStarting(this, token).into()
            }
        }
        unsafe extern "system" fn FrameworkShutdownCompleted<
            Identity: IDispatcherQueue3_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            handler: *mut core::ffi::c_void,
            result__: *mut i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueue3_Impl::FrameworkShutdownCompleted(
                    this,
                    core::mem::transmute_copy(&handler),
                ) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveFrameworkShutdownCompleted<
            Identity: IDispatcherQueue3_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            token: i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueue3_Impl::RemoveFrameworkShutdownCompleted(this, token).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IDispatcherQueue3, OFFSET>(),
            EnqueueEventLoopExit: EnqueueEventLoopExit::<Identity, OFFSET>,
            EnsureSystemDispatcherQueue: EnsureSystemDispatcherQueue::<Identity, OFFSET>,
            RunEventLoop: RunEventLoop::<Identity, OFFSET>,
            RunEventLoopWithOptions: RunEventLoopWithOptions::<Identity, OFFSET>,
            FrameworkShutdownStarting: FrameworkShutdownStarting::<Identity, OFFSET>,
            RemoveFrameworkShutdownStarting: RemoveFrameworkShutdownStarting::<Identity, OFFSET>,
            FrameworkShutdownCompleted: FrameworkShutdownCompleted::<Identity, OFFSET>,
            RemoveFrameworkShutdownCompleted: RemoveFrameworkShutdownCompleted::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDispatcherQueue3 as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDispatcherQueue3_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub EnqueueEventLoopExit:
        unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub EnsureSystemDispatcherQueue:
        unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub RunEventLoop: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub RunEventLoopWithOptions: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        DispatcherRunOptions,
        *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub FrameworkShutdownStarting: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i64,
    ) -> windows_core::HRESULT,
    pub RemoveFrameworkShutdownStarting:
        unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
    pub FrameworkShutdownCompleted: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i64,
    ) -> windows_core::HRESULT,
    pub RemoveFrameworkShutdownCompleted:
        unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IDispatcherQueueController,
    IDispatcherQueueController_Vtbl,
    0xbce8178d_2183_584c_9e5b_f9366f6ae484
);
impl windows_core::RuntimeType for IDispatcherQueueController {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDispatcherQueueController {
    const NAME: &'static str = "Microsoft.UI.Dispatching.IDispatcherQueueController";
}
pub trait IDispatcherQueueController_Impl: windows_core::IUnknownImpl {
    fn DispatcherQueue(&self) -> windows_core::Result<DispatcherQueue>;
    fn ShutdownQueueAsync(&self) -> windows_core::Result<windows_future::IAsyncAction>;
}
impl IDispatcherQueueController_Vtbl {
    pub const fn new<Identity: IDispatcherQueueController_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn DispatcherQueue<
            Identity: IDispatcherQueueController_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueueController_Impl::DispatcherQueue(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn ShutdownQueueAsync<
            Identity: IDispatcherQueueController_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueueController_Impl::ShutdownQueueAsync(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IDispatcherQueueController,
                OFFSET,
            >(),
            DispatcherQueue: DispatcherQueue::<Identity, OFFSET>,
            ShutdownQueueAsync: ShutdownQueueAsync::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDispatcherQueueController as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDispatcherQueueController_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub DispatcherQueue: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub ShutdownQueueAsync: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IDispatcherQueueController2,
    IDispatcherQueueController2_Vtbl,
    0x4c68ee2a_1cb1_5591_a3a2_9b590b8f8b9a
);
impl windows_core::RuntimeType for IDispatcherQueueController2 {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDispatcherQueueController2 {
    const NAME: &'static str = "Microsoft.UI.Dispatching.IDispatcherQueueController2";
}
pub trait IDispatcherQueueController2_Impl: windows_core::IUnknownImpl {
    fn ShutdownQueue(&self) -> windows_core::Result<()>;
}
impl IDispatcherQueueController2_Vtbl {
    pub const fn new<Identity: IDispatcherQueueController2_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn ShutdownQueue<
            Identity: IDispatcherQueueController2_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueueController2_Impl::ShutdownQueue(this).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IDispatcherQueueController2,
                OFFSET,
            >(),
            ShutdownQueue: ShutdownQueue::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDispatcherQueueController2 as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDispatcherQueueController2_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub ShutdownQueue: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IDispatcherQueueControllerStatics,
    IDispatcherQueueControllerStatics_Vtbl,
    0xf18d6145_722b_593d_bcf2_a61e713f0037
);
impl windows_core::RuntimeType for IDispatcherQueueControllerStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDispatcherQueueControllerStatics {
    const NAME: &'static str = "Microsoft.UI.Dispatching.IDispatcherQueueControllerStatics";
}
pub trait IDispatcherQueueControllerStatics_Impl: windows_core::IUnknownImpl {
    fn CreateOnDedicatedThread(&self) -> windows_core::Result<DispatcherQueueController>;
    fn CreateOnCurrentThread(&self) -> windows_core::Result<DispatcherQueueController>;
}
impl IDispatcherQueueControllerStatics_Vtbl {
    pub const fn new<Identity: IDispatcherQueueControllerStatics_Impl, const OFFSET: isize>() -> Self
    {
        unsafe extern "system" fn CreateOnDedicatedThread<
            Identity: IDispatcherQueueControllerStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueueControllerStatics_Impl::CreateOnDedicatedThread(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn CreateOnCurrentThread<
            Identity: IDispatcherQueueControllerStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueueControllerStatics_Impl::CreateOnCurrentThread(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IDispatcherQueueControllerStatics,
                OFFSET,
            >(),
            CreateOnDedicatedThread: CreateOnDedicatedThread::<Identity, OFFSET>,
            CreateOnCurrentThread: CreateOnCurrentThread::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDispatcherQueueControllerStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDispatcherQueueControllerStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub CreateOnDedicatedThread: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
    pub CreateOnCurrentThread: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IDispatcherQueueShutdownStartingEventArgs,
    IDispatcherQueueShutdownStartingEventArgs_Vtbl,
    0x32519be5_072b_5660_a70e_8835c9b8157d
);
impl windows_core::RuntimeType for IDispatcherQueueShutdownStartingEventArgs {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDispatcherQueueShutdownStartingEventArgs {
    const NAME: &'static str = "Microsoft.UI.Dispatching.IDispatcherQueueShutdownStartingEventArgs";
}
pub trait IDispatcherQueueShutdownStartingEventArgs_Impl: windows_core::IUnknownImpl {
    fn GetDeferral(&self) -> windows_core::Result<windows::Foundation::Deferral>;
}
impl IDispatcherQueueShutdownStartingEventArgs_Vtbl {
    pub const fn new<
        Identity: IDispatcherQueueShutdownStartingEventArgs_Impl,
        const OFFSET: isize,
    >() -> Self {
        unsafe extern "system" fn GetDeferral<
            Identity: IDispatcherQueueShutdownStartingEventArgs_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueueShutdownStartingEventArgs_Impl::GetDeferral(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<
                Identity,
                IDispatcherQueueShutdownStartingEventArgs,
                OFFSET,
            >(),
            GetDeferral: GetDeferral::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDispatcherQueueShutdownStartingEventArgs as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDispatcherQueueShutdownStartingEventArgs_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub GetDeferral: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IDispatcherQueueStatics,
    IDispatcherQueueStatics_Vtbl,
    0xcd3382ea_a455_5124_b63a_ca40d34ca23c
);
impl windows_core::RuntimeType for IDispatcherQueueStatics {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDispatcherQueueStatics {
    const NAME: &'static str = "Microsoft.UI.Dispatching.IDispatcherQueueStatics";
}
pub trait IDispatcherQueueStatics_Impl: windows_core::IUnknownImpl {
    fn GetForCurrentThread(&self) -> windows_core::Result<DispatcherQueue>;
}
impl IDispatcherQueueStatics_Vtbl {
    pub const fn new<Identity: IDispatcherQueueStatics_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn GetForCurrentThread<
            Identity: IDispatcherQueueStatics_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueueStatics_Impl::GetForCurrentThread(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        core::mem::forget(ok__);
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IDispatcherQueueStatics, OFFSET>(
            ),
            GetForCurrentThread: GetForCurrentThread::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDispatcherQueueStatics as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDispatcherQueueStatics_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub GetForCurrentThread: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut *mut core::ffi::c_void,
    ) -> windows_core::HRESULT,
}
windows_core::imp::define_interface!(
    IDispatcherQueueTimer,
    IDispatcherQueueTimer_Vtbl,
    0xad4d63fd_88fe_541f_ac11_bf2dc1ed2ce5
);
impl windows_core::RuntimeType for IDispatcherQueueTimer {
    const SIGNATURE: windows_core::imp::ConstBuffer =
        windows_core::imp::ConstBuffer::for_interface::<Self>();
}
impl windows_core::RuntimeName for IDispatcherQueueTimer {
    const NAME: &'static str = "Microsoft.UI.Dispatching.IDispatcherQueueTimer";
}
pub trait IDispatcherQueueTimer_Impl: windows_core::IUnknownImpl {
    fn Interval(&self) -> windows_core::Result<windows::Foundation::TimeSpan>;
    fn SetInterval(&self, value: &windows::Foundation::TimeSpan) -> windows_core::Result<()>;
    fn IsRunning(&self) -> windows_core::Result<bool>;
    fn IsRepeating(&self) -> windows_core::Result<bool>;
    fn SetIsRepeating(&self, value: bool) -> windows_core::Result<()>;
    fn Start(&self) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
    fn Tick(
        &self,
        handler: windows_core::Ref<
            '_,
            windows::Foundation::TypedEventHandler<
                DispatcherQueueTimer,
                windows_core::IInspectable,
            >,
        >,
    ) -> windows_core::Result<i64>;
    fn RemoveTick(&self, token: i64) -> windows_core::Result<()>;
}
impl IDispatcherQueueTimer_Vtbl {
    pub const fn new<Identity: IDispatcherQueueTimer_Impl, const OFFSET: isize>() -> Self {
        unsafe extern "system" fn Interval<
            Identity: IDispatcherQueueTimer_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut windows::Foundation::TimeSpan,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueueTimer_Impl::Interval(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetInterval<
            Identity: IDispatcherQueueTimer_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: windows::Foundation::TimeSpan,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueueTimer_Impl::SetInterval(this, core::mem::transmute(&value)).into()
            }
        }
        unsafe extern "system" fn IsRunning<
            Identity: IDispatcherQueueTimer_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueueTimer_Impl::IsRunning(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn IsRepeating<
            Identity: IDispatcherQueueTimer_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            result__: *mut bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueueTimer_Impl::IsRepeating(this) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn SetIsRepeating<
            Identity: IDispatcherQueueTimer_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            value: bool,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueueTimer_Impl::SetIsRepeating(this, value).into()
            }
        }
        unsafe extern "system" fn Start<
            Identity: IDispatcherQueueTimer_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueueTimer_Impl::Start(this).into()
            }
        }
        unsafe extern "system" fn Stop<
            Identity: IDispatcherQueueTimer_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueueTimer_Impl::Stop(this).into()
            }
        }
        unsafe extern "system" fn Tick<
            Identity: IDispatcherQueueTimer_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            handler: *mut core::ffi::c_void,
            result__: *mut i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                match IDispatcherQueueTimer_Impl::Tick(this, core::mem::transmute_copy(&handler)) {
                    Ok(ok__) => {
                        result__.write(core::mem::transmute_copy(&ok__));
                        windows_core::HRESULT(0)
                    }
                    Err(err) => err.into(),
                }
            }
        }
        unsafe extern "system" fn RemoveTick<
            Identity: IDispatcherQueueTimer_Impl,
            const OFFSET: isize,
        >(
            this: *mut core::ffi::c_void,
            token: i64,
        ) -> windows_core::HRESULT {
            unsafe {
                let this: &Identity =
                    &*((this as *const *const ()).offset(OFFSET) as *const Identity);
                IDispatcherQueueTimer_Impl::RemoveTick(this, token).into()
            }
        }
        Self {
            base__: windows_core::IInspectable_Vtbl::new::<Identity, IDispatcherQueueTimer, OFFSET>(
            ),
            Interval: Interval::<Identity, OFFSET>,
            SetInterval: SetInterval::<Identity, OFFSET>,
            IsRunning: IsRunning::<Identity, OFFSET>,
            IsRepeating: IsRepeating::<Identity, OFFSET>,
            SetIsRepeating: SetIsRepeating::<Identity, OFFSET>,
            Start: Start::<Identity, OFFSET>,
            Stop: Stop::<Identity, OFFSET>,
            Tick: Tick::<Identity, OFFSET>,
            RemoveTick: RemoveTick::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDispatcherQueueTimer as windows_core::Interface>::IID
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct IDispatcherQueueTimer_Vtbl {
    pub base__: windows_core::IInspectable_Vtbl,
    pub Interval: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut windows::Foundation::TimeSpan,
    ) -> windows_core::HRESULT,
    pub SetInterval: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        windows::Foundation::TimeSpan,
    ) -> windows_core::HRESULT,
    pub IsRunning:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut bool) -> windows_core::HRESULT,
    pub IsRepeating:
        unsafe extern "system" fn(*mut core::ffi::c_void, *mut bool) -> windows_core::HRESULT,
    pub SetIsRepeating:
        unsafe extern "system" fn(*mut core::ffi::c_void, bool) -> windows_core::HRESULT,
    pub Start: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Stop: unsafe extern "system" fn(*mut core::ffi::c_void) -> windows_core::HRESULT,
    pub Tick: unsafe extern "system" fn(
        *mut core::ffi::c_void,
        *mut core::ffi::c_void,
        *mut i64,
    ) -> windows_core::HRESULT,
    pub RemoveTick: unsafe extern "system" fn(*mut core::ffi::c_void, i64) -> windows_core::HRESULT,
}
